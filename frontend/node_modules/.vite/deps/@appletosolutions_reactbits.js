import {
  BloomEffect,
  Effect,
  EffectComposer,
  EffectPass,
  RenderPass,
  SMAAEffect,
  SMAAPreset
} from "./chunk-N7ABRTLU.js";
import {
  AnimatePresence,
  animate,
  motion,
  useAnimation,
  useAnimationFrame,
  useInView,
  useMotionValue,
  useMotionValueEvent,
  useScroll,
  useSpring,
  useTransform,
  useVelocity
} from "./chunk-YRM36UNM.js";
import {
  require_jsx_runtime
} from "./chunk-7CC4PDZ5.js";
import {
  require_react
} from "./chunk-YHPANKLD.js";
import {
  Camera,
  Color,
  Geometry,
  Mesh,
  Plane,
  Polyline,
  Program,
  Renderer,
  Texture,
  Transform,
  Triangle,
  Vec3
} from "./chunk-KRKCPJQO.js";
import {
  ACESFilmicToneMapping,
  AmbientLight,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  CanvasTexture,
  ClampToEdgeWrapping,
  Clock,
  Color as Color2,
  DataTexture,
  DoubleSide,
  FloatType,
  Fog,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedMesh,
  LineCurve3,
  LinearFilter,
  LoadingManager,
  MathUtils,
  Mesh as Mesh2,
  MeshLambertMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  NearestFilter,
  Object3D,
  OrthographicCamera,
  PMREMGenerator,
  PerspectiveCamera,
  Plane as Plane2,
  PlaneGeometry,
  PointLight,
  RGBAFormat,
  Raycaster,
  SRGBColorSpace,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  TextureLoader,
  TubeGeometry,
  Uniform,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderer
} from "./chunk-HXPAPZVQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-PR4QN5HX.js";

// optional-peer-dep:__vite-optional-peer-dep:gsap:@appletosolutions/reactbits
var require_reactbits = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:gsap:@appletosolutions/reactbits"() {
    throw new Error(`Could not resolve "gsap" imported by "@appletosolutions/reactbits". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:matter-js:@appletosolutions/reactbits
var require_reactbits2 = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:matter-js:@appletosolutions/reactbits"() {
    throw new Error(`Could not resolve "matter-js" imported by "@appletosolutions/reactbits". Is it installed?`);
  }
});

// node_modules/@appletosolutions/reactbits/dist/index.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());
var import_gsap = __toESM(require_reactbits());

// optional-peer-dep:__vite-optional-peer-dep:gsap/ScrollTrigger:@appletosolutions/reactbits
throw new Error(`Could not resolve "gsap/ScrollTrigger" imported by "@appletosolutions/reactbits". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:gsap/SplitText:@appletosolutions/reactbits
throw new Error(`Could not resolve "gsap/SplitText" imported by "@appletosolutions/reactbits". Is it installed?`);

// node_modules/@appletosolutions/reactbits/dist/index.es.js
var import_matter_js = __toESM(require_reactbits2());

// optional-peer-dep:__vite-optional-peer-dep:gsap/ScrambleTextPlugin:@appletosolutions/reactbits
throw new Error(`Could not resolve "gsap/ScrambleTextPlugin" imported by "@appletosolutions/reactbits". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:@react-three/fiber:@appletosolutions/reactbits
throw new Error(`Could not resolve "@react-three/fiber" imported by "@appletosolutions/reactbits". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:@react-three/drei:@appletosolutions/reactbits
throw new Error(`Could not resolve "@react-three/drei" imported by "@appletosolutions/reactbits". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:three-stdlib:@appletosolutions/reactbits
throw new Error(`Could not resolve "three-stdlib" imported by "@appletosolutions/reactbits". Is it installed?`);

// node_modules/react-icons/lib/iconBase.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/react-icons/lib/iconContext.mjs
var import_react = __toESM(require_react(), 1);
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = import_react.default.createContext && import_react.default.createContext(DefaultContext);

// node_modules/react-icons/lib/iconBase.mjs
var _excluded = ["attr", "size", "title"];
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  for (var key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function Tree2Element(tree) {
  return tree && tree.map((node, i2) => import_react2.default.createElement(node.tag, _objectSpread({
    key: i2
  }, node.attr), Tree2Element(node.child)));
}
function GenIcon(data) {
  return (props) => import_react2.default.createElement(IconBase, _extends({
    attr: _objectSpread({}, data.attr)
  }, props), Tree2Element(data.child));
}
function IconBase(props) {
  var elem = (conf) => {
    var {
      attr,
      size,
      title
    } = props, svgProps = _objectWithoutProperties(props, _excluded);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + " " : "") + props.className;
    return import_react2.default.createElement("svg", _extends({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: _objectSpread(_objectSpread({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && import_react2.default.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? import_react2.default.createElement(IconContext.Consumer, null, (conf) => elem(conf)) : elem(DefaultContext);
}

// node_modules/react-icons/fi/index.mjs
function FiCircle(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "10" }, "child": [] }] })(props);
}
function FiCode(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polyline", "attr": { "points": "16 18 22 12 16 6" }, "child": [] }, { "tag": "polyline", "attr": { "points": "8 6 2 12 8 18" }, "child": [] }] })(props);
}
function FiFileText(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" }, "child": [] }, { "tag": "polyline", "attr": { "points": "14 2 14 8 20 8" }, "child": [] }, { "tag": "line", "attr": { "x1": "16", "y1": "13", "x2": "8", "y2": "13" }, "child": [] }, { "tag": "line", "attr": { "x1": "16", "y1": "17", "x2": "8", "y2": "17" }, "child": [] }, { "tag": "polyline", "attr": { "points": "10 9 9 9 8 9" }, "child": [] }] })(props);
}
function FiLayers(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "polygon", "attr": { "points": "12 2 2 7 12 12 22 7 12 2" }, "child": [] }, { "tag": "polyline", "attr": { "points": "2 17 12 22 22 17" }, "child": [] }, { "tag": "polyline", "attr": { "points": "2 12 12 17 22 12" }, "child": [] }] })(props);
}
function FiLayout(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "rect", "attr": { "x": "3", "y": "3", "width": "18", "height": "18", "rx": "2", "ry": "2" }, "child": [] }, { "tag": "line", "attr": { "x1": "3", "y1": "9", "x2": "21", "y2": "9" }, "child": [] }, { "tag": "line", "attr": { "x1": "9", "y1": "21", "x2": "9", "y2": "9" }, "child": [] }] })(props);
}

// optional-peer-dep:__vite-optional-peer-dep:gsap/Observer:@appletosolutions/reactbits
throw new Error(`Could not resolve "gsap/Observer" imported by "@appletosolutions/reactbits". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:@chakra-ui/react:@appletosolutions/reactbits
throw new Error(`Could not resolve "@chakra-ui/react" imported by "@appletosolutions/reactbits". Is it installed?`);

// node_modules/react-icons/ri/index.mjs
function RiVolumeDownFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M8.88889 16.0001H5C4.44772 16.0001 4 15.5524 4 15.0001V9.00007C4 8.44778 4.44772 8.00007 5 8.00007H8.88889L14.1834 3.66821C14.3971 3.49335 14.7121 3.52485 14.887 3.73857C14.9601 3.8279 15 3.93977 15 4.05519V19.9449C15 20.2211 14.7761 20.4449 14.5 20.4449C14.3846 20.4449 14.2727 20.405 14.1834 20.3319L8.88889 16.0001ZM18.8631 16.5911L17.4411 15.1691C18.3892 14.4376 19 13.2902 19 12.0001C19 10.5697 18.2493 9.31476 17.1203 8.60766L18.5589 7.16906C20.0396 8.26166 21 10.0187 21 12.0001C21 13.8422 20.1698 15.4905 18.8631 16.5911Z" }, "child": [] }] })(props);
}
function RiVolumeUpFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "d": "M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z" }, "child": [] }] })(props);
}

// optional-peer-dep:__vite-optional-peer-dep:gl-matrix:@appletosolutions/reactbits
throw new Error(`Could not resolve "gl-matrix" imported by "@appletosolutions/reactbits". Is it installed?`);

// node_modules/three/src/math/MathUtils.js
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function degToRad(degrees) {
  return degrees * DEG2RAD;
}

// optional-peer-dep:__vite-optional-peer-dep:@react-three/postprocessing:@appletosolutions/reactbits
throw new Error(`Could not resolve "@react-three/postprocessing" imported by "@appletosolutions/reactbits". Is it installed?`);

// optional-peer-dep:__vite-optional-peer-dep:gsap/InertiaPlugin:@appletosolutions/reactbits
throw new Error(`Could not resolve "gsap/InertiaPlugin" imported by "@appletosolutions/reactbits". Is it installed?`);

// node_modules/three/examples/jsm/environments/RoomEnvironment.js
var RoomEnvironment = class extends Scene {
  constructor() {
    super();
    const geometry = new BoxGeometry();
    geometry.deleteAttribute("uv");
    const roomMaterial = new MeshStandardMaterial({ side: BackSide });
    const boxMaterial = new MeshStandardMaterial();
    const mainLight = new PointLight(16777215, 900, 28, 2);
    mainLight.position.set(0.418, 16.199, 0.3);
    this.add(mainLight);
    const room = new Mesh2(geometry, roomMaterial);
    room.position.set(-0.757, 13.219, 0.717);
    room.scale.set(31.713, 28.305, 28.591);
    this.add(room);
    const boxes = new InstancedMesh(geometry, boxMaterial, 6);
    const transform = new Object3D();
    transform.position.set(-10.906, 2.009, 1.846);
    transform.rotation.set(0, -0.195, 0);
    transform.scale.set(2.328, 7.905, 4.651);
    transform.updateMatrix();
    boxes.setMatrixAt(0, transform.matrix);
    transform.position.set(-5.607, -0.754, -0.758);
    transform.rotation.set(0, 0.994, 0);
    transform.scale.set(1.97, 1.534, 3.955);
    transform.updateMatrix();
    boxes.setMatrixAt(1, transform.matrix);
    transform.position.set(6.167, 0.857, 7.803);
    transform.rotation.set(0, 0.561, 0);
    transform.scale.set(3.927, 6.285, 3.687);
    transform.updateMatrix();
    boxes.setMatrixAt(2, transform.matrix);
    transform.position.set(-2.017, 0.018, 6.124);
    transform.rotation.set(0, 0.333, 0);
    transform.scale.set(2.002, 4.566, 2.064);
    transform.updateMatrix();
    boxes.setMatrixAt(3, transform.matrix);
    transform.position.set(2.291, -0.756, -2.621);
    transform.rotation.set(0, -0.286, 0);
    transform.scale.set(1.546, 1.552, 1.496);
    transform.updateMatrix();
    boxes.setMatrixAt(4, transform.matrix);
    transform.position.set(-2.193, -0.369, -5.547);
    transform.rotation.set(0, 0.516, 0);
    transform.scale.set(3.875, 3.487, 2.986);
    transform.updateMatrix();
    boxes.setMatrixAt(5, transform.matrix);
    this.add(boxes);
    const light1 = new Mesh2(geometry, createAreaLightMaterial(50));
    light1.position.set(-16.116, 14.37, 8.208);
    light1.scale.set(0.1, 2.428, 2.739);
    this.add(light1);
    const light2 = new Mesh2(geometry, createAreaLightMaterial(50));
    light2.position.set(-16.109, 18.021, -8.207);
    light2.scale.set(0.1, 2.425, 2.751);
    this.add(light2);
    const light3 = new Mesh2(geometry, createAreaLightMaterial(17));
    light3.position.set(14.904, 12.198, -1.832);
    light3.scale.set(0.15, 4.265, 6.331);
    this.add(light3);
    const light4 = new Mesh2(geometry, createAreaLightMaterial(43));
    light4.position.set(-0.462, 8.89, 14.52);
    light4.scale.set(4.38, 5.441, 0.088);
    this.add(light4);
    const light5 = new Mesh2(geometry, createAreaLightMaterial(20));
    light5.position.set(3.235, 11.486, -12.541);
    light5.scale.set(2.5, 2, 0.1);
    this.add(light5);
    const light6 = new Mesh2(geometry, createAreaLightMaterial(100));
    light6.position.set(0, 20, 0);
    light6.scale.set(1, 0.1, 1);
    this.add(light6);
  }
  /**
   * Frees internal resources. This method should be called
   * when the environment is no longer required.
   */
  dispose() {
    const resources = /* @__PURE__ */ new Set();
    this.traverse((object) => {
      if (object.isMesh) {
        resources.add(object.geometry);
        resources.add(object.material);
      }
    });
    for (const resource of resources) {
      resource.dispose();
    }
  }
};
function createAreaLightMaterial(intensity) {
  const material = new MeshLambertMaterial({
    color: 0,
    emissive: 16777215,
    emissiveIntensity: intensity
  });
  return material;
}

// node_modules/@appletosolutions/reactbits/dist/index.es.js
(void 0).registerPlugin(void 0, void 0);
var Je = ({ text: t2, className: n2 = "", delay: o2 = 100, duration: a2 = 0.6, ease: s2 = "power3.out", splitType: c2 = "chars", from: l2 = { opacity: 0, y: 40 }, to: u2 = { opacity: 1, y: 0 }, threshold: h2 = 0.1, rootMargin: d2 = "-100px", textAlign: m2 = "center", onLetterAnimationComplete: p2 }) => {
  const f2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = f2.current;
    if (!e2) return;
    const t3 = "lines" === c2;
    t3 && (e2.style.position = "relative");
    const n3 = new (void 0)(e2, { type: c2, absolute: t3, linesClass: "split-line" });
    let i2;
    switch (c2) {
      case "lines":
        i2 = n3.lines;
        break;
      case "words":
        i2 = n3.words;
        break;
      case "words, chars":
        i2 = [...n3.words, ...n3.chars];
        break;
      default:
        i2 = n3.chars;
    }
    i2.forEach((e3) => {
      e3.style.willChange = "transform, opacity";
    });
    const r2 = 100 * (1 - h2), m3 = /^(-?\d+)px$/.exec(d2), y = m3 ? parseInt(m3[1], 10) : 0, w = `top ${r2}%${y < 0 ? `-=${Math.abs(y)}px` : `+=${y}px`}`, b = (void 0).timeline({ scrollTrigger: { trigger: e2, start: w, toggleActions: "play none none none", once: true }, smoothChildTiming: true, onComplete: p2 });
    return b.set(i2, { ...l2, immediateRender: false, force3D: true }), b.to(i2, { ...u2, duration: a2, ease: s2, stagger: o2 / 1e3, force3D: true }), () => {
      b.kill(), (void 0).getAll().forEach((e3) => e3.kill()), (void 0).killTweensOf(i2), n3.revert();
    };
  }, [t2, o2, a2, s2, c2, l2, u2, h2, d2, p2]), (0, import_jsx_runtime.jsx)("p", { ref: f2, className: `split-parent ${n2}`, style: { textAlign: m2, overflow: "hidden", display: "inline-block", whiteSpace: "normal", wordWrap: "break-word" }, children: t2 });
};
var et = ({ text: n2 = "", delay: s2 = 200, className: c2 = "", animateBy: l2 = "words", direction: u2 = "top", threshold: h2 = 0.1, rootMargin: d2 = "0px", animationFrom: m2, animationTo: p2, easing: f2 = (e2) => e2, onAnimationComplete: v2, stepDuration: g2 = 0.35 }) => {
  const x2 = "words" === l2 ? n2.split(" ") : n2.split(""), [w, b] = (0, import_react3.useState)(false), M = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    if (!M.current) return;
    const e2 = new IntersectionObserver(([t2]) => {
      t2.isIntersecting && (b(true), e2.unobserve(M.current));
    }, { threshold: h2, rootMargin: d2 });
    return e2.observe(M.current), () => e2.disconnect();
  }, [h2, d2]);
  const P = (0, import_react3.useMemo)(() => "top" === u2 ? { filter: "blur(10px)", opacity: 0, y: -50 } : { filter: "blur(10px)", opacity: 0, y: 50 }, [u2]), S = (0, import_react3.useMemo)(() => [{ filter: "blur(5px)", opacity: 0.5, y: "top" === u2 ? 5 : -5 }, { filter: "blur(0px)", opacity: 1, y: 0 }], [u2]), C = m2 ?? P, E = p2 ?? S, z = E.length + 1, _ = g2 * (z - 1), T = Array.from({ length: z }, (e2, t2) => 1 === z ? 0 : t2 / (z - 1));
  return (0, import_jsx_runtime.jsx)("p", { ref: M, className: c2, style: { display: "flex", flexWrap: "wrap" }, children: x2.map((e2, n3) => {
    const i2 = ((e3, t2) => {
      const n4 = /* @__PURE__ */ new Set([...Object.keys(e3), ...t2.flatMap((e4) => Object.keys(e4))]), i3 = {};
      return n4.forEach((n5) => {
        i3[n5] = [e3[n5], ...t2.map((e4) => e4[n5])];
      }), i3;
    })(C, E), r2 = { duration: _, times: T, delay: n3 * s2 / 1e3 };
    return r2.ease = f2, (0, import_jsx_runtime.jsxs)(motion.span, { initial: C, animate: w ? i2 : C, transition: r2, onAnimationComplete: n3 === x2.length - 1 ? v2 : void 0, style: { display: "inline-block", willChange: "transform, filter, opacity" }, children: [" " === e2 ? " " : e2, "words" === l2 && n3 < x2.length - 1 && " "] }, n3);
  }) });
};
var tt = (e2, t2, n2 = true) => ({ from: t2, to: t2 + 360, ease: "linear", duration: e2, type: "tween", repeat: n2 ? 1 / 0 : 0 });
var nt = (e2, t2) => ({ rotate: tt(e2, t2), scale: { type: "spring", damping: 20, stiffness: 300 } });
var it = ({ text: i2, spinDuration: o2 = 20, onHover: a2 = "speedUp", className: s2 = "" }) => {
  const c2 = Array.from(i2), l2 = useAnimation(), u2 = useMotionValue(0);
  (0, import_react3.useEffect)(() => {
    const e2 = u2.get();
    l2.start({ rotate: e2 + 360, scale: 1, transition: nt(o2, e2) });
  }, [o2, i2, a2, l2]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".circular-text {\n  margin: 0 auto;\n  border-radius: 50%;\n  width: 200px;\n  position: relative;\n  height: 200px;\n  font-weight: bold;\n  color: #fff;\n  font-weight: 900;\n  text-align: center;\n  cursor: pointer;\n  transform-origin: 50% 50%;\n  -webkit-transform-origin: 50% 50%;\n}\n\n.circular-text span {\n  position: absolute;\n  display: inline-block;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  font-size: 24px;\n  transition: all 0.5s cubic-bezier(0, 0, 0, 1);\n}" }), (0, import_jsx_runtime.jsx)(motion.div, { className: `circular-text ${s2}`, style: { rotate: u2 }, initial: { rotate: 0 }, animate: l2, onMouseEnter: () => {
    const e2 = u2.get();
    if (!a2) return;
    let t2, n2 = 1;
    switch (a2) {
      case "slowDown":
        t2 = nt(2 * o2, e2);
        break;
      case "speedUp":
        t2 = nt(o2 / 4, e2);
        break;
      case "pause":
        t2 = { rotate: { type: "spring", damping: 20, stiffness: 300 }, scale: { type: "spring", damping: 20, stiffness: 300 } };
        break;
      case "goBonkers":
        t2 = nt(o2 / 20, e2), n2 = 0.8;
        break;
      default:
        t2 = nt(o2, e2);
    }
    l2.start({ rotate: e2 + 360, scale: n2, transition: t2 });
  }, onMouseLeave: () => {
    const e2 = u2.get();
    l2.start({ rotate: e2 + 360, scale: 1, transition: nt(o2, e2) });
  }, children: c2.map((t2, n2) => {
    const i3 = 360 / c2.length * n2, r2 = Math.PI / c2.length, o3 = `rotateZ(${i3}deg) translate3d(${r2 * n2}px, ${r2 * n2}px, 0)`;
    return (0, import_jsx_runtime.jsx)("span", { style: { transform: o3, WebkitTransform: o3 }, children: t2 }, n2);
  }) })] });
};
var rt = ({ text: i2, disabled: r2 = false, speed: o2 = 5, className: a2 = "" }) => {
  const s2 = `${o2}s`;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".shiny-text {\n  color: #b5b5b5a4; /* Adjust this color to change intensity/style */\n  background: linear-gradient(\n    120deg,\n    rgba(255, 255, 255, 0) 40%,\n    rgba(255, 255, 255, 0.8) 50%,\n    rgba(255, 255, 255, 0) 60%\n  );\n  background-size: 200% 100%;\n  -webkit-background-clip: text;\n  background-clip: text;\n  display: inline-block;\n  animation: shine 5s linear infinite;\n}\n\n@keyframes shine {\n  0% {\n    background-position: 100%;\n  }\n  100% {\n    background-position: -100%;\n  }\n}\n\n.shiny-text.disabled {\n  animation: none;\n}\n" }), (0, import_jsx_runtime.jsx)("div", { className: `shiny-text ${r2 ? "disabled" : ""} ${a2}`, style: { animationDuration: s2 }, children: i2 })] });
};
var ot = ({ text: n2 = "Compressa", fontFamily: a2 = "Compressa VF", fontUrl: s2 = "https://res.cloudinary.com/dr6lvwubh/raw/upload/v1529908256/CompressaPRO-GX.woff2", width: c2 = true, weight: l2 = true, italic: u2 = true, alpha: h2 = false, flex: d2 = true, stroke: m2 = false, scale: p2 = false, textColor: f2 = "#FFFFFF", strokeColor: v2 = "#FF0000", className: g2 = "", minFontSize: x2 = 24 }) => {
  const y = (0, import_react3.useRef)(null), w = (0, import_react3.useRef)(null), b = (0, import_react3.useRef)([]), M = (0, import_react3.useRef)({ x: 0, y: 0 }), P = (0, import_react3.useRef)({ x: 0, y: 0 }), [S, C] = (0, import_react3.useState)(x2), [E, z] = (0, import_react3.useState)(1), [_, T] = (0, import_react3.useState)(1), A = n2.split("");
  (0, import_react3.useEffect)(() => {
    const e2 = (e3) => {
      P.current.x = e3.clientX, P.current.y = e3.clientY;
    }, t2 = (e3) => {
      const t3 = e3.touches[0];
      P.current.x = t3.clientX, P.current.y = t3.clientY;
    };
    if (window.addEventListener("mousemove", e2), window.addEventListener("touchmove", t2, { passive: false }), y.current) {
      const { left: e3, top: t3, width: n3, height: i2 } = y.current.getBoundingClientRect();
      M.current.x = e3 + n3 / 2, M.current.y = t3 + i2 / 2, P.current.x = M.current.x, P.current.y = M.current.y;
    }
    return () => {
      window.removeEventListener("mousemove", e2), window.removeEventListener("touchmove", t2);
    };
  }, []);
  const R2 = () => {
    if (!y.current || !w.current) return;
    const { width: e2, height: t2 } = y.current.getBoundingClientRect();
    let n3 = e2 / (A.length / 2);
    n3 = Math.max(n3, x2), C(n3), z(1), T(1), requestAnimationFrame(() => {
      if (!w.current) return;
      const e3 = w.current.getBoundingClientRect();
      if (p2 && e3.height > 0) {
        const n4 = t2 / e3.height;
        z(n4), T(n4);
      }
    });
  };
  (0, import_react3.useEffect)(() => (R2(), window.addEventListener("resize", R2), () => window.removeEventListener("resize", R2)), [p2, n2]), (0, import_react3.useEffect)(() => {
    let e2;
    const t2 = () => {
      if (M.current.x += (P.current.x - M.current.x) / 15, M.current.y += (P.current.y - M.current.y) / 15, w.current) {
        const e3 = w.current.getBoundingClientRect().width / 2;
        b.current.forEach((t3) => {
          if (!t3) return;
          const n3 = t3.getBoundingClientRect(), i2 = { x: n3.x + n3.width / 2, y: n3.y + n3.height / 2 }, r2 = ((e4, t4) => {
            const n4 = t4.x - e4.x, i3 = t4.y - e4.y;
            return Math.sqrt(n4 * n4 + i3 * i3);
          })(M.current, i2), o2 = (t4, n4, i3) => {
            const r3 = i3 - Math.abs(i3 * t4 / e3);
            return Math.max(n4, r3 + n4);
          }, a3 = c2 ? Math.floor(o2(r2, 5, 200)) : 100, s3 = l2 ? Math.floor(o2(r2, 100, 900)) : 400, d3 = u2 ? o2(r2, 0, 1).toFixed(2) : 0, m3 = h2 ? o2(r2, 0, 1).toFixed(2) : 1;
          t3.style.opacity = m3.toString(), t3.style.fontVariationSettings = `'wght' ${s3}, 'wdth' ${a3}, 'ital' ${d3}`;
        });
      }
      e2 = requestAnimationFrame(t2);
    };
    return t2(), () => cancelAnimationFrame(e2);
  }, [c2, l2, u2, h2, A.length]);
  const I = [g2, d2 ? "flex" : "", m2 ? "stroke" : ""].filter(Boolean).join(" ");
  return (0, import_jsx_runtime.jsxs)("div", { ref: y, style: { position: "relative", width: "100%", height: "100%", background: "transparent" }, children: [(0, import_jsx_runtime.jsx)("style", { children: `
        @font-face {
          font-family: '${a2}';
          src: url('${s2}');
          font-style: normal;
        }

        .flex {
          display: flex;
          justify-content: space-between;
        }

        .stroke span {
          position: relative;
          color: ${f2};
        }
        .stroke span::after {
          content: attr(data-char);
          position: absolute;
          left: 0;
          top: 0;
          color: transparent;
          z-index: -1;
          -webkit-text-stroke-width: 3px;
          -webkit-text-stroke-color: ${v2};
        }

        .text-pressure-title {
          color: ${f2};
        }
      ` }), (0, import_jsx_runtime.jsx)("h1", { ref: w, className: `text-pressure-title ${I}`, style: { fontFamily: a2, textTransform: "uppercase", fontSize: S, lineHeight: _, transform: `scale(1, ${E})`, transformOrigin: "center top", margin: 0, textAlign: "center", userSelect: "none", whiteSpace: "nowrap", fontWeight: 100, width: "100%" }, children: A.map((t2, n3) => (0, import_jsx_runtime.jsx)("span", { ref: (e2) => {
    b.current[n3] = e2;
  }, "data-char": t2, style: { display: "inline-block", color: m2 ? void 0 : f2 }, children: t2 }, n3)) })] });
};
var at = ({ children: t2, fontSize: n2 = "clamp(2rem, 8vw, 8rem)", fontWeight: o2 = 900, fontFamily: a2 = "inherit", color: s2 = "#fff", enableHover: c2 = true, baseIntensity: l2 = 0.18, hoverIntensity: u2 = 0.5 }) => {
  const h2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    let e2, i2 = false;
    const r2 = h2.current;
    if (!r2) return;
    return (async () => {
      var _a;
      if (((_a = document.fonts) == null ? void 0 : _a.ready) && await document.fonts.ready, i2) return;
      const h3 = r2.getContext("2d");
      if (!h3) return;
      const d2 = "inherit" === a2 ? window.getComputedStyle(r2).fontFamily || "sans-serif" : a2, m2 = "number" == typeof n2 ? `${n2}px` : n2;
      let p2;
      if ("number" == typeof n2) p2 = n2;
      else {
        const e3 = document.createElement("span");
        e3.style.fontSize = n2, document.body.appendChild(e3);
        const t3 = window.getComputedStyle(e3).fontSize;
        p2 = parseFloat(t3), document.body.removeChild(e3);
      }
      const f2 = import_react3.default.Children.toArray(t2).join(""), v2 = document.createElement("canvas"), g2 = v2.getContext("2d");
      if (!g2) return;
      g2.font = `${o2} ${m2} ${d2}`, g2.textBaseline = "alphabetic";
      const x2 = g2.measureText(f2), y = x2.actualBoundingBoxLeft ?? 0, w = x2.actualBoundingBoxRight ?? x2.width, b = x2.actualBoundingBoxAscent ?? p2, M = x2.actualBoundingBoxDescent ?? 0.2 * p2, P = Math.ceil(y + w), S = Math.ceil(b + M), C = P + 10;
      v2.width = C, v2.height = S;
      g2.font = `${o2} ${m2} ${d2}`, g2.textBaseline = "alphabetic", g2.fillStyle = s2, g2.fillText(f2, 5 - y, b);
      r2.width = C + 100, r2.height = S + 0, h3.translate(50, 0);
      const E = 55 + P, z = 0 + S;
      let _ = false;
      const T = () => {
        if (i2) return;
        h3.clearRect(-30, -30, C + 60, S + 60);
        const t3 = _ ? u2 : l2;
        for (let e3 = 0; e3 < S; e3++) {
          const n3 = Math.floor(t3 * (Math.random() - 0.5) * 30);
          h3.drawImage(v2, 0, e3, C, 1, n3, e3, C, 1);
        }
        e2 = window.requestAnimationFrame(T);
      };
      T();
      const A = (e3, t3) => e3 >= 55 && e3 <= E && t3 >= 0 && t3 <= z, R2 = (e3) => {
        if (!c2) return;
        const t3 = r2.getBoundingClientRect(), n3 = e3.clientX - t3.left, i3 = e3.clientY - t3.top;
        _ = A(n3, i3);
      }, I = () => {
        _ = false;
      }, L = (e3) => {
        if (!c2) return;
        e3.preventDefault();
        const t3 = r2.getBoundingClientRect(), n3 = e3.touches[0], i3 = n3.clientX - t3.left, o3 = n3.clientY - t3.top;
        _ = A(i3, o3);
      }, F = () => {
        _ = false;
      };
      c2 && (r2.addEventListener("mousemove", R2), r2.addEventListener("mouseleave", I), r2.addEventListener("touchmove", L, { passive: false }), r2.addEventListener("touchend", F));
      r2.cleanupFuzzyText = () => {
        window.cancelAnimationFrame(e2), c2 && (r2.removeEventListener("mousemove", R2), r2.removeEventListener("mouseleave", I), r2.removeEventListener("touchmove", L), r2.removeEventListener("touchend", F));
      };
    })(), () => {
      i2 = true, window.cancelAnimationFrame(e2), r2 && r2.cleanupFuzzyText && r2.cleanupFuzzyText();
    };
  }, [t2, n2, o2, a2, s2, c2, l2, u2]), (0, import_jsx_runtime.jsx)("canvas", { ref: h2 });
};
function st({ children: i2, className: r2 = "", colors: o2 = ["#40ffaa", "#4079ff", "#40ffaa", "#4079ff", "#40ffaa"], animationSpeed: a2 = 8, showBorder: s2 = false }) {
  const c2 = { backgroundImage: `linear-gradient(to right, ${o2.join(", ")})`, animationDuration: `${a2}s` };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: '.animated-gradient-text {\n  position: relative;\n  margin: 0 auto;\n  display: flex;\n  max-width: fit-content;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n  border-radius: 1.25rem;\n  font-weight: 500;\n  backdrop-filter: blur(10px);\n  transition: box-shadow 0.5s ease-out;\n  overflow: hidden;\n  cursor: pointer;\n}\n\n.gradient-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-size: 300% 100%;\n  animation: gradient linear infinite;\n  border-radius: inherit;\n  z-index: 0;\n  pointer-events: none;\n}\n\n.gradient-overlay::before {\n  content: "";\n  position: absolute;\n  left: 0;\n  top: 0;\n  border-radius: inherit;\n  width: calc(100% - 2px);\n  height: calc(100% - 2px);\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: #060010;\n  z-index: -1;\n}\n\n@keyframes gradient {\n  0% {\n    background-position: 0% 50%;\n  }\n\n  50% {\n    background-position: 100% 50%;\n  }\n\n  100% {\n    background-position: 0% 50%;\n  }\n}\n\n.text-content {\n  display: inline-block;\n  position: relative;\n  z-index: 2;\n  background-size: 300% 100%;\n  background-clip: text;\n  -webkit-background-clip: text;\n  color: transparent;\n  animation: gradient linear infinite;\n}' }), (0, import_jsx_runtime.jsxs)("div", { className: `animated-gradient-text ${r2}`, children: [s2 && (0, import_jsx_runtime.jsx)("div", { className: "gradient-overlay", style: c2 }), (0, import_jsx_runtime.jsx)("div", { className: "text-content", style: c2, children: i2 })] })] });
}
var ct = ({ text: a2 = "", highlightWords: s2 = [], highlightClass: c2 = "highlighted", trigger: l2 = "auto", backgroundColor: u2 = "transparent", wireframes: h2 = false, gravity: d2 = 1, mouseConstraintStiffness: m2 = 0.2, fontSize: p2 = "1rem" }) => {
  const f2 = (0, import_react3.useRef)(null), v2 = (0, import_react3.useRef)(null), g2 = (0, import_react3.useRef)(null), [x2, y] = (0, import_react3.useState)(false);
  (0, import_react3.useEffect)(() => {
    if (!v2.current) return;
    const e2 = a2.split(" ").map((e3) => `<span class="word ${s2.some((t2) => e3.startsWith(t2)) ? c2 : ""}">${e3}</span>`).join(" ");
    v2.current.innerHTML = e2;
  }, [a2, s2, c2]), (0, import_react3.useEffect)(() => {
    if ("auto" !== l2) {
      if ("scroll" === l2 && f2.current) {
        const e2 = new IntersectionObserver(([t2]) => {
          t2.isIntersecting && (y(true), e2.disconnect());
        }, { threshold: 0.1 });
        return e2.observe(f2.current), () => e2.disconnect();
      }
    } else y(true);
  }, [l2]), (0, import_react3.useEffect)(() => {
    if (!x2) return;
    const { Engine: e2, Render: t2, World: n2, Bodies: i2, Runner: r2, Mouse: o2, MouseConstraint: a3 } = import_matter_js.default;
    if (!f2.current || !g2.current || !v2.current) return;
    const s3 = f2.current.getBoundingClientRect(), c3 = s3.width, l3 = s3.height;
    if (c3 <= 0 || l3 <= 0) return;
    const p3 = e2.create();
    p3.world.gravity.y = d2;
    const y2 = t2.create({ element: g2.current, engine: p3, options: { width: c3, height: l3, background: u2, wireframes: h2 } }), w2 = { isStatic: true, render: { fillStyle: "transparent" } }, b = i2.rectangle(c3 / 2, l3 + 25, c3, 50, w2), M = i2.rectangle(-25, l3 / 2, 50, l3, w2), P = i2.rectangle(c3 + 25, l3 / 2, 50, l3, w2), S = i2.rectangle(c3 / 2, -25, c3, 50, w2), C = v2.current.querySelectorAll(".word"), E = Array.from(C).map((e3) => {
      const t3 = e3.getBoundingClientRect(), n3 = t3.left - s3.left + t3.width / 2, r3 = t3.top - s3.top + t3.height / 2, o3 = i2.rectangle(n3, r3, t3.width, t3.height, { render: { fillStyle: "transparent" }, restitution: 0.8, frictionAir: 0.01, friction: 0.2 });
      return import_matter_js.default.Body.setVelocity(o3, { x: 5 * (Math.random() - 0.5), y: 0 }), import_matter_js.default.Body.setAngularVelocity(o3, 0.05 * (Math.random() - 0.5)), { elem: e3, body: o3 };
    });
    E.forEach(({ elem: e3, body: t3 }) => {
      e3.style.position = "absolute", e3.style.left = t3.position.x - t3.bounds.max.x + t3.bounds.min.x / 2 + "px", e3.style.top = t3.position.y - t3.bounds.max.y + t3.bounds.min.y / 2 + "px", e3.style.transform = "none";
    });
    const z = o2.create(f2.current), _ = a3.create(p3, { mouse: z, constraint: { stiffness: m2, render: { visible: false } } });
    y2.mouse = z, n2.add(p3.world, [b, M, P, S, _, ...E.map((e3) => e3.body)]);
    const T = r2.create();
    r2.run(T, p3), t2.run(y2);
    const A = () => {
      E.forEach(({ body: e3, elem: t3 }) => {
        const { x: n3, y: i3 } = e3.position;
        t3.style.left = `${n3}px`, t3.style.top = `${i3}px`, t3.style.transform = `translate(-50%, -50%) rotate(${e3.angle}rad)`;
      }), import_matter_js.default.Engine.update(p3), requestAnimationFrame(A);
    };
    return A(), () => {
      t2.stop(y2), r2.stop(T), y2.canvas && g2.current && g2.current.removeChild(y2.canvas), n2.clear(p3.world, false), e2.clear(p3);
    };
  }, [x2, d2, h2, u2, m2]);
  const w = () => {
    x2 || "click" !== l2 && "hover" !== l2 || y(true);
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".falling-text-container {\n  position: relative;\n  z-index: 1;\n  width: 100%;\n  height: 100%;\n  cursor: pointer;\n  text-align: center;\n  padding-top: 2em;\n}\n\n.falling-text-target {\n  display: inline-block;\n}\n\n.word {\n  display: inline-block;\n  margin: 0 2px;\n  user-select: none;\n}\n\n.highlighted {\n  color: cyan;\n  font-weight: bold;\n}\n\n.falling-text-canvas {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 0;\n}\n" }), (0, import_jsx_runtime.jsxs)("div", { ref: f2, className: "falling-text-container", onClick: "click" === l2 ? w : void 0, onMouseEnter: "hover" === l2 ? w : void 0, style: { position: "relative", overflow: "hidden" }, children: [(0, import_jsx_runtime.jsx)("div", { ref: v2, className: "falling-text-target", style: { fontSize: p2, lineHeight: 1.4 } }), (0, import_jsx_runtime.jsx)("div", { ref: g2, className: "falling-text-canvas" })] })] });
};
var lt = ({ text: a2 = "⚛️", delay: s2 = 0.01, spacing: c2 = 100, followMouseDirection: l2 = true, randomFloat: u2 = true, exitDuration: h2 = 0.5, removalInterval: d2 = 30, maxPoints: m2 = 5 }) => {
  const [p2, f2] = (0, import_react3.useState)([]), v2 = (0, import_react3.useRef)(null), g2 = (0, import_react3.useRef)(Date.now()), x2 = (0, import_react3.useRef)(0), w = (e2) => {
    if (!v2.current) return;
    const t2 = v2.current.getBoundingClientRect(), n2 = e2.clientX - t2.left, i2 = e2.clientY - t2.top;
    f2((e3) => {
      let t3 = [...e3];
      if (0 === t3.length) t3.push({ id: x2.current++, x: n2, y: i2, angle: 0, ...u2 && { randomX: 10 * Math.random() - 5, randomY: 10 * Math.random() - 5, randomRotate: 10 * Math.random() - 5 } });
      else {
        const e4 = t3[t3.length - 1], r2 = n2 - e4.x, o2 = i2 - e4.y, a3 = Math.sqrt(r2 * r2 + o2 * o2);
        if (a3 >= c2) {
          let n3 = 180 * Math.atan2(o2, r2) / Math.PI;
          n3 > 90 ? n3 -= 180 : n3 < -90 && (n3 += 180);
          const i3 = l2 ? n3 : 0, s3 = Math.floor(a3 / c2);
          for (let n4 = 1; n4 <= s3; n4++) {
            const s4 = c2 * n4 / a3, l3 = e4.x + r2 * s4, h3 = e4.y + o2 * s4;
            t3.push({ id: x2.current++, x: l3, y: h3, angle: i3, ...u2 && { randomX: 10 * Math.random() - 5, randomY: 10 * Math.random() - 5, randomRotate: 10 * Math.random() - 5 } });
          }
        }
      }
      return t3.length > m2 && (t3 = t3.slice(t3.length - m2)), t3;
    }), g2.current = Date.now();
  };
  return (0, import_react3.useEffect)(() => {
    const e2 = v2.current;
    if (e2) return e2.addEventListener("mousemove", w), () => e2.removeEventListener("mousemove", w);
  }, []), (0, import_react3.useEffect)(() => {
    const e2 = setInterval(() => {
      Date.now() - g2.current > 100 && f2((e3) => e3.length > 0 ? e3.slice(1) : e3);
    }, d2);
    return () => clearInterval(e2);
  }, [d2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".text-cursor-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n\n.text-cursor-inner {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n}\n\n.text-cursor-item {\n  position: absolute;\n  user-select: none;\n  white-space: nowrap;\n  font-size: 1.875rem;\n}\n" }), (0, import_jsx_runtime.jsx)("div", { ref: v2, className: "text-cursor-container", children: (0, import_jsx_runtime.jsx)("div", { className: "text-cursor-inner", children: (0, import_jsx_runtime.jsx)(AnimatePresence, { children: p2.map((t2) => (0, import_jsx_runtime.jsx)(motion.div, { initial: { opacity: 0, scale: 1, x: 0, y: 0, rotate: t2.angle }, animate: { opacity: 1, scale: 1, x: u2 ? [0, t2.randomX || 0, 0] : 0, y: u2 ? [0, t2.randomY || 0, 0] : 0, rotate: u2 ? [t2.angle, t2.angle + (t2.randomRotate || 0), t2.angle] : t2.angle }, exit: { opacity: 0, scale: 0 }, transition: { opacity: { duration: h2, ease: "easeOut", delay: s2 }, ...u2 && { x: { duration: 2, ease: "easeInOut", repeat: 1 / 0, repeatType: "mirror" }, y: { duration: 2, ease: "easeInOut", repeat: 1 / 0, repeatType: "mirror" }, rotate: { duration: 2, ease: "easeInOut", repeat: 1 / 0, repeatType: "mirror" } } }, className: "text-cursor-item", style: { left: t2.x, top: t2.y }, children: a2 }, t2.id)) }) }) })] });
};
var ut = { wrapper: { display: "inline-block", whiteSpace: "pre-wrap" }, srOnly: { position: "absolute", width: "1px", height: "1px", padding: 0, margin: "-1px", overflow: "hidden", clip: "rect(0,0,0,0)", border: 0 } };
function ht({ text: n2, speed: a2 = 50, maxIterations: s2 = 10, sequential: c2 = false, revealDirection: l2 = "start", useOriginalCharsOnly: u2 = false, characters: h2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+", className: d2 = "", parentClassName: m2 = "", encryptedClassName: p2 = "", animateOn: f2 = "hover", ...v2 }) {
  const [g2, x2] = (0, import_react3.useState)(n2), [w, b] = (0, import_react3.useState)(false), [M, P] = (0, import_react3.useState)(false), [S, C] = (0, import_react3.useState)(/* @__PURE__ */ new Set()), [E, z] = (0, import_react3.useState)(false), _ = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    let e2, t2 = 0;
    const i2 = u2 ? Array.from(new Set(n2.split(""))).filter((e3) => " " !== e3) : h2.split(""), r2 = (e3, t3) => {
      if (u2) {
        const n3 = e3.split("").map((e4, n4) => ({ char: e4, isSpace: " " === e4, index: n4, isRevealed: t3.has(n4) })), i3 = n3.filter((e4) => !e4.isSpace && !e4.isRevealed).map((e4) => e4.char);
        for (let e4 = i3.length - 1; e4 > 0; e4--) {
          const t4 = Math.floor(Math.random() * (e4 + 1));
          [i3[e4], i3[t4]] = [i3[t4], i3[e4]];
        }
        let r3 = 0;
        return n3.map((t4) => t4.isSpace ? " " : t4.isRevealed ? e3[t4.index] : i3[r3++]).join("");
      }
      return e3.split("").map((n3, r3) => " " === n3 ? " " : t3.has(r3) ? e3[r3] : i2[Math.floor(Math.random() * i2.length)]).join("");
    };
    return w ? (P(true), e2 = setInterval(() => {
      C((i3) => {
        if (c2) {
          if (i3.size < n2.length) {
            const e3 = ((e4) => {
              const t4 = n2.length;
              switch (l2) {
                case "start":
                default:
                  return e4.size;
                case "end":
                  return t4 - 1 - e4.size;
                case "center": {
                  const n3 = Math.floor(t4 / 2), i4 = Math.floor(e4.size / 2), r3 = e4.size % 2 == 0 ? n3 + i4 : n3 - i4 - 1;
                  if (r3 >= 0 && r3 < t4 && !e4.has(r3)) return r3;
                  for (let n4 = 0; n4 < t4; n4++) if (!e4.has(n4)) return n4;
                  return 0;
                }
              }
            })(i3), t3 = new Set(i3);
            return t3.add(e3), x2(r2(n2, t3)), t3;
          }
          return clearInterval(e2), P(false), i3;
        }
        return x2(r2(n2, i3)), t2++, t2 >= s2 && (clearInterval(e2), P(false), x2(n2)), i3;
      });
    }, a2)) : (x2(n2), C(/* @__PURE__ */ new Set()), P(false)), () => {
      e2 && clearInterval(e2);
    };
  }, [w, n2, a2, s2, c2, l2, h2, u2]), (0, import_react3.useEffect)(() => {
    if ("view" !== f2) return;
    const e2 = new IntersectionObserver((e3) => {
      e3.forEach((e4) => {
        e4.isIntersecting && !E && (b(true), z(true));
      });
    }, { root: null, rootMargin: "0px", threshold: 0.1 }), t2 = _.current;
    return t2 && e2.observe(t2), () => {
      t2 && e2.unobserve(t2);
    };
  }, [f2, E]);
  const T = "hover" === f2 ? { onMouseEnter: () => b(true), onMouseLeave: () => b(false) } : {};
  return (0, import_jsx_runtime.jsxs)(motion.span, { className: m2, ref: _, style: ut.wrapper, ...T, ...v2, children: [(0, import_jsx_runtime.jsx)("span", { style: ut.srOnly, children: g2 }), (0, import_jsx_runtime.jsx)("span", { "aria-hidden": "true", children: g2.split("").map((t2, n3) => {
    const i2 = S.has(n3) || !M || !w;
    return (0, import_jsx_runtime.jsx)("span", { className: i2 ? d2 : p2, children: t2 }, n3);
  }) })] });
}
var dt = ({ sentence: a2 = "True Focus", manualMode: s2 = false, blurAmount: c2 = 5, borderColor: l2 = "green", glowColor: u2 = "rgba(0, 255, 0, 0.6)", animationDuration: h2 = 0.5, pauseBetweenAnimations: d2 = 1 }) => {
  const m2 = a2.split(" "), [p2, f2] = (0, import_react3.useState)(0), [v2, g2] = (0, import_react3.useState)(null), x2 = (0, import_react3.useRef)(null), w = (0, import_react3.useRef)([]), [b, M] = (0, import_react3.useState)({ x: 0, y: 0, width: 0, height: 0 });
  (0, import_react3.useEffect)(() => {
    if (!s2) {
      const e2 = setInterval(() => {
        f2((e3) => (e3 + 1) % m2.length);
      }, 1e3 * (h2 + d2));
      return () => clearInterval(e2);
    }
  }, [s2, h2, d2, m2.length]), (0, import_react3.useEffect)(() => {
    if (null === p2 || -1 === p2) return;
    if (!w.current[p2] || !x2.current) return;
    const e2 = x2.current.getBoundingClientRect(), t2 = w.current[p2].getBoundingClientRect();
    M({ x: t2.left - e2.left, y: t2.top - e2.top, width: t2.width, height: t2.height });
  }, [p2, m2.length]);
  const P = () => {
    s2 && f2(v2 ?? 0);
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".focus-container {\n  position: relative;\n  display: flex;\n  gap: 1em;\n  justify-content: center;\n  align-items: center;\n  flex-wrap: wrap;\n}\n\n.focus-word {\n  position: relative;\n  font-size: 3rem;\n  font-weight: 900;\n  cursor: pointer;\n  transition:\n    filter 0.3s ease,\n    color 0.3s ease;\n}\n\n.focus-word.active {\n  filter: blur(0);\n}\n\n.focus-frame {\n  position: absolute;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n  box-sizing: content-box;\n  border: none;\n}\n\n.corner {\n  position: absolute;\n  width: 1rem;\n  height: 1rem;\n  border: 3px solid var(--border-color, #fff);\n  filter: drop-shadow(0px 0px 4px var(--border-color, #fff));\n  border-radius: 3px;\n  transition: none;\n}\n\n.top-left {\n  top: -10px;\n  left: -10px;\n  border-right: none;\n  border-bottom: none;\n}\n\n.top-right {\n  top: -10px;\n  right: -10px;\n  border-left: none;\n  border-bottom: none;\n}\n\n.bottom-left {\n  bottom: -10px;\n  left: -10px;\n  border-right: none;\n  border-top: none;\n}\n\n.bottom-right {\n  bottom: -10px;\n  right: -10px;\n  border-left: none;\n  border-top: none;\n}\n" }), (0, import_jsx_runtime.jsxs)("div", { className: "focus-container", ref: x2, children: [m2.map((t2, n2) => {
    const i2 = n2 === p2;
    return (0, import_jsx_runtime.jsx)("span", { ref: (e2) => {
      e2 && (w.current[n2] = e2);
    }, className: `focus-word ${s2 ? "manual" : ""} ${i2 && !s2 ? "active" : ""}`, style: { filter: i2 ? "blur(0px)" : `blur(${c2}px)`, transition: `filter ${h2}s ease`, "--border-color": l2, "--glow-color": u2 }, onMouseEnter: () => ((e2) => {
      s2 && (g2(e2), f2(e2));
    })(n2), onMouseLeave: P, children: t2 }, n2);
  }), (0, import_jsx_runtime.jsxs)(motion.div, { className: "focus-frame", animate: { x: b.x, y: b.y, width: b.width, height: b.height, opacity: p2 >= 0 ? 1 : 0 }, transition: { duration: h2 }, style: { "--border-color": l2, "--glow-color": u2 }, children: [(0, import_jsx_runtime.jsx)("span", { className: "corner top-left" }), (0, import_jsx_runtime.jsx)("span", { className: "corner top-right" }), (0, import_jsx_runtime.jsx)("span", { className: "corner bottom-left" }), (0, import_jsx_runtime.jsx)("span", { className: "corner bottom-right" })] })] })] });
};
(void 0).registerPlugin(void 0);
var mt = ({ children: o2, scrollContainerRef: s2, containerClassName: c2 = "", textClassName: l2 = "", animationDuration: u2 = 1, ease: h2 = "back.inOut(2)", scrollStart: d2 = "center bottom+=50%", scrollEnd: m2 = "bottom bottom-=40%", stagger: p2 = 0.03 }) => {
  const f2 = (0, import_react3.useRef)(null), g2 = (0, import_react3.useMemo)(() => ("string" == typeof o2 ? o2 : "").split("").map((t2, n2) => (0, import_jsx_runtime.jsx)("span", { className: "char", children: " " === t2 ? " " : t2 }, n2)), [o2]);
  return (0, import_react3.useEffect)(() => {
    const e2 = f2.current;
    if (!e2) return;
    const t2 = s2 && s2.current ? s2.current : window, n2 = e2.querySelectorAll(".char");
    (void 0).fromTo(n2, { willChange: "opacity, transform", opacity: 0, yPercent: 120, scaleY: 2.3, scaleX: 0.7, transformOrigin: "50% 0%" }, { duration: u2, ease: h2, opacity: 1, yPercent: 0, scaleY: 1, scaleX: 1, stagger: p2, scrollTrigger: { trigger: e2, scroller: t2, start: d2, end: m2, scrub: true } });
  }, [s2, u2, h2, d2, m2, p2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".scroll-float {\n  overflow: hidden;\n}\n\n.scroll-float-text {\n  display: inline-block;\n  font-size: clamp(1.6rem, 8vw, 10rem);\n  font-weight: 900;\n  text-align: center;\n  line-height: 1.5;\n}\n\n.char {\n  display: inline-block;\n}" }), (0, import_jsx_runtime.jsx)("h2", { ref: f2, className: `scroll-float ${c2}`, children: (0, import_jsx_runtime.jsx)("span", { className: `scroll-float-text ${l2}`, children: g2 }) })] });
};
(void 0).registerPlugin(void 0);
var pt = ({ children: o2, scrollContainerRef: s2, enableBlur: c2 = true, baseOpacity: l2 = 0.1, baseRotation: u2 = 3, blurStrength: h2 = 4, containerClassName: d2 = "", textClassName: m2 = "", rotationEnd: p2 = "bottom bottom", wordAnimationEnd: f2 = "bottom bottom" }) => {
  const x2 = (0, import_react3.useRef)(null), y = (0, import_react3.useMemo)(() => ("string" == typeof o2 ? o2 : "").split(/(\s+)/).map((t2, n2) => t2.match(/^\s+$/) ? t2 : (0, import_jsx_runtime.jsx)("span", { className: "word", children: t2 }, n2)), [o2]);
  return (0, import_react3.useEffect)(() => {
    const e2 = x2.current;
    if (!e2) return;
    const t2 = s2 && s2.current ? s2.current : window;
    (void 0).fromTo(e2, { transformOrigin: "0% 50%", rotate: u2 }, { ease: "none", rotate: 0, scrollTrigger: { trigger: e2, scroller: t2, start: "top bottom", end: p2, scrub: true } });
    const n2 = e2.querySelectorAll(".word");
    return (void 0).fromTo(n2, { opacity: l2, willChange: "opacity" }, { ease: "none", opacity: 1, stagger: 0.05, scrollTrigger: { trigger: e2, scroller: t2, start: "top bottom-=20%", end: f2, scrub: true } }), c2 && (void 0).fromTo(n2, { filter: `blur(${h2}px)` }, { ease: "none", filter: "blur(0px)", stagger: 0.05, scrollTrigger: { trigger: e2, scroller: t2, start: "top bottom-=20%", end: f2, scrub: true } }), () => {
      (void 0).getAll().forEach((e3) => e3.kill());
    };
  }, [s2, c2, u2, l2, p2, f2, h2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".scroll-reveal {\n  margin: 20px 0;\n}\n\n.scroll-reveal-text {\n  font-size: clamp(1.6rem, 4vw, 3rem);\n  line-height: 1.5;\n  font-weight: 600;\n}\n\n.word {\n  display: inline-block;\n}" }), (0, import_jsx_runtime.jsx)("h2", { ref: x2, className: `scroll-reveal ${d2}`, children: (0, import_jsx_runtime.jsx)("p", { className: `scroll-reveal-text ${m2}`, children: y }) })] });
};
function ft(e2, t2, n2, i2, r2) {
  return (e2 - t2) / (n2 - t2) * (r2 - i2) + i2;
}
var vt = "undefined" != typeof window ? window.devicePixelRatio : 1;
var gt = class {
  constructor(e2, { fontSize: t2, fontFamily: n2, charset: i2, invert: r2 } = {}) {
    this.width = 0, this.height = 0, this.center = { x: 0, y: 0 }, this.mouse = { x: 0, y: 0 }, this.cols = 0, this.rows = 0, this.renderer = e2, this.domElement = document.createElement("div"), this.domElement.style.position = "absolute", this.domElement.style.top = "0", this.domElement.style.left = "0", this.domElement.style.width = "100%", this.domElement.style.height = "100%", this.pre = document.createElement("pre"), this.domElement.appendChild(this.pre), this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.domElement.appendChild(this.canvas), this.deg = 0, this.invert = r2 ?? true, this.fontSize = t2 ?? 12, this.fontFamily = n2 ?? "'Courier New', monospace", this.charset = i2 ?? " .'`^\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$", this.context && (this.context.imageSmoothingEnabled = false, this.context.imageSmoothingEnabled = false), this.onMouseMove = this.onMouseMove.bind(this), document.addEventListener("mousemove", this.onMouseMove);
  }
  setSize(e2, t2) {
    this.width = e2, this.height = t2, this.renderer.setSize(e2, t2), this.reset(), this.center = { x: e2 / 2, y: t2 / 2 }, this.mouse = { x: this.center.x, y: this.center.y };
  }
  reset() {
    if (this.context) {
      this.context.font = `${this.fontSize}px ${this.fontFamily}`;
      const e2 = this.context.measureText("A").width;
      this.cols = Math.floor(this.width / (this.fontSize * (e2 / this.fontSize))), this.rows = Math.floor(this.height / this.fontSize), this.canvas.width = this.cols, this.canvas.height = this.rows, this.pre.style.fontFamily = this.fontFamily, this.pre.style.fontSize = `${this.fontSize}px`, this.pre.style.margin = "0", this.pre.style.padding = "0", this.pre.style.lineHeight = "1em", this.pre.style.position = "absolute", this.pre.style.left = "50%", this.pre.style.top = "50%", this.pre.style.transform = "translate(-50%, -50%)", this.pre.style.zIndex = "9", this.pre.style.backgroundAttachment = "fixed", this.pre.style.mixBlendMode = "difference";
    }
  }
  render(e2, t2) {
    this.renderer.render(e2, t2);
    const n2 = this.canvas.width, i2 = this.canvas.height;
    this.context && (this.context.clearRect(0, 0, n2, i2), this.context.drawImage(this.renderer.domElement, 0, 0, n2, i2), this.asciify(this.context, n2, i2), this.hue());
  }
  onMouseMove(e2) {
    this.mouse = { x: e2.clientX * vt, y: e2.clientY * vt };
  }
  get dx() {
    return this.mouse.x - this.center.x;
  }
  get dy() {
    return this.mouse.y - this.center.y;
  }
  hue() {
    const e2 = 180 * Math.atan2(this.dy, this.dx) / Math.PI;
    this.deg += 0.075 * (e2 - this.deg), this.domElement.style.filter = `hue-rotate(${this.deg.toFixed(1)}deg)`;
  }
  asciify(e2, t2, n2) {
    const i2 = e2.getImageData(0, 0, t2, n2).data;
    let r2 = "";
    for (let e3 = 0; e3 < n2; e3++) {
      for (let n3 = 0; n3 < t2; n3++) {
        const o2 = 4 * n3 + 4 * e3 * t2, [a2, s2, c2, l2] = [i2[o2], i2[o2 + 1], i2[o2 + 2], i2[o2 + 3]];
        if (0 === l2) {
          r2 += " ";
          continue;
        }
        let u2 = (0.3 * a2 + 0.6 * s2 + 0.1 * c2) / 255, h2 = Math.floor((1 - u2) * (this.charset.length - 1));
        this.invert && (h2 = this.charset.length - h2 - 1), r2 += this.charset[h2];
      }
      r2 += "\n";
    }
    this.pre.innerHTML = r2;
  }
  dispose() {
    document.removeEventListener("mousemove", this.onMouseMove);
  }
};
var xt = class {
  constructor(e2, { fontSize: t2 = 200, fontFamily: n2 = "Arial", color: i2 = "#fdf9f3" } = {}) {
    this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.txt = e2, this.fontSize = t2, this.fontFamily = n2, this.color = i2, this.font = `600 ${this.fontSize}px ${this.fontFamily}`;
  }
  resize() {
    if (this.context) {
      this.context.font = this.font;
      const e2 = this.context.measureText(this.txt), t2 = Math.ceil(e2.width) + 20, n2 = Math.ceil(e2.actualBoundingBoxAscent + e2.actualBoundingBoxDescent) + 20;
      this.canvas.width = t2, this.canvas.height = n2;
    }
  }
  render() {
    if (this.context) {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.fillStyle = this.color, this.context.font = this.font;
      const e2 = 10 + this.context.measureText(this.txt).actualBoundingBoxAscent;
      this.context.fillText(this.txt, 10, e2);
    }
  }
  get width() {
    return this.canvas.width;
  }
  get height() {
    return this.canvas.height;
  }
  get texture() {
    return this.canvas;
  }
};
var yt = class {
  constructor({ text: e2, asciiFontSize: t2, textFontSize: n2, textColor: i2, planeBaseHeight: r2, enableWaves: o2 }, a2, s2, c2) {
    this.center = { x: 0, y: 0 }, this.animationFrameId = 0, this.textString = e2, this.asciiFontSize = t2, this.textFontSize = n2, this.textColor = i2, this.planeBaseHeight = r2, this.container = a2, this.width = s2, this.height = c2, this.enableWaves = o2, this.camera = new PerspectiveCamera(45, this.width / this.height, 1, 1e3), this.camera.position.z = 30, this.scene = new Scene(), this.mouse = { x: 0, y: 0 }, this.onMouseMove = this.onMouseMove.bind(this), this.setMesh(), this.setRenderer();
  }
  setMesh() {
    this.textCanvas = new xt(this.textString, { fontSize: this.textFontSize, fontFamily: "IBM Plex Mono", color: this.textColor }), this.textCanvas.resize(), this.textCanvas.render(), this.texture = new CanvasTexture(this.textCanvas.texture), this.texture.minFilter = NearestFilter;
    const e2 = this.textCanvas.width / this.textCanvas.height, t2 = this.planeBaseHeight, n2 = t2 * e2, i2 = t2;
    this.geometry = new PlaneGeometry(n2, i2, 36, 36), this.material = new ShaderMaterial({ vertexShader: "\nvarying vec2 vUv;\nuniform float uTime;\nuniform float mouse;\nuniform float uEnableWaves;\n\nvoid main() {\n    vUv = uv;\n    float time = uTime * 5.;\n\n    float waveFactor = uEnableWaves;\n\n    vec3 transformed = position;\n\n    transformed.x += sin(time + position.y) * 0.5 * waveFactor;\n    transformed.y += cos(time + position.z) * 0.15 * waveFactor;\n    transformed.z += sin(time + position.x) * waveFactor;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);\n}\n", fragmentShader: "\nvarying vec2 vUv;\nuniform float mouse;\nuniform float uTime;\nuniform sampler2D uTexture;\n\nvoid main() {\n    float time = uTime;\n    vec2 pos = vUv;\n    \n    float move = sin(time + mouse) * 0.01;\n    float r = texture2D(uTexture, pos + cos(time * 2. - time + pos.x) * .01).r;\n    float g = texture2D(uTexture, pos + tan(time * .5 + pos.x - time) * .01).g;\n    float b = texture2D(uTexture, pos - cos(time * 2. + time + pos.y) * .01).b;\n    float a = texture2D(uTexture, pos).a;\n    gl_FragColor = vec4(r, g, b, a);\n}\n", transparent: true, uniforms: { uTime: { value: 0 }, mouse: { value: 1 }, uTexture: { value: this.texture }, uEnableWaves: { value: this.enableWaves ? 1 : 0 } } }), this.mesh = new Mesh2(this.geometry, this.material), this.scene.add(this.mesh);
  }
  setRenderer() {
    this.renderer = new WebGLRenderer({ antialias: false, alpha: true }), this.renderer.setPixelRatio(1), this.renderer.setClearColor(0, 0), this.filter = new gt(this.renderer, { fontFamily: "IBM Plex Mono", fontSize: this.asciiFontSize, invert: true }), this.container.appendChild(this.filter.domElement), this.setSize(this.width, this.height), this.container.addEventListener("mousemove", this.onMouseMove), this.container.addEventListener("touchmove", this.onMouseMove);
  }
  setSize(e2, t2) {
    this.width = e2, this.height = t2, this.camera.aspect = e2 / t2, this.camera.updateProjectionMatrix(), this.filter.setSize(e2, t2), this.center = { x: e2 / 2, y: t2 / 2 };
  }
  load() {
    this.animate();
  }
  onMouseMove(e2) {
    const t2 = e2.touches ? e2.touches[0] : e2, n2 = this.container.getBoundingClientRect(), i2 = t2.clientX - n2.left, r2 = t2.clientY - n2.top;
    this.mouse = { x: i2, y: r2 };
  }
  animate() {
    const e2 = () => {
      this.animationFrameId = requestAnimationFrame(e2), this.render();
    };
    e2();
  }
  render() {
    const e2 = 1e-3 * (/* @__PURE__ */ new Date()).getTime();
    this.textCanvas.render(), this.texture.needsUpdate = true, this.mesh.material.uniforms.uTime.value = Math.sin(e2), this.updateRotation(), this.filter.render(this.scene, this.camera);
  }
  updateRotation() {
    const e2 = ft(this.mouse.y, 0, this.height, 0.5, -0.5), t2 = ft(this.mouse.x, 0, this.width, -0.5, 0.5);
    this.mesh.rotation.x += 0.05 * (e2 - this.mesh.rotation.x), this.mesh.rotation.y += 0.05 * (t2 - this.mesh.rotation.y);
  }
  clear() {
    this.scene.traverse((e2) => {
      const t2 = e2;
      t2.isMesh && ([t2.material].flat().forEach((e3) => {
        e3.dispose(), Object.keys(e3).forEach((t3) => {
          const n2 = e3[t3];
          n2 && "object" == typeof n2 && "dispose" in n2 && "function" == typeof n2.dispose && n2.dispose();
        });
      }), t2.geometry.dispose());
    }), this.scene.clear();
  }
  dispose() {
    cancelAnimationFrame(this.animationFrameId), this.filter.dispose(), this.container.removeChild(this.filter.domElement), this.container.removeEventListener("mousemove", this.onMouseMove), this.container.removeEventListener("touchmove", this.onMouseMove), this.clear(), this.renderer.dispose();
  }
};
function wt({ text: t2 = "David!", asciiFontSize: n2 = 8, textFontSize: o2 = 200, textColor: a2 = "#fdf9f3", planeBaseHeight: s2 = 8, enableWaves: c2 = true }) {
  const l2 = (0, import_react3.useRef)(null), u2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    if (!l2.current) return;
    const { width: e2, height: i2 } = l2.current.getBoundingClientRect();
    u2.current = new yt({ text: t2, asciiFontSize: n2, textFontSize: o2, textColor: a2, planeBaseHeight: s2, enableWaves: c2 }, l2.current, e2, i2), u2.current.load();
    const r2 = new ResizeObserver((e3) => {
      var _a;
      if (!e3[0]) return;
      const { width: t3, height: n3 } = e3[0].contentRect;
      (_a = u2.current) == null ? void 0 : _a.setSize(t3, n3);
    });
    return r2.observe(l2.current), () => {
      var _a;
      r2.disconnect(), (_a = u2.current) == null ? void 0 : _a.dispose();
    };
  }, [t2, n2, o2, a2, s2, c2]), (0, import_jsx_runtime.jsx)("div", { ref: l2, style: { position: "absolute", width: "100%", height: "100%" }, children: (0, import_jsx_runtime.jsx)("style", { children: "\n        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@500&display=swap');\n\n        body {\n          margin: 0;\n          padding: 0;\n        }\n\n        canvas {\n          position: absolute;\n          left: 0;\n          top: 0;\n          width: 100%;\n          height: 100%;\n          image-rendering: optimizeSpeed;\n          image-rendering: -moz-crisp-edges;\n          image-rendering: -o-crisp-edges;\n          image-rendering: -webkit-optimize-contrast;\n          image-rendering: optimize-contrast;\n          image-rendering: crisp-edges;\n          image-rendering: pixelated;\n        }\n\n        pre {\n          margin: 0;\n          user-select: none;\n          padding: 0;\n          line-height: 1em;\n          text-align: left;\n          position: absolute;\n          left: 0;\n          top: 0;\n          background-image: radial-gradient(circle, #ff6188 0%, #fc9867 50%, #ffd866 100%);\n          background-attachment: fixed;\n          -webkit-text-fill-color: transparent;\n          -webkit-background-clip: text;\n          z-index: 9;\n          mix-blend-mode: difference;\n        }\n      " }) });
}
(void 0).registerPlugin(void 0, void 0);
var bt = ({ radius: o2 = 100, duration: a2 = 1.2, speed: s2 = 0.5, scrambleChars: c2 = ".:", className: l2 = "", style: u2 = {}, children: h2 }) => {
  const d2 = (0, import_react3.useRef)(null), m2 = (0, import_react3.useRef)([]);
  return (0, import_react3.useEffect)(() => {
    if (!d2.current) return;
    const e2 = (void 0).create(d2.current.querySelector("p"), { type: "chars", charsClass: "char" });
    m2.current = e2.chars, m2.current.forEach((e3) => {
      (void 0).set(e3, { display: "inline-block", attr: { "data-content": e3.innerHTML } });
    });
    const t2 = (e3) => {
      m2.current.forEach((t3) => {
        const { left: n3, top: i2, width: r2, height: l3 } = t3.getBoundingClientRect(), u3 = e3.clientX - (n3 + r2 / 2), h3 = e3.clientY - (i2 + l3 / 2), d3 = Math.hypot(u3, h3);
        d3 < o2 && (void 0).to(t3, { overwrite: true, duration: a2 * (1 - d3 / o2), scrambleText: { text: t3.dataset.content || "", chars: c2, speed: s2 }, ease: "none" });
      });
    }, n2 = d2.current;
    return n2.addEventListener("pointermove", t2), () => {
      n2.removeEventListener("pointermove", t2), e2.revert();
    };
  }, [o2, a2, s2, c2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".text-block {\n  margin: 7vw;\n  max-width: 800px;\n  font-family: monospace;\n  font-size: clamp(14px, 4vw, 32px);\n  color: #fff;\n}\n\n.char {\n  will-change: transform;\n  display: inline-block;\n}\n" }), (0, import_jsx_runtime.jsx)("div", { ref: d2, className: `text-block ${l2}`, style: u2, children: (0, import_jsx_runtime.jsx)("p", { children: h2 }) })] });
};
var Mt = ({ children: i2, speed: r2 = 0.5, enableShadows: o2 = true, enableOnHover: a2 = false, className: s2 = "" }) => {
  const c2 = { "--after-duration": 3 * r2 + "s", "--before-duration": 2 * r2 + "s", "--after-shadow": o2 ? "-5px 0 red" : "none", "--before-shadow": o2 ? "5px 0 cyan" : "none" }, l2 = a2 ? "enable-on-hover" : "";
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".glitch {\n  color: #fff;\n  font-size: clamp(2rem, 10vw, 8rem);\n  white-space: nowrap;\n  font-weight: 900;\n  position: relative;\n  margin: 0 auto;\n  user-select: none;\n  cursor: pointer;\n}\n\n.glitch::after,\n.glitch::before {\n  content: attr(data-text);\n  position: absolute;\n  top: 0;\n  color: #fff;\n  background-color: #060010;\n  overflow: hidden;\n  clip-path: inset(0 0 0 0);\n}\n\n.glitch:not(.enable-on-hover)::after {\n  left: 10px;\n  text-shadow: var(--after-shadow, -10px 0 red);\n  animation: animate-glitch var(--after-duration, 3s) infinite linear alternate-reverse;\n}\n.glitch:not(.enable-on-hover)::before {\n  left: -10px;\n  text-shadow: var(--before-shadow, 10px 0 cyan);\n  animation: animate-glitch var(--before-duration, 2s) infinite linear alternate-reverse;\n}\n\n.glitch.enable-on-hover::after,\n.glitch.enable-on-hover::before {\n  content: '';\n  opacity: 0;\n  animation: none;\n}\n\n.glitch.enable-on-hover:hover::after {\n  content: attr(data-text);\n  opacity: 1;\n  left: 10px;\n  text-shadow: var(--after-shadow, -10px 0 red);\n  animation: animate-glitch var(--after-duration, 3s) infinite linear alternate-reverse;\n}\n.glitch.enable-on-hover:hover::before {\n  content: attr(data-text);\n  opacity: 1;\n  left: -10px;\n  text-shadow: var(--before-shadow, 10px 0 cyan);\n  animation: animate-glitch var(--before-duration, 2s) infinite linear alternate-reverse;\n}\n\n@keyframes animate-glitch {\n  0%   { clip-path: inset(20% 0 50% 0); }\n  5%   { clip-path: inset(10% 0 60% 0); }\n  10%  { clip-path: inset(15% 0 55% 0); }\n  15%  { clip-path: inset(25% 0 35% 0); }\n  20%  { clip-path: inset(30% 0 40% 0); }\n  25%  { clip-path: inset(40% 0 20% 0); }\n  30%  { clip-path: inset(10% 0 60% 0); }\n  35%  { clip-path: inset(15% 0 55% 0); }\n  40%  { clip-path: inset(25% 0 35% 0); }\n  45%  { clip-path: inset(30% 0 40% 0); }\n  50%  { clip-path: inset(20% 0 50% 0); }\n  55%  { clip-path: inset(10% 0 60% 0); }\n  60%  { clip-path: inset(15% 0 55% 0); }\n  65%  { clip-path: inset(25% 0 35% 0); }\n  70%  { clip-path: inset(30% 0 40% 0); }\n  75%  { clip-path: inset(40% 0 20% 0); }\n  80%  { clip-path: inset(20% 0 50% 0); }\n  85%  { clip-path: inset(10% 0 60% 0); }\n  90%  { clip-path: inset(15% 0 55% 0); }\n  95%  { clip-path: inset(25% 0 35% 0); }\n  100% { clip-path: inset(30% 0 40% 0); }\n}\n" }), (0, import_jsx_runtime.jsx)("div", { className: `glitch ${l2} ${s2}`, style: c2, "data-text": i2, children: i2 })] });
};
var Pt = ({ scrollContainerRef: r2, texts: a2 = [], velocity: c2 = 100, className: l2 = "", damping: u2 = 50, stiffness: h2 = 400, numCopies: d2 = 6, velocityMapping: m2 = { input: [0, 1e3], output: [0, 5] }, parallaxClassName: p2 = "parallax", scrollerClassName: f2 = "scroller", parallaxStyle: v2, scrollerStyle: g2 }) => {
  function x2({ children: t2, baseVelocity: n2 = c2, scrollContainerRef: r3, className: a3 = "", damping: l3, stiffness: u3, numCopies: h3, velocityMapping: d3, parallaxClassName: m3, scrollerClassName: p3, parallaxStyle: f3, scrollerStyle: v3 }) {
    const g3 = useMotionValue(0), x3 = r3 ? { container: r3 } : {}, { scrollY: w } = useScroll(x3), M = useVelocity(w), _ = useSpring(M, { damping: l3 ?? 50, stiffness: u3 ?? 400 }), T = useTransform(_, (d3 == null ? void 0 : d3.input) || [0, 1e3], (d3 == null ? void 0 : d3.output) || [0, 5], { clamp: false }), A = (0, import_react3.useRef)(null), R2 = function(e2) {
      const [t3, n3] = (0, import_react3.useState)(0);
      return (0, import_react3.useLayoutEffect)(() => {
        function t4() {
          e2.current && n3(e2.current.offsetWidth);
        }
        return t4(), window.addEventListener("resize", t4), () => window.removeEventListener("resize", t4);
      }, [e2]), t3;
    }(A);
    const I = useTransform(g3, (e2) => 0 === R2 ? "0px" : `${function(e3, t3, n3) {
      const i2 = t3 - e3;
      return ((n3 - e3) % i2 + i2) % i2 + e3;
    }(-R2, 0, e2)}px`), L = (0, import_react3.useRef)(1);
    useAnimationFrame((e2, t3) => {
      let i2 = L.current * n2 * (t3 / 1e3);
      T.get() < 0 ? L.current = -1 : T.get() > 0 && (L.current = 1), i2 += L.current * i2 * T.get(), g3.set(g3.get() + i2);
    });
    const F = [];
    for (let n3 = 0; n3 < h3; n3++) F.push((0, import_jsx_runtime.jsx)("span", { className: a3, ref: 0 === n3 ? A : null, children: t2 }, n3));
    return (0, import_jsx_runtime.jsx)("div", { className: m3, style: f3, children: (0, import_jsx_runtime.jsx)(motion.div, { className: p3, style: { x: I, ...v3 }, children: F }) });
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".parallax {\n  position: relative;\n  overflow: hidden;\n}\n\n.scroller {\n  display: flex;\n  white-space: nowrap;\n  text-align: center;\n  font-family: sans-serif;\n  font-size: 2.25rem;\n  font-weight: bold;\n  letter-spacing: -0.02em;\n  filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.1));\n}\n\n.scroller span {\n  flex-shrink: 0;\n}\n\n@media (min-width: 768px) {\n  .scroller {\n    font-size: 5rem;\n    line-height: 5rem;\n  }\n}" }), (0, import_jsx_runtime.jsx)("section", { children: a2.map((e2, n2) => (0, import_jsx_runtime.jsxs)(x2, { className: l2, baseVelocity: n2 % 2 != 0 ? -c2 : c2, scrollContainerRef: r2, damping: u2, stiffness: h2, numCopies: d2, velocityMapping: m2, parallaxClassName: p2, scrollerClassName: f2, parallaxStyle: v2, scrollerStyle: g2, children: [e2, " "] }, n2)) })] });
};
var St = (0, import_react3.forwardRef)((o2, s2) => {
  const { label: c2, fromFontVariationSettings: l2, toFontVariationSettings: u2, containerRef: h2, radius: d2 = 50, falloff: m2 = "linear", className: p2 = "", onClick: f2, style: v2, ...g2 } = o2, x2 = (0, import_react3.useRef)([]), w = (0, import_react3.useRef)([]), b = function(e2) {
    const t2 = (0, import_react3.useRef)({ x: 0, y: 0 });
    return (0, import_react3.useEffect)(() => {
      const n2 = (n3, i3) => {
        if (e2 == null ? void 0 : e2.current) {
          const r3 = e2.current.getBoundingClientRect();
          t2.current = { x: n3 - r3.left, y: i3 - r3.top };
        } else t2.current = { x: n3, y: i3 };
      }, i2 = (e3) => n2(e3.clientX, e3.clientY), r2 = (e3) => {
        const t3 = e3.touches[0];
        n2(t3.clientX, t3.clientY);
      };
      return window.addEventListener("mousemove", i2), window.addEventListener("touchmove", r2), () => {
        window.removeEventListener("mousemove", i2), window.removeEventListener("touchmove", r2);
      };
    }, [e2]), t2;
  }(h2), M = (0, import_react3.useRef)({ x: null, y: null }), P = (0, import_react3.useMemo)(() => {
    const e2 = (e3) => new Map(e3.split(",").map((e4) => e4.trim()).map((e4) => {
      const [t3, n3] = e4.split(" ");
      return [t3.replace(/['"]/g, ""), parseFloat(n3)];
    })), t2 = e2(l2), n2 = e2(u2);
    return Array.from(t2.entries()).map(([e3, t3]) => ({ axis: e3, fromValue: t3, toValue: n2.get(e3) ?? t3 }));
  }, [l2, u2]);
  var S;
  (0, import_react3.useEffect)(() => {
    let e2;
    const t2 = () => {
      S(), e2 = requestAnimationFrame(t2);
    };
    return e2 = requestAnimationFrame(t2), () => cancelAnimationFrame(e2);
  }, [S = () => {
    if (!(h2 == null ? void 0 : h2.current)) return;
    const { x: e2, y: t2 } = b.current;
    if (M.current.x === e2 && M.current.y === t2) return;
    M.current = { x: e2, y: t2 };
    const n2 = h2.current.getBoundingClientRect();
    x2.current.forEach((e3, t3) => {
      if (!e3) return;
      const i2 = e3.getBoundingClientRect(), r2 = i2.left + i2.width / 2 - n2.left, o3 = i2.top + i2.height / 2 - n2.top, a2 = (s3 = b.current.x, c3 = b.current.y, u3 = r2, h3 = o3, Math.sqrt((u3 - s3) ** 2 + (h3 - c3) ** 2));
      var s3, c3, u3, h3;
      if (a2 >= d2) return void (e3.style.fontVariationSettings = l2);
      const p3 = ((e4) => {
        const t4 = Math.min(Math.max(1 - e4 / d2, 0), 1);
        switch (m2) {
          case "exponential":
            return t4 ** 2;
          case "gaussian":
            return Math.exp(-((e4 / (d2 / 2)) ** 2) / 2);
          default:
            return t4;
        }
      })(a2), f3 = P.map(({ axis: e4, fromValue: t4, toValue: n3 }) => `'${e4}' ${t4 + (n3 - t4) * p3}`).join(", ");
      w.current[t3] = f3, e3.style.fontVariationSettings = f3;
    });
  }]);
  const C = c2.split(" ");
  let E = 0;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: '@import url("https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap");\n\n.variable-proximity {\n  font-family: "Roboto Flex", sans-serif;\n}\n\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border: 0;\n}\n' }), (0, import_jsx_runtime.jsxs)("span", { ref: s2, className: `${p2} variable-proximity`, onClick: f2, style: { display: "inline", ...v2 }, ...g2, children: [C.map((n2, i2) => (0, import_jsx_runtime.jsxs)("span", { style: { display: "inline-block", whiteSpace: "nowrap" }, children: [n2.split("").map((t2) => {
    const n3 = E++;
    return (0, import_jsx_runtime.jsx)(motion.span, { ref: (e2) => {
      x2.current[n3] = e2;
    }, style: { display: "inline-block", fontVariationSettings: w.current[n3] }, "aria-hidden": "true", children: t2 }, n3);
  }), i2 < C.length - 1 && (0, import_jsx_runtime.jsx)("span", { style: { display: "inline-block" }, children: " " })] }, i2)), (0, import_jsx_runtime.jsx)("span", { className: "sr-only", children: c2 })] })] });
});
function Ct({ to: t2, from: n2 = 0, direction: o2 = "up", delay: a2 = 0, duration: s2 = 2, className: c2 = "", startWhen: l2 = true, separator: u2 = "", onStart: h2, onEnd: d2 }) {
  const m2 = (0, import_react3.useRef)(null), p2 = useMotionValue("down" === o2 ? t2 : n2), f2 = useSpring(p2, { damping: 20 + 1 / s2 * 40, stiffness: 1 / s2 * 100 }), v2 = useInView(m2, { once: true, margin: "0px" });
  return (0, import_react3.useEffect)(() => {
    m2.current && (m2.current.textContent = String("down" === o2 ? t2 : n2));
  }, [n2, t2, o2]), (0, import_react3.useEffect)(() => {
    if (v2 && l2) {
      "function" == typeof h2 && h2();
      const e2 = setTimeout(() => {
        p2.set("down" === o2 ? n2 : t2);
      }, 1e3 * a2), i2 = setTimeout(() => {
        "function" == typeof d2 && d2();
      }, 1e3 * a2 + 1e3 * s2);
      return () => {
        clearTimeout(e2), clearTimeout(i2);
      };
    }
  }, [v2, l2, p2, o2, n2, t2, a2, h2, d2, s2]), (0, import_react3.useEffect)(() => {
    const e2 = f2.on("change", (e3) => {
      if (m2.current) {
        const t3 = { useGrouping: !!u2, minimumFractionDigits: 0, maximumFractionDigits: 0 }, n3 = Intl.NumberFormat("en-US", t3).format(Number(e3.toFixed(0)));
        m2.current.textContent = u2 ? n3.replace(/,/g, u2) : n3;
      }
    });
    return () => e2();
  }, [f2, u2]), (0, import_jsx_runtime.jsx)("span", { className: `${c2}`, ref: m2 });
}
St.displayName = "VariableProximity";
var Et = ({ children: n2 }) => (0, import_jsx_runtime.jsxs)("div", { style: { animation: "bounce 2s infinite" }, children: [(0, import_jsx_runtime.jsx)("style", { children: "\n          @keyframes bounce {\n            0%, 100% {\n              transform: translateY(0);\n            }\n            50% {\n              transform: translateY(-20px);\n            }\n          }\n        " }), n2] });
var zt = ({ as: i2, className: r2 = "", color: o2 = "white", speed: a2 = "6s", children: s2, ...c2 }) => {
  const l2 = i2 || "button";
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: "\n          .star-border-container {\n            display: inline-block;\n            padding: 1px 0;\n            position: relative;\n            border-radius: 20px;\n            overflow: hidden;\n          }\n          \n          .border-gradient-bottom {\n            position: absolute;\n            width: 300%;\n            height: 50%;\n            opacity: 0.7;\n            bottom: -11px;\n            right: -250%;\n            border-radius: 50%;\n            animation: star-movement-bottom linear infinite alternate;\n            z-index: 0;\n          }\n          \n          .border-gradient-top {\n            position: absolute;\n            opacity: 0.7;\n            width: 300%;\n            height: 50%;\n            top: -10px;\n            left: -250%;\n            border-radius: 50%;\n            animation: star-movement-top linear infinite alternate;\n            z-index: 0;\n          }\n          \n          .inner-content {\n            position: relative;\n            border: 1px solid #222;\n            background: #000;\n            color: white;\n            font-size: 16px;\n            text-align: center;\n            padding: 16px 26px;\n            border-radius: 20px;\n            z-index: 1;\n          }\n          \n          @keyframes star-movement-bottom {\n            0% {\n              transform: translate(0%, 0%);\n              opacity: 1;\n            }\n            100% {\n              transform: translate(-100%, 0%);\n              opacity: 0;\n            }\n          }\n          \n          @keyframes star-movement-top {\n            0% {\n              transform: translate(0%, 0%);\n              opacity: 1;\n            }\n            100% {\n              transform: translate(100%, 0%);\n              opacity: 0;\n            }\n          }\n      " }), import_react3.default.createElement(l2, { className: `star-border-container ${r2}`, ...c2 }, (0, import_jsx_runtime.jsx)("div", { className: "border-gradient-bottom", style: { background: `radial-gradient(circle, ${o2}, transparent 10%)`, animationDuration: a2 } }), (0, import_jsx_runtime.jsx)("div", { className: "border-gradient-top", style: { background: `radial-gradient(circle, ${o2}, transparent 10%)`, animationDuration: a2 } }), (0, import_jsx_runtime.jsx)("div", { className: "inner-content", children: s2 }))] });
};
var _t = ({ sparkColor: n2 = "#fff", sparkSize: o2 = 10, sparkRadius: a2 = 15, sparkCount: s2 = 8, duration: c2 = 400, easing: u2 = "ease-out", extraScale: h2 = 1, children: d2 }) => {
  const m2 = (0, import_react3.useRef)(null), p2 = (0, import_react3.useRef)([]), f2 = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    const e2 = m2.current;
    if (!e2) return;
    const t2 = e2.parentElement;
    if (!t2) return;
    let n3;
    const i2 = () => {
      const { width: n4, height: i3 } = t2.getBoundingClientRect();
      e2.width === n4 && e2.height === i3 || (e2.width = n4, e2.height = i3);
    }, r2 = new ResizeObserver(() => {
      clearTimeout(n3), n3 = setTimeout(i2, 100);
    });
    return r2.observe(t2), i2(), () => {
      r2.disconnect(), clearTimeout(n3);
    };
  }, []);
  const v2 = (0, import_react3.useCallback)((e2) => {
    switch (u2) {
      case "linear":
        return e2;
      case "ease-in":
        return e2 * e2;
      case "ease-in-out":
        return e2 < 0.5 ? 2 * e2 * e2 : (4 - 2 * e2) * e2 - 1;
      default:
        return e2 * (2 - e2);
    }
  }, [u2]);
  (0, import_react3.useEffect)(() => {
    const e2 = m2.current;
    if (!e2) return;
    const t2 = e2.getContext("2d");
    if (!t2) return;
    let i2;
    const r2 = (s3) => {
      f2.current || (f2.current = s3), t2 == null ? void 0 : t2.clearRect(0, 0, e2.width, e2.height), p2.current = p2.current.filter((e3) => {
        const i3 = s3 - e3.startTime;
        if (i3 >= c2) return false;
        const r3 = v2(i3 / c2), l2 = r3 * a2 * h2, u3 = o2 * (1 - r3), d3 = e3.x + l2 * Math.cos(e3.angle), m3 = e3.y + l2 * Math.sin(e3.angle), p3 = e3.x + (l2 + u3) * Math.cos(e3.angle), f3 = e3.y + (l2 + u3) * Math.sin(e3.angle);
        return t2.strokeStyle = n2, t2.lineWidth = 2, t2.beginPath(), t2.moveTo(d3, m3), t2.lineTo(p3, f3), t2.stroke(), true;
      }), i2 = requestAnimationFrame(r2);
    };
    return i2 = requestAnimationFrame(r2), () => {
      cancelAnimationFrame(i2);
    };
  }, [n2, o2, a2, s2, c2, v2, h2]);
  return (0, import_jsx_runtime.jsxs)("div", { style: { width: "100%", height: "100%", position: "relative" }, onClick: (e2) => {
    const t2 = m2.current;
    if (!t2) return;
    const n3 = t2.getBoundingClientRect(), i2 = e2.clientX - n3.left, r2 = e2.clientY - n3.top, o3 = performance.now(), a3 = Array.from({ length: s2 }, (e3, t3) => ({ x: i2, y: r2, angle: 2 * Math.PI * t3 / s2, startTime: o3 }));
    p2.current.push(...a3);
  }, children: [(0, import_jsx_runtime.jsx)("canvas", { ref: m2, style: { position: "absolute", inset: 0, pointerEvents: "none" } }), d2] });
};
(void 0).registerPlugin(void 0);
var Tt = ({ children: t2, distance: n2 = 100, direction: o2 = "vertical", reverse: a2 = false, duration: s2 = 0.8, ease: c2 = "power3.out", initialOpacity: l2 = 0, animateOpacity: u2 = true, scale: h2 = 1, threshold: d2 = 0.1, delay: m2 = 0, onComplete: p2 }) => {
  const f2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = f2.current;
    if (!e2) return;
    const t3 = "horizontal" === o2 ? "x" : "y", i2 = a2 ? -n2 : n2, r2 = 100 * (1 - d2);
    return (void 0).set(e2, { [t3]: i2, scale: h2, opacity: u2 ? l2 : 1 }), (void 0).to(e2, { [t3]: 0, scale: 1, opacity: 1, duration: s2, ease: c2, delay: m2, onComplete: p2, scrollTrigger: { trigger: e2, start: `top ${r2}%`, toggleActions: "play none none none", once: true } }), () => {
      (void 0).getAll().forEach((e3) => e3.kill()), (void 0).killTweensOf(e2);
    };
  }, [n2, o2, a2, s2, c2, l2, u2, h2, d2, m2, p2]), (0, import_jsx_runtime.jsx)("div", { ref: f2, children: t2 });
};
var At = ({ children: t2, blur: n2 = false, duration: a2 = 1e3, easing: s2 = "ease-out", delay: c2 = 0, threshold: l2 = 0.1, initialOpacity: u2 = 0, className: h2 = "" }) => {
  const [d2, m2] = (0, import_react3.useState)(false), p2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = p2.current;
    if (!e2) return;
    const t3 = new IntersectionObserver(([n3]) => {
      n3.isIntersecting && (t3.unobserve(e2), setTimeout(() => {
        m2(true);
      }, c2));
    }, { threshold: l2 });
    return t3.observe(e2), () => t3.disconnect();
  }, [l2, c2]), (0, import_jsx_runtime.jsx)("div", { ref: p2, className: h2, style: { opacity: d2 ? 1 : u2, transition: `opacity ${a2}ms ${s2}, filter ${a2}ms ${s2}`, filter: n2 ? d2 ? "blur(0px)" : "blur(10px)" : "none" }, children: t2 });
};
var Rt = ({ firstContent: a2, secondContent: s2, gridSize: c2 = 7, pixelColor: l2 = "currentColor", animationStepDuration: u2 = 0.3, className: h2 = "", style: d2 = {}, aspectRatio: m2 = "100%" }) => {
  const p2 = (0, import_react3.useRef)(null), f2 = (0, import_react3.useRef)(null), g2 = (0, import_react3.useRef)(null), x2 = (0, import_react3.useRef)(null), [y, w] = (0, import_react3.useState)(false), b = "ontouchstart" in window || navigator.maxTouchPoints > 0 || window.matchMedia("(pointer: coarse)").matches;
  (0, import_react3.useEffect)(() => {
    const e2 = f2.current;
    if (e2) {
      e2.innerHTML = "";
      for (let t2 = 0; t2 < c2; t2++) for (let n2 = 0; n2 < c2; n2++) {
        const i2 = document.createElement("div");
        i2.classList.add("pixelated-image-card__pixel"), i2.style.backgroundColor = l2;
        const r2 = 100 / c2;
        i2.style.width = `${r2}%`, i2.style.height = `${r2}%`, i2.style.left = n2 * r2 + "%", i2.style.top = t2 * r2 + "%", e2.appendChild(i2);
      }
    }
  }, [c2, l2]);
  const M = (e2) => {
    w(e2);
    const t2 = f2.current, n2 = g2.current;
    if (!t2 || !n2) return;
    const i2 = t2.querySelectorAll(".pixelated-image-card__pixel");
    if (!i2.length) return;
    (void 0).killTweensOf(i2), x2.current && x2.current.kill(), (void 0).set(i2, { display: "none" });
    const r2 = i2.length, o2 = u2 / r2;
    (void 0).to(i2, { display: "block", duration: 0, stagger: { each: o2, from: "random" } }), x2.current = (void 0).delayedCall(u2, () => {
      n2.style.display = e2 ? "block" : "none", n2.style.pointerEvents = e2 ? "none" : "";
    }), (void 0).to(i2, { display: "none", duration: 0, delay: u2, stagger: { each: o2, from: "random" } });
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".pixelated-image-card {\n  background-color: #222;\n  color: var(--color-primary, #fff);\n  border-radius: 15px;\n  border: 2px solid #fff;\n  width: 300px;\n  max-width: 100%;\n  position: relative;\n  overflow: hidden;\n}\n\n.pixelated-image-card__default,\n.pixelated-image-card__active,\n.pixelated-image-card__pixels {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.pixelated-image-card__active {\n  z-index: 2;\n}\n\n.pixelated-image-card__active {\n  display: none;\n}\n\n.pixelated-image-card__pixels {\n  pointer-events: none;\n  position: absolute;\n  z-index: 3;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.pixelated-image-card__pixel {\n  display: none;\n  position: absolute;\n}\n" }), (0, import_jsx_runtime.jsxs)("div", { ref: p2, className: `pixelated-image-card ${h2}`, style: d2, onMouseEnter: b ? void 0 : () => {
    y || M(true);
  }, onMouseLeave: b ? void 0 : () => {
    y && M(false);
  }, onClick: b ? () => {
    M(!y);
  } : void 0, children: [(0, import_jsx_runtime.jsx)("div", { style: { paddingTop: m2 } }), (0, import_jsx_runtime.jsx)("div", { className: "pixelated-image-card__default", children: a2 }), (0, import_jsx_runtime.jsx)("div", { className: "pixelated-image-card__active", ref: g2, children: s2 }), (0, import_jsx_runtime.jsx)("div", { className: "pixelated-image-card__pixels", ref: f2 })] })] });
};
var It = ({ width: i2 = "500px", height: r2 = "500px", background: o2 = "#000", borderRadius: a2 = "10px", borderColor: s2 = "#333", children: c2, glareColor: l2 = "#ffffff", glareOpacity: u2 = 0.5, glareAngle: h2 = -45, glareSize: d2 = 250, transitionDuration: m2 = 650, playOnce: p2 = false, className: f2 = "", style: v2 = {} }) => {
  const g2 = l2.replace("#", "");
  let x2 = l2;
  if (/^[0-9A-Fa-f]{6}$/.test(g2)) {
    x2 = `rgba(${parseInt(g2.slice(0, 2), 16)}, ${parseInt(g2.slice(2, 4), 16)}, ${parseInt(g2.slice(4, 6), 16)}, ${u2})`;
  } else if (/^[0-9A-Fa-f]{3}$/.test(g2)) {
    x2 = `rgba(${parseInt(g2[0] + g2[0], 16)}, ${parseInt(g2[1] + g2[1], 16)}, ${parseInt(g2[2] + g2[2], 16)}, ${u2})`;
  }
  const y = { "--gh-width": i2, "--gh-height": r2, "--gh-bg": o2, "--gh-br": a2, "--gh-angle": `${h2}deg`, "--gh-duration": `${m2}ms`, "--gh-size": `${d2}%`, "--gh-rgba": x2, "--gh-border": s2 };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: '\n      .glare-hover {\n  width: var(--gh-width);\n  height: var(--gh-height);\n  background: var(--gh-bg);\n  border-radius: var(--gh-br);\n  border: 1px solid var(--gh-border);\n  overflow: hidden;\n  position: relative;\n  display: grid;\n  place-items: center;\n}\n\n.glare-hover::before {\n  content: "";\n  position: absolute;\n  inset: 0;\n  background: linear-gradient(var(--gh-angle),\n      hsla(0, 0%, 0%, 0) 60%,\n      var(--gh-rgba) 70%,\n      hsla(0, 0%, 0%, 0),\n      hsla(0, 0%, 0%, 0) 100%);\n  transition: var(--gh-duration) ease;\n  background-size: var(--gh-size) var(--gh-size), 100% 100%;\n  background-repeat: no-repeat;\n  background-position: -100% -100%, 0 0;\n}\n\n.glare-hover:hover {\n  cursor: pointer;\n}\n\n.glare-hover:hover::before {\n  background-position: 100% 100%, 0 0;\n}\n\n.glare-hover--play-once::before {\n  transition: none;\n}\n\n.glare-hover--play-once:hover::before {\n  transition: var(--gh-duration) ease;\n  background-position: 100% 100%, 0 0;\n}\n        ' }), (0, import_jsx_runtime.jsx)("div", { className: `glare-hover ${p2 ? "glare-hover--play-once" : ""} ${f2}`, style: { ...y, ...v2 }, children: c2 })] });
};
var Lt = ({ rows: o2 = 9, columns: a2 = 9, containerSize: s2 = "80vmin", lineColor: c2 = "#efefef", lineWidth: l2 = "1vmin", lineHeight: u2 = "6vmin", baseAngle: h2 = -10, className: d2 = "", style: m2 = {} }) => {
  const p2 = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    const e2 = p2.current;
    if (!e2) return;
    const t2 = e2.querySelectorAll("span"), n2 = (e3) => {
      t2.forEach((t3) => {
        const n3 = t3.getBoundingClientRect(), i3 = n3.x + n3.width / 2, r2 = n3.y + n3.height / 2, o3 = e3.x - i3, a3 = e3.y - r2, s3 = Math.sqrt(a3 * a3 + o3 * o3) || 1, c3 = 180 * Math.acos(o3 / s3) / Math.PI * (e3.y > r2 ? 1 : -1);
        t3.style.setProperty("--rotate", `${c3}deg`);
      });
    }, i2 = (e3) => {
      n2({ x: e3.x, y: e3.y });
    };
    if (window.addEventListener("pointermove", i2), t2.length) {
      const e3 = Math.floor(t2.length / 2), i3 = t2[e3].getBoundingClientRect();
      n2({ x: i3.x, y: i3.y });
    }
    return () => {
      window.removeEventListener("pointermove", i2);
    };
  }, []);
  const f2 = o2 * a2, v2 = Array.from({ length: f2 }, (t2, n2) => (0, import_jsx_runtime.jsx)("span", { style: { "--rotate": `${h2}deg`, backgroundColor: c2, width: l2, height: u2 } }, n2));
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: "\n    .magnetLines-container {\n  display: grid;\n  grid-template-columns: repeat(var(--columns), 1fr);\n  grid-template-rows: repeat(var(--rows), 1fr);\n\n  justify-items: center;\n  align-items: center;\n\n  width: 80vmin;\n  height: 80vmin;\n}\n\n.magnetLines-container span {\n  display: block;\n  transform-origin: center;\n  will-change: transform;\n  transform: rotate(var(--rotate));\n}\n\n     " }), (0, import_jsx_runtime.jsx)("div", { ref: p2, className: `magnetLines-container ${d2}`, style: { display: "grid", gridTemplateColumns: `repeat(${a2}, 1fr)`, gridTemplateRows: `repeat(${o2}, 1fr)`, width: s2, height: s2, ...m2 }, children: v2 })] });
};
var Ft = ({ children: t2, padding: n2 = 100, disabled: a2 = false, magnetStrength: s2 = 2, activeTransition: c2 = "transform 0.3s ease-out", inactiveTransition: l2 = "transform 0.5s ease-in-out", wrapperClassName: u2 = "", innerClassName: h2 = "", ...d2 }) => {
  const [m2, p2] = (0, import_react3.useState)(false), [f2, v2] = (0, import_react3.useState)({ x: 0, y: 0 }), g2 = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    if (a2) return void v2({ x: 0, y: 0 });
    const e2 = (e3) => {
      if (!g2.current) return;
      const { left: t3, top: i2, width: r2, height: o2 } = g2.current.getBoundingClientRect(), a3 = t3 + r2 / 2, c3 = i2 + o2 / 2, l3 = Math.abs(a3 - e3.clientX), u3 = Math.abs(c3 - e3.clientY);
      if (l3 < r2 / 2 + n2 && u3 < o2 / 2 + n2) {
        p2(true);
        const t4 = (e3.clientX - a3) / s2, n3 = (e3.clientY - c3) / s2;
        v2({ x: t4, y: n3 });
      } else p2(false), v2({ x: 0, y: 0 });
    };
    return window.addEventListener("mousemove", e2), () => {
      window.removeEventListener("mousemove", e2);
    };
  }, [n2, a2, s2]);
  const x2 = m2 ? c2 : l2;
  return (0, import_jsx_runtime.jsx)("div", { ref: g2, className: u2, style: { position: "relative", display: "inline-block" }, ...d2, children: (0, import_jsx_runtime.jsx)("div", { className: h2, style: { transform: `translate3d(${f2.x}px, ${f2.y}px, 0)`, transition: x2, willChange: "transform" }, children: t2 }) });
};
var kt = ({ id: n2 = "goo-filter", strength: i2 = 10 }) => (0, import_jsx_runtime.jsx)("svg", { className: "goo-filter-container", children: (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsxs)("filter", { id: n2, children: [(0, import_jsx_runtime.jsx)("feGaussianBlur", { in: "SourceGraphic", stdDeviation: i2, result: "blur" }), (0, import_jsx_runtime.jsx)("feColorMatrix", { in: "blur", type: "matrix", values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9", result: "goo" }), (0, import_jsx_runtime.jsx)("feComposite", { in: "SourceGraphic", in2: "goo", operator: "atop" })] }) }) });
var Dt = (void 0)({ resolution: new Vector2(), mouseTrail: null, gridSize: 100, pixelColor: new Color2("#ffffff") }, "\n    varying vec2 vUv;\n    void main() {\n      gl_Position = vec4(position.xy, 0.0, 1.0);\n    }\n  ", "\n    uniform vec2 resolution;\n    uniform sampler2D mouseTrail;\n    uniform float gridSize;\n    uniform vec3 pixelColor;\n\n    vec2 coverUv(vec2 uv) {\n      vec2 s = resolution.xy / max(resolution.x, resolution.y);\n      vec2 newUv = (uv - 0.5) * s + 0.5;\n      return clamp(newUv, 0.0, 1.0);\n    }\n\n    float sdfCircle(vec2 p, float r) {\n        return length(p - 0.5) - r;\n    }\n\n    void main() {\n      vec2 screenUv = gl_FragCoord.xy / resolution;\n      vec2 uv = coverUv(screenUv);\n\n      vec2 gridUv = fract(uv * gridSize);\n      vec2 gridUvCenter = (floor(uv * gridSize) + 0.5) / gridSize;\n\n      float trail = texture2D(mouseTrail, gridUvCenter).r;\n\n      gl_FragColor = vec4(pixelColor, trail);\n    }\n  ");
function Nt({ gridSize: n2, trailSize: i2, maxAge: r2, interpolate: o2, easingFunction: s2, pixelColor: c2 }) {
  const l2 = (void 0)((e2) => e2.size), u2 = (void 0)((e2) => e2.viewport), h2 = (0, import_react3.useMemo)(() => new Dt(), []);
  h2.uniforms.pixelColor.value = new Color2(c2);
  const [d2, m2] = (void 0)({ size: 512, radius: i2, maxAge: r2, interpolate: o2 || 0.1, ease: s2 || ((e2) => e2) });
  d2 && (d2.minFilter = NearestFilter, d2.magFilter = NearestFilter, d2.wrapS = ClampToEdgeWrapping, d2.wrapT = ClampToEdgeWrapping);
  const p2 = Math.max(u2.width, u2.height) / 2;
  return (0, import_jsx_runtime.jsxs)("mesh", { scale: [p2, p2, 1], onPointerMove: m2, children: [(0, import_jsx_runtime.jsx)("planeGeometry", { args: [2, 2] }), (0, import_jsx_runtime.jsx)("primitive", { object: h2, gridSize: n2, resolution: [l2.width * u2.dpr, l2.height * u2.dpr], mouseTrail: d2 })] });
}
function Bt({ gridSize: i2 = 40, trailSize: r2 = 0.1, maxAge: o2 = 250, interpolate: a2 = 5, easingFunction: s2 = (e2) => e2, canvasProps: c2 = {}, glProps: l2 = { antialias: false, powerPreference: "high-performance", alpha: true }, gooeyFilter: u2, color: h2 = "#ffffff", className: d2 = "" }) {
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".goo-filter-container {\n  position: absolute;\n  overflow: hidden;\n  z-index: 1;\n}\n\n.pixel-canvas {\n  position: absolute;\n  z-index: 1;\n}" }), u2 && (0, import_jsx_runtime.jsx)(kt, { id: u2.id, strength: u2.strength }), (0, import_jsx_runtime.jsx)(void 0, { ...c2, gl: l2, className: `pixel-canvas ${d2}`, style: u2 ? { filter: `url(#${u2.id})` } : void 0, children: (0, import_jsx_runtime.jsx)(Nt, { gridSize: i2, trailSize: r2, maxAge: o2, interpolate: a2, easingFunction: s2, pixelColor: h2 }) })] });
}
var Ut = { patternScale: 2, refraction: 0.015, edge: 1, patternBlur: 5e-3, liquid: 0.07, speed: 0.3 };
function Ot({ imageData: e2, params: t2 = Ut }) {
  const n2 = (0, import_react3.useRef)(null), [a2, s2] = (0, import_react3.useState)(null), [c2, l2] = (0, import_react3.useState)({}), u2 = (0, import_react3.useRef)(0), h2 = (0, import_react3.useRef)(0);
  function d2() {
    a2 && c2 && (a2.uniform1f(c2.u_edge, t2.edge), a2.uniform1f(c2.u_patternBlur, t2.patternBlur), a2.uniform1f(c2.u_time, 0), a2.uniform1f(c2.u_patternScale, t2.patternScale), a2.uniform1f(c2.u_refraction, t2.refraction), a2.uniform1f(c2.u_liquid, t2.liquid));
  }
  (0, import_react3.useEffect)(() => {
    !function() {
      const e3 = n2.current, t3 = e3 == null ? void 0 : e3.getContext("webgl2", { antialias: true, alpha: true });
      if (!e3 || !t3) return;
      function i2(e4, t4, n3) {
        const i3 = e4.createShader(n3);
        return i3 ? (e4.shaderSource(i3, t4), e4.compileShader(i3), e4.getShaderParameter(i3, e4.COMPILE_STATUS) ? i3 : (e4.deleteShader(i3), null)) : null;
      }
      const r2 = i2(t3, "#version 300 es\nprecision mediump float;\n\nin vec2 a_position;\nout vec2 vUv;\n\nvoid main() {\n    vUv = .5 * (a_position + 1.);\n    gl_Position = vec4(a_position, 0.0, 1.0);\n}", t3.VERTEX_SHADER), o2 = i2(t3, "#version 300 es\nprecision mediump float;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nuniform sampler2D u_image_texture;\nuniform float u_time;\nuniform float u_ratio;\nuniform float u_img_ratio;\nuniform float u_patternScale;\nuniform float u_refraction;\nuniform float u_edge;\nuniform float u_patternBlur;\nuniform float u_liquid;\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n\nvec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec2 mod289(vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\nvec3 permute(vec3 x) { return mod289(((x*34.)+1.)*x); }\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute(permute(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2. * fract(p * C.www) - 1.;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130. * dot(m, g);\n}\n\nvec2 get_img_uv() {\n    vec2 img_uv = vUv;\n    img_uv -= .5;\n    if (u_ratio > u_img_ratio) {\n        img_uv.x = img_uv.x * u_ratio / u_img_ratio;\n    } else {\n        img_uv.y = img_uv.y * u_img_ratio / u_ratio;\n    }\n    float scale_factor = 1.;\n    img_uv *= scale_factor;\n    img_uv += .5;\n    img_uv.y = 1. - img_uv.y;\n    return img_uv;\n}\nvec2 rotate(vec2 uv, float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\nfloat get_color_channel(float c1, float c2, float stripe_p, vec3 w, float extra_blur, float b) {\n    float ch = c2;\n    float border = 0.;\n    float blur = u_patternBlur + extra_blur;\n    ch = mix(ch, c1, smoothstep(.0, blur, stripe_p));\n    border = w[0];\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\n    b = smoothstep(.2, .8, b);\n    border = w[0] + .4 * (1. - b) * w[1];\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\n    border = w[0] + .5 * (1. - b) * w[1];\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\n    border = w[0] + w[1];\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\n    float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\n    float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\n    ch = mix(ch, gradient, smoothstep(border - blur, border + blur, stripe_p));\n    return ch;\n}\nfloat get_img_frame_alpha(vec2 uv, float img_frame_width) {\n    float img_frame_alpha = smoothstep(0., img_frame_width, uv.x) * smoothstep(1., 1. - img_frame_width, uv.x);\n    img_frame_alpha *= smoothstep(0., img_frame_width, uv.y) * smoothstep(1., 1. - img_frame_width, uv.y);\n    return img_frame_alpha;\n}\nvoid main() {\n    vec2 uv = vUv;\n    uv.y = 1. - uv.y;\n    uv.x *= u_ratio;\n    float diagonal = uv.x - uv.y;\n    float t = .001 * u_time;\n    vec2 img_uv = get_img_uv();\n    vec4 img = texture(u_image_texture, img_uv);\n    vec3 color = vec3(0.);\n    float opacity = 1.;\n    vec3 color1 = vec3(.98, 0.98, 1.);\n    vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, uv.x + uv.y));\n    float edge = img.r;\n    vec2 grad_uv = uv;\n    grad_uv -= .5;\n    float dist = length(grad_uv + vec2(0., .2 * diagonal));\n    grad_uv = rotate(grad_uv, (.25 - .2 * diagonal) * PI);\n    float bulge = pow(1.8 * dist, 1.2);\n    bulge = 1. - bulge;\n    bulge *= pow(uv.y, .3);\n    float cycle_width = u_patternScale;\n    float thin_strip_1_ratio = .12 / cycle_width * (1. - .4 * bulge);\n    float thin_strip_2_ratio = .07 / cycle_width * (1. + .4 * bulge);\n    float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\n    float thin_strip_1_width = cycle_width * thin_strip_1_ratio;\n    float thin_strip_2_width = cycle_width * thin_strip_2_ratio;\n    opacity = 1. - smoothstep(.9 - .5 * u_edge, 1. - .5 * u_edge, edge);\n    opacity *= get_img_frame_alpha(img_uv, 0.01);\n    float noise = snoise(uv - t);\n    edge += (1. - edge) * u_liquid * noise;\n    float refr = 0.;\n    refr += (1. - bulge);\n    refr = clamp(refr, 0., 1.);\n    float dir = grad_uv.x;\n    dir += diagonal;\n    dir -= 2. * noise * diagonal * (smoothstep(0., 1., edge) * smoothstep(1., 0., edge));\n    bulge *= clamp(pow(uv.y, .1), .3, 1.);\n    dir *= (.1 + (1.1 - edge) * bulge);\n    dir *= smoothstep(1., .7, edge);\n    dir += .18 * (smoothstep(.1, .2, uv.y) * smoothstep(.4, .2, uv.y));\n    dir += .03 * (smoothstep(.1, .2, 1. - uv.y) * smoothstep(.4, .2, 1. - uv.y));\n    dir *= (.5 + .5 * pow(uv.y, 2.));\n    dir *= cycle_width;\n    dir -= t;\n    float refr_r = refr;\n    refr_r += .03 * bulge * noise;\n    float refr_b = 1.3 * refr;\n    refr_r += 5. * (smoothstep(-.1, .2, uv.y) * smoothstep(.5, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(1., .4, bulge));\n    refr_r -= diagonal;\n    refr_b += (smoothstep(0., .4, uv.y) * smoothstep(.8, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(.8, .4, bulge));\n    refr_b -= .2 * edge;\n    refr_r *= u_refraction;\n    refr_b *= u_refraction;\n    vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\n    w[1] -= .02 * smoothstep(.0, 1., edge + bulge);\n    float stripe_r = mod(dir + refr_r, 1.);\n    float r = get_color_channel(color1.r, color2.r, stripe_r, w, 0.02 + .03 * u_refraction * bulge, bulge);\n    float stripe_g = mod(dir, 1.);\n    float g = get_color_channel(color1.g, color2.g, stripe_g, w, 0.01 / (1. - diagonal), bulge);\n    float stripe_b = mod(dir - refr_b, 1.);\n    float b = get_color_channel(color1.b, color2.b, stripe_b, w, .01, bulge);\n    color = vec3(r, g, b);\n    color *= opacity;\n    fragColor = vec4(color, opacity);\n}\n", t3.FRAGMENT_SHADER), a3 = t3.createProgram();
      if (!a3 || !r2 || !o2) return;
      if (t3.attachShader(a3, r2), t3.attachShader(a3, o2), t3.linkProgram(a3), !t3.getProgramParameter(a3, t3.LINK_STATUS)) return null;
      const c3 = function(e4, t4) {
        var _a;
        let n3 = {}, i3 = t4.getProgramParameter(e4, t4.ACTIVE_UNIFORMS);
        for (let r3 = 0; r3 < i3; r3++) {
          let i4 = (_a = t4.getActiveUniform(e4, r3)) == null ? void 0 : _a.name;
          i4 && (n3[i4] = t4.getUniformLocation(e4, i4));
        }
        return n3;
      }(a3, t3);
      l2(c3);
      const u3 = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), h3 = t3.createBuffer();
      t3.bindBuffer(t3.ARRAY_BUFFER, h3), t3.bufferData(t3.ARRAY_BUFFER, u3, t3.STATIC_DRAW), t3.useProgram(a3);
      const d3 = t3.getAttribLocation(a3, "a_position");
      t3.enableVertexAttribArray(d3), t3.bindBuffer(t3.ARRAY_BUFFER, h3), t3.vertexAttribPointer(d3, 2, t3.FLOAT, false, 0, 0), s2(t3);
    }(), d2();
  }, []), (0, import_react3.useEffect)(() => {
    a2 && c2 && d2();
  }, [a2, t2, c2]), (0, import_react3.useEffect)(() => {
    if (!a2 || !c2) return;
    let e3;
    return h2.current = performance.now(), e3 = requestAnimationFrame(function n3(i2) {
      const r2 = i2 - h2.current;
      h2.current = i2, u2.current += r2 * t2.speed, a2.uniform1f(c2.u_time, u2.current), a2.drawArrays(a2.TRIANGLE_STRIP, 0, 4), e3 = requestAnimationFrame(n3);
    }), () => {
      cancelAnimationFrame(e3);
    };
  }, [a2, t2.speed]), (0, import_react3.useEffect)(() => {
    const t3 = n2.current;
    if (t3 && a2 && c2) return i2(), window.addEventListener("resize", i2), () => {
      window.removeEventListener("resize", i2);
    };
    function i2() {
      if (!(t3 && a2 && c2 && e2)) return;
      const n3 = e2.width / e2.height;
      a2.uniform1f(c2.u_img_ratio, n3);
      t3.width = 1e3 * devicePixelRatio, t3.height = 1e3 * devicePixelRatio, a2.viewport(0, 0, t3.height, t3.height), a2.uniform1f(c2.u_ratio, 1), a2.uniform1f(c2.u_img_ratio, n3);
    }
  }, [a2, c2, e2]), (0, import_react3.useEffect)(() => {
    if (!a2 || !c2) return;
    const t3 = a2.getParameter(a2.TEXTURE_BINDING_2D);
    t3 && a2.deleteTexture(t3);
    const n3 = a2.createTexture();
    a2.activeTexture(a2.TEXTURE0), a2.bindTexture(a2.TEXTURE_2D, n3), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, a2.LINEAR), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, a2.LINEAR), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, a2.CLAMP_TO_EDGE), a2.pixelStorei(a2.UNPACK_ALIGNMENT, 1);
    try {
      a2.texImage2D(a2.TEXTURE_2D, 0, a2.RGBA, e2 == null ? void 0 : e2.width, e2 == null ? void 0 : e2.height, 0, a2.RGBA, a2.UNSIGNED_BYTE, e2 == null ? void 0 : e2.data), a2.uniform1i(c2.u_image_texture, 0);
    } catch (e3) {
    }
    return () => {
      n3 && a2.deleteTexture(n3);
    };
  }, [a2, c2, e2]);
}
var Vt = ({ patternSize: o2 = 250, patternScaleX: a2 = 1, patternScaleY: s2 = 1, patternRefreshInterval: c2 = 2, patternAlpha: l2 = 15 }) => {
  const u2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = u2.current;
    if (!e2) return;
    const t2 = e2.getContext("2d");
    if (!t2) return;
    let n2 = 0;
    const i2 = document.createElement("canvas");
    i2.width = o2, i2.height = o2;
    const r2 = i2.getContext("2d");
    if (!r2) return;
    const h2 = r2.createImageData(o2, o2), d2 = o2 * o2 * 4, m2 = () => {
      e2 && (e2.width = window.innerWidth * window.devicePixelRatio, e2.height = window.innerHeight * window.devicePixelRatio, t2.scale(a2, s2));
    }, p2 = () => {
      n2 % c2 === 0 && ((() => {
        for (let e3 = 0; e3 < d2; e3 += 4) {
          const t3 = 255 * Math.random();
          h2.data[e3] = t3, h2.data[e3 + 1] = t3, h2.data[e3 + 2] = t3, h2.data[e3 + 3] = l2;
        }
        r2.putImageData(h2, 0, 0);
      })(), (() => {
        t2.clearRect(0, 0, e2.width, e2.height);
        const n3 = t2.createPattern(i2, "repeat");
        n3 && (t2.fillStyle = n3, t2.fillRect(0, 0, e2.width, e2.height));
      })()), n2++, window.requestAnimationFrame(p2);
    };
    return window.addEventListener("resize", m2), m2(), p2(), () => {
      window.removeEventListener("resize", m2);
    };
  }, [o2, a2, s2, c2, l2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: "\n  .noise-overlay {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100vw;\n  height: 100vh;\n}\n  " }), (0, import_jsx_runtime.jsx)("canvas", { className: "noise-overlay", ref: u2 })] });
};
var Xt = (e2, t2, n2) => (1 - n2) * e2 + n2 * t2;
var qt = ({ color: n2 = "white", containerRef: o2 = null }) => {
  const a2 = (0, import_react3.useRef)(null), s2 = (0, import_react3.useRef)(null), c2 = (0, import_react3.useRef)(null), l2 = (0, import_react3.useRef)(null), u2 = (0, import_react3.useRef)(null);
  let h2 = { x: 0, y: 0 };
  return (0, import_react3.useEffect)(() => {
    const e2 = (e3) => {
      const t3 = e3;
      if (h2 = ((e4, t4) => {
        const n4 = e4;
        if (t4) {
          const e5 = t4.getBoundingClientRect();
          return { x: n4.clientX - e5.left, y: n4.clientY - e5.top };
        }
        return { x: n4.clientX, y: n4.clientY };
      })(t3, o2 == null ? void 0 : o2.current), o2 == null ? void 0 : o2.current) {
        const e4 = o2.current.getBoundingClientRect();
        t3.clientX < e4.left || t3.clientX > e4.right || t3.clientY < e4.top || t3.clientY > e4.bottom ? (void 0).to([s2.current, c2.current].filter(Boolean), { opacity: 0 }) : (void 0).to([s2.current, c2.current].filter(Boolean), { opacity: 1 });
      }
    }, t2 = (o2 == null ? void 0 : o2.current) || window;
    t2.addEventListener("mousemove", e2);
    const n3 = { tx: { previous: 0, current: 0, amt: 0.15 }, ty: { previous: 0, current: 0, amt: 0.15 } };
    (void 0).set([s2.current, c2.current].filter(Boolean), { opacity: 0 });
    const i2 = (e3) => {
      n3.tx.previous = n3.tx.current = h2.x, n3.ty.previous = n3.ty.current = h2.y, (void 0).to([s2.current, c2.current].filter(Boolean), { duration: 0.9, ease: "Power3.easeOut", opacity: 1 }), requestAnimationFrame(p2), t2.removeEventListener("mousemove", i2);
    };
    t2.addEventListener("mousemove", i2);
    const r2 = { turbulence: 0 }, a3 = (void 0).timeline({ paused: true, onStart: () => {
      s2.current && (s2.current.style.filter = "url(#filter-noise-x)"), c2.current && (c2.current.style.filter = "url(#filter-noise-y)");
    }, onUpdate: () => {
      l2.current && u2.current && (l2.current.setAttribute("baseFrequency", r2.turbulence.toString()), u2.current.setAttribute("baseFrequency", r2.turbulence.toString()));
    }, onComplete: () => {
      s2.current && c2.current && (s2.current.style.filter = "none", c2.current.style.filter = "none");
    } }).to(r2, { duration: 0.5, ease: "power1", startAt: { turbulence: 1 }, turbulence: 0 }), d2 = () => a3.restart(), m2 = () => {
      a3.progress(1).kill();
    }, p2 = () => {
      n3.tx.current = h2.x, n3.ty.current = h2.y;
      for (const e3 in n3) {
        const t3 = n3[e3];
        t3.previous = Xt(t3.previous, t3.current, t3.amt);
      }
      s2.current && c2.current && ((void 0).set(c2.current, { x: n3.tx.previous }), (void 0).set(s2.current, { y: n3.ty.previous })), requestAnimationFrame(p2);
    }, f2 = (o2 == null ? void 0 : o2.current) ? o2.current.querySelectorAll("a") : document.querySelectorAll("a");
    return f2.forEach((e3) => {
      e3.addEventListener("mouseenter", d2), e3.addEventListener("mouseleave", m2);
    }), () => {
      t2.removeEventListener("mousemove", e2), t2.removeEventListener("mousemove", i2), f2.forEach((e3) => {
        e3.removeEventListener("mouseenter", d2), e3.removeEventListener("mouseleave", m2);
      });
    };
  }, [o2]), (0, import_jsx_runtime.jsxs)("div", { ref: a2, className: "cursor", style: { position: o2 ? "absolute" : "fixed", top: 0, left: 0, width: "100%", height: "100%", pointerEvents: "none", zIndex: 1e4 }, children: [(0, import_jsx_runtime.jsx)("svg", { style: { position: "absolute", left: 0, top: 0, width: "100%", height: "100%" }, children: (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("filter", { id: "filter-noise-x", children: [(0, import_jsx_runtime.jsx)("feTurbulence", { type: "fractalNoise", baseFrequency: "0.000001", numOctaves: "1", ref: l2 }), (0, import_jsx_runtime.jsx)("feDisplacementMap", { in: "SourceGraphic", scale: "40" })] }), (0, import_jsx_runtime.jsxs)("filter", { id: "filter-noise-y", children: [(0, import_jsx_runtime.jsx)("feTurbulence", { type: "fractalNoise", baseFrequency: "0.000001", numOctaves: "1", ref: u2 }), (0, import_jsx_runtime.jsx)("feDisplacementMap", { in: "SourceGraphic", scale: "40" })] })] }) }), (0, import_jsx_runtime.jsx)("div", { ref: s2, style: { position: "absolute", width: "100%", height: "1px", background: n2, pointerEvents: "none", transform: "translateY(50%)", opacity: 0 } }), (0, import_jsx_runtime.jsx)("div", { ref: c2, style: { position: "absolute", height: "100%", width: "1px", background: n2, pointerEvents: "none", transform: "translateX(50%)", opacity: 0 } })] });
};
function Yt(e2, t2, n2) {
  return (1 - n2) * e2 + n2 * t2;
}
function $t(e2, t2) {
  let n2 = 0, i2 = 0;
  return "touches" in e2 && e2.touches.length > 0 ? (n2 = e2.touches[0].clientX, i2 = e2.touches[0].clientY) : "clientX" in e2 && (n2 = e2.clientX, i2 = e2.clientY), { x: n2 - t2.left, y: i2 - t2.top };
}
function Wt(e2, t2) {
  const n2 = e2.x - t2.x, i2 = e2.y - t2.y;
  return Math.hypot(n2, i2);
}
var Ht = class {
  constructor(e2) {
    this.DOM = { el: null, inner: null }, this.defaultStyle = { scale: 1, x: 0, y: 0, opacity: 0 }, this.rect = null, this.DOM.el = e2, this.DOM.inner = this.DOM.el.querySelector(".content__img-inner"), this.getRect(), this.initEvents();
  }
  initEvents() {
    this.resize = () => {
      (void 0).set(this.DOM.el, this.defaultStyle), this.getRect();
    }, window.addEventListener("resize", this.resize);
  }
  getRect() {
    this.rect = this.DOM.el.getBoundingClientRect();
  }
};
var Gt = { 1: class {
  constructor(e2) {
    this.container = e2, this.DOM = { el: e2 }, this.images = [...e2.querySelectorAll(".content__img")].map((e3) => new Ht(e3)), this.imagesTotal = this.images.length, this.imgPosition = 0, this.zIndexVal = 1, this.activeImagesCount = 0, this.isIdle = true, this.threshold = 80, this.mousePos = { x: 0, y: 0 }, this.lastMousePos = { x: 0, y: 0 }, this.cacheMousePos = { x: 0, y: 0 };
    const t2 = (e3) => {
      const t3 = this.container.getBoundingClientRect();
      this.mousePos = $t(e3, t3);
    };
    e2.addEventListener("mousemove", t2), e2.addEventListener("touchmove", t2);
    const n2 = (t3) => {
      const i2 = this.container.getBoundingClientRect();
      this.mousePos = $t(t3, i2), this.cacheMousePos = { ...this.mousePos }, requestAnimationFrame(() => this.render()), e2.removeEventListener("mousemove", n2), e2.removeEventListener("touchmove", n2);
    };
    e2.addEventListener("mousemove", n2), e2.addEventListener("touchmove", n2);
  }
  render() {
    const e2 = Wt(this.mousePos, this.lastMousePos);
    this.cacheMousePos.x = Yt(this.cacheMousePos.x, this.mousePos.x, 0.1), this.cacheMousePos.y = Yt(this.cacheMousePos.y, this.mousePos.y, 0.1), e2 > this.threshold && (this.showNextImage(), this.lastMousePos = { ...this.mousePos }), this.isIdle && 1 !== this.zIndexVal && (this.zIndexVal = 1), requestAnimationFrame(() => this.render());
  }
  showNextImage() {
    var _a, _b, _c, _d;
    ++this.zIndexVal, this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
    const e2 = this.images[this.imgPosition];
    (void 0).killTweensOf(e2.DOM.el), (void 0).timeline({ onStart: () => this.onImageActivated(), onComplete: () => this.onImageDeactivated() }).fromTo(e2.DOM.el, { opacity: 1, scale: 1, zIndex: this.zIndexVal, x: this.cacheMousePos.x - (((_a = e2.rect) == null ? void 0 : _a.width) ?? 0) / 2, y: this.cacheMousePos.y - (((_b = e2.rect) == null ? void 0 : _b.height) ?? 0) / 2 }, { duration: 0.4, ease: "power1", x: this.mousePos.x - (((_c = e2.rect) == null ? void 0 : _c.width) ?? 0) / 2, y: this.mousePos.y - (((_d = e2.rect) == null ? void 0 : _d.height) ?? 0) / 2 }, 0).to(e2.DOM.el, { duration: 0.4, ease: "power3", opacity: 0, scale: 0.2 }, 0.4);
  }
  onImageActivated() {
    this.activeImagesCount++, this.isIdle = false;
  }
  onImageDeactivated() {
    this.activeImagesCount--, 0 === this.activeImagesCount && (this.isIdle = true);
  }
}, 2: class {
  constructor(e2) {
    this.container = e2, this.DOM = { el: e2 }, this.images = [...e2.querySelectorAll(".content__img")].map((e3) => new Ht(e3)), this.imagesTotal = this.images.length, this.imgPosition = 0, this.zIndexVal = 1, this.activeImagesCount = 0, this.isIdle = true, this.threshold = 80, this.mousePos = { x: 0, y: 0 }, this.lastMousePos = { x: 0, y: 0 }, this.cacheMousePos = { x: 0, y: 0 };
    const t2 = (t3) => {
      const n3 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, n3);
    };
    e2.addEventListener("mousemove", t2), e2.addEventListener("touchmove", t2);
    const n2 = (t3) => {
      const i2 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, i2), this.cacheMousePos = { ...this.mousePos }, requestAnimationFrame(() => this.render()), e2.removeEventListener("mousemove", n2), e2.removeEventListener("touchmove", n2);
    };
    e2.addEventListener("mousemove", n2), e2.addEventListener("touchmove", n2);
  }
  render() {
    const e2 = Wt(this.mousePos, this.lastMousePos);
    this.cacheMousePos.x = Yt(this.cacheMousePos.x, this.mousePos.x, 0.1), this.cacheMousePos.y = Yt(this.cacheMousePos.y, this.mousePos.y, 0.1), e2 > this.threshold && (this.showNextImage(), this.lastMousePos = { ...this.mousePos }), this.isIdle && 1 !== this.zIndexVal && (this.zIndexVal = 1), requestAnimationFrame(() => this.render());
  }
  showNextImage() {
    var _a, _b, _c, _d;
    ++this.zIndexVal, this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
    const e2 = this.images[this.imgPosition];
    (void 0).killTweensOf(e2.DOM.el), (void 0).timeline({ onStart: () => this.onImageActivated(), onComplete: () => this.onImageDeactivated() }).fromTo(e2.DOM.el, { opacity: 1, scale: 0, zIndex: this.zIndexVal, x: this.cacheMousePos.x - (((_a = e2.rect) == null ? void 0 : _a.width) ?? 0) / 2, y: this.cacheMousePos.y - (((_b = e2.rect) == null ? void 0 : _b.height) ?? 0) / 2 }, { duration: 0.4, ease: "power1", scale: 1, x: this.mousePos.x - (((_c = e2.rect) == null ? void 0 : _c.width) ?? 0) / 2, y: this.mousePos.y - (((_d = e2.rect) == null ? void 0 : _d.height) ?? 0) / 2 }, 0).fromTo(e2.DOM.inner, { scale: 2.8, filter: "brightness(250%)" }, { duration: 0.4, ease: "power1", scale: 1, filter: "brightness(100%)" }, 0).to(e2.DOM.el, { duration: 0.4, ease: "power2", opacity: 0, scale: 0.2 }, 0.45);
  }
  onImageActivated() {
    this.activeImagesCount++, this.isIdle = false;
  }
  onImageDeactivated() {
    this.activeImagesCount--, 0 === this.activeImagesCount && (this.isIdle = true);
  }
}, 3: class {
  constructor(e2) {
    this.container = e2, this.DOM = { el: e2 }, this.images = [...e2.querySelectorAll(".content__img")].map((e3) => new Ht(e3)), this.imagesTotal = this.images.length, this.imgPosition = 0, this.zIndexVal = 1, this.activeImagesCount = 0, this.isIdle = true, this.threshold = 80, this.mousePos = { x: 0, y: 0 }, this.lastMousePos = { x: 0, y: 0 }, this.cacheMousePos = { x: 0, y: 0 };
    const t2 = (t3) => {
      const n3 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, n3);
    };
    e2.addEventListener("mousemove", t2), e2.addEventListener("touchmove", t2);
    const n2 = (t3) => {
      const i2 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, i2), this.cacheMousePos = { ...this.mousePos }, requestAnimationFrame(() => this.render()), e2.removeEventListener("mousemove", n2), e2.removeEventListener("touchmove", n2);
    };
    e2.addEventListener("mousemove", n2), e2.addEventListener("touchmove", n2);
  }
  render() {
    const e2 = Wt(this.mousePos, this.lastMousePos);
    this.cacheMousePos.x = Yt(this.cacheMousePos.x, this.mousePos.x, 0.1), this.cacheMousePos.y = Yt(this.cacheMousePos.y, this.mousePos.y, 0.1), e2 > this.threshold && (this.showNextImage(), this.lastMousePos = { ...this.mousePos }), this.isIdle && 1 !== this.zIndexVal && (this.zIndexVal = 1), requestAnimationFrame(() => this.render());
  }
  showNextImage() {
    var _a, _b, _c, _d;
    ++this.zIndexVal, this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
    const e2 = this.images[this.imgPosition];
    (void 0).killTweensOf(e2.DOM.el), (void 0).timeline({ onStart: () => this.onImageActivated(), onComplete: () => this.onImageDeactivated() }).fromTo(e2.DOM.el, { opacity: 1, scale: 0, zIndex: this.zIndexVal, xPercent: 0, yPercent: 0, x: this.cacheMousePos.x - (((_a = e2.rect) == null ? void 0 : _a.width) ?? 0) / 2, y: this.cacheMousePos.y - (((_b = e2.rect) == null ? void 0 : _b.height) ?? 0) / 2 }, { duration: 0.4, ease: "power1", scale: 1, x: this.mousePos.x - (((_c = e2.rect) == null ? void 0 : _c.width) ?? 0) / 2, y: this.mousePos.y - (((_d = e2.rect) == null ? void 0 : _d.height) ?? 0) / 2 }, 0).fromTo(e2.DOM.inner, { scale: 1.2 }, { duration: 0.4, ease: "power1", scale: 1 }, 0).to(e2.DOM.el, { duration: 0.6, ease: "power2", opacity: 0, scale: 0.2, xPercent: () => (void 0).utils.random(-30, 30), yPercent: -200 }, 0.6);
  }
  onImageActivated() {
    this.activeImagesCount++, this.isIdle = false;
  }
  onImageDeactivated() {
    this.activeImagesCount--, 0 === this.activeImagesCount && (this.isIdle = true);
  }
}, 4: class {
  constructor(e2) {
    this.container = e2, this.DOM = { el: e2 }, this.images = [...e2.querySelectorAll(".content__img")].map((e3) => new Ht(e3)), this.imagesTotal = this.images.length, this.imgPosition = 0, this.zIndexVal = 1, this.activeImagesCount = 0, this.isIdle = true, this.threshold = 80, this.mousePos = { x: 0, y: 0 }, this.lastMousePos = { x: 0, y: 0 }, this.cacheMousePos = { x: 0, y: 0 };
    const t2 = (t3) => {
      const n3 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, n3);
    };
    e2.addEventListener("mousemove", t2), e2.addEventListener("touchmove", t2);
    const n2 = (t3) => {
      const i2 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, i2), this.cacheMousePos = { ...this.mousePos }, requestAnimationFrame(() => this.render()), e2.removeEventListener("mousemove", n2), e2.removeEventListener("touchmove", n2);
    };
    e2.addEventListener("mousemove", n2), e2.addEventListener("touchmove", n2);
  }
  render() {
    Wt(this.mousePos, this.lastMousePos) > this.threshold && (this.showNextImage(), this.lastMousePos = { ...this.mousePos }), this.cacheMousePos.x = Yt(this.cacheMousePos.x, this.mousePos.x, 0.1), this.cacheMousePos.y = Yt(this.cacheMousePos.y, this.mousePos.y, 0.1), this.isIdle && 1 !== this.zIndexVal && (this.zIndexVal = 1), requestAnimationFrame(() => this.render());
  }
  showNextImage() {
    var _a, _b, _c, _d;
    ++this.zIndexVal, this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
    const e2 = this.images[this.imgPosition];
    (void 0).killTweensOf(e2.DOM.el);
    let t2 = this.mousePos.x - this.cacheMousePos.x, n2 = this.mousePos.y - this.cacheMousePos.y, i2 = Math.sqrt(t2 * t2 + n2 * n2);
    0 !== i2 && (t2 /= i2, n2 /= i2), t2 *= i2 / 100, n2 *= i2 / 100, (void 0).timeline({ onStart: () => this.onImageActivated(), onComplete: () => this.onImageDeactivated() }).fromTo(e2.DOM.el, { opacity: 1, scale: 0, zIndex: this.zIndexVal, x: this.cacheMousePos.x - (((_a = e2.rect) == null ? void 0 : _a.width) ?? 0) / 2, y: this.cacheMousePos.y - (((_b = e2.rect) == null ? void 0 : _b.height) ?? 0) / 2 }, { duration: 0.4, ease: "power1", scale: 1, x: this.mousePos.x - (((_c = e2.rect) == null ? void 0 : _c.width) ?? 0) / 2, y: this.mousePos.y - (((_d = e2.rect) == null ? void 0 : _d.height) ?? 0) / 2 }, 0).fromTo(e2.DOM.inner, { scale: 2, filter: `brightness(${Math.max(400 * i2 / 100, 100)}%) contrast(${Math.max(400 * i2 / 100, 100)}%)` }, { duration: 0.4, ease: "power1", scale: 1, filter: "brightness(100%) contrast(100%)" }, 0).to(e2.DOM.el, { duration: 0.4, ease: "power3", opacity: 0 }, 0.4).to(e2.DOM.el, { duration: 1.5, ease: "power4", x: "+=" + 110 * t2, y: "+=" + 110 * n2 }, 0.05);
  }
  onImageActivated() {
    this.activeImagesCount++, this.isIdle = false;
  }
  onImageDeactivated() {
    this.activeImagesCount--, 0 === this.activeImagesCount && (this.isIdle = true);
  }
}, 5: class {
  constructor(e2) {
    this.container = e2, this.DOM = { el: e2 }, this.images = [...e2.querySelectorAll(".content__img")].map((e3) => new Ht(e3)), this.imagesTotal = this.images.length, this.imgPosition = 0, this.zIndexVal = 1, this.activeImagesCount = 0, this.isIdle = true, this.threshold = 80, this.mousePos = { x: 0, y: 0 }, this.lastMousePos = { x: 0, y: 0 }, this.cacheMousePos = { x: 0, y: 0 }, this.lastAngle = 0;
    const t2 = (t3) => {
      const n3 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, n3);
    };
    e2.addEventListener("mousemove", t2), e2.addEventListener("touchmove", t2);
    const n2 = (t3) => {
      const i2 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, i2), this.cacheMousePos = { ...this.mousePos }, requestAnimationFrame(() => this.render()), e2.removeEventListener("mousemove", n2), e2.removeEventListener("touchmove", n2);
    };
    e2.addEventListener("mousemove", n2), e2.addEventListener("touchmove", n2);
  }
  render() {
    Wt(this.mousePos, this.lastMousePos) > this.threshold && (this.showNextImage(), this.lastMousePos = { ...this.mousePos }), this.cacheMousePos.x = Yt(this.cacheMousePos.x, this.mousePos.x, 0.1), this.cacheMousePos.y = Yt(this.cacheMousePos.y, this.mousePos.y, 0.1), this.isIdle && 1 !== this.zIndexVal && (this.zIndexVal = 1), requestAnimationFrame(() => this.render());
  }
  showNextImage() {
    var _a, _b, _c, _d;
    let e2 = this.mousePos.x - this.cacheMousePos.x, t2 = this.mousePos.y - this.cacheMousePos.y, n2 = Math.atan2(t2, e2) * (180 / Math.PI);
    n2 < 0 && (n2 += 360), n2 > 90 && n2 <= 270 && (n2 += 180);
    const i2 = n2 >= this.lastAngle;
    this.lastAngle = n2;
    let r2 = i2 ? n2 - 10 : n2 + 10;
    const o2 = Math.sqrt(e2 * e2 + t2 * t2);
    0 !== o2 && (e2 /= o2, t2 /= o2), e2 *= o2 / 150, t2 *= o2 / 150, ++this.zIndexVal, this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
    const a2 = this.images[this.imgPosition];
    (void 0).killTweensOf(a2.DOM.el), (void 0).timeline({ onStart: () => this.onImageActivated(), onComplete: () => this.onImageDeactivated() }).fromTo(a2.DOM.el, { opacity: 1, filter: "brightness(80%)", scale: 0.1, zIndex: this.zIndexVal, x: this.cacheMousePos.x - (((_a = a2.rect) == null ? void 0 : _a.width) ?? 0) / 2, y: this.cacheMousePos.y - (((_b = a2.rect) == null ? void 0 : _b.height) ?? 0) / 2, rotation: r2 }, { duration: 1, ease: "power2", scale: 1, filter: "brightness(100%)", x: this.mousePos.x - (((_c = a2.rect) == null ? void 0 : _c.width) ?? 0) / 2 + 70 * e2, y: this.mousePos.y - (((_d = a2.rect) == null ? void 0 : _d.height) ?? 0) / 2 + 70 * t2, rotation: this.lastAngle }, 0).to(a2.DOM.el, { duration: 0.4, ease: "expo", opacity: 0 }, 0.5).to(a2.DOM.el, { duration: 1.5, ease: "power4", x: "+=" + 120 * e2, y: "+=" + 120 * t2 }, 0.05);
  }
  onImageActivated() {
    this.activeImagesCount++, this.isIdle = false;
  }
  onImageDeactivated() {
    this.activeImagesCount--, 0 === this.activeImagesCount && (this.isIdle = true);
  }
}, 6: class {
  constructor(e2) {
    this.container = e2, this.DOM = { el: e2 }, this.images = [...e2.querySelectorAll(".content__img")].map((e3) => new Ht(e3)), this.imagesTotal = this.images.length, this.imgPosition = 0, this.zIndexVal = 1, this.activeImagesCount = 0, this.isIdle = true, this.threshold = 80, this.mousePos = { x: 0, y: 0 }, this.lastMousePos = { x: 0, y: 0 }, this.cacheMousePos = { x: 0, y: 0 };
    const t2 = (t3) => {
      const n3 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, n3);
    };
    e2.addEventListener("mousemove", t2), e2.addEventListener("touchmove", t2);
    const n2 = (t3) => {
      const i2 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, i2), this.cacheMousePos = { ...this.mousePos }, requestAnimationFrame(() => this.render()), e2.removeEventListener("mousemove", n2), e2.removeEventListener("touchmove", n2);
    };
    e2.addEventListener("mousemove", n2), e2.addEventListener("touchmove", n2);
  }
  render() {
    const e2 = Wt(this.mousePos, this.lastMousePos);
    this.cacheMousePos.x = Yt(this.cacheMousePos.x, this.mousePos.x, 0.3), this.cacheMousePos.y = Yt(this.cacheMousePos.y, this.mousePos.y, 0.3), e2 > this.threshold && (this.showNextImage(), this.lastMousePos = { ...this.mousePos }), this.isIdle && 1 !== this.zIndexVal && (this.zIndexVal = 1), requestAnimationFrame(() => this.render());
  }
  mapSpeedToSize(e2, t2, n2) {
    return t2 + (n2 - t2) * Math.min(e2 / 200, 1);
  }
  mapSpeedToBrightness(e2, t2, n2) {
    return t2 + (n2 - t2) * Math.min(e2 / 70, 1);
  }
  mapSpeedToBlur(e2, t2, n2) {
    return t2 + (n2 - t2) * Math.min(e2 / 90, 1);
  }
  mapSpeedToGrayscale(e2, t2, n2) {
    return t2 + (n2 - t2) * Math.min(e2 / 90, 1);
  }
  showNextImage() {
    var _a, _b, _c, _d;
    const e2 = this.mousePos.x - this.cacheMousePos.x, t2 = this.mousePos.y - this.cacheMousePos.y, n2 = Math.sqrt(e2 * e2 + t2 * t2);
    ++this.zIndexVal, this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
    const i2 = this.images[this.imgPosition], r2 = this.mapSpeedToSize(n2, 0.3, 2), o2 = this.mapSpeedToBrightness(n2, 0, 1.3), a2 = this.mapSpeedToBlur(n2, 20, 0), s2 = this.mapSpeedToGrayscale(n2, 600, 0);
    (void 0).killTweensOf(i2.DOM.el), (void 0).timeline({ onStart: () => this.onImageActivated(), onComplete: () => this.onImageDeactivated() }).fromTo(i2.DOM.el, { opacity: 1, scale: 0, zIndex: this.zIndexVal, x: this.cacheMousePos.x - (((_a = i2.rect) == null ? void 0 : _a.width) ?? 0) / 2, y: this.cacheMousePos.y - (((_b = i2.rect) == null ? void 0 : _b.height) ?? 0) / 2 }, { duration: 0.8, ease: "power3", scale: r2, filter: `grayscale(${100 * s2}%) brightness(${100 * o2}%) blur(${a2}px)`, x: this.mousePos.x - (((_c = i2.rect) == null ? void 0 : _c.width) ?? 0) / 2, y: this.mousePos.y - (((_d = i2.rect) == null ? void 0 : _d.height) ?? 0) / 2 }, 0).fromTo(i2.DOM.inner, { scale: 2 }, { duration: 0.8, ease: "power3", scale: 1 }, 0).to(i2.DOM.el, { duration: 0.4, ease: "power3.in", opacity: 0, scale: 0.2 }, 0.45);
  }
  onImageActivated() {
    this.activeImagesCount++, this.isIdle = false;
  }
  onImageDeactivated() {
    this.activeImagesCount--, 0 === this.activeImagesCount && (this.isIdle = true);
  }
}, 7: class {
  constructor(e2) {
    this.container = e2, this.DOM = { el: e2 }, this.images = [...e2.querySelectorAll(".content__img")].map((e3) => new Ht(e3)), this.imagesTotal = this.images.length, this.imgPosition = 0, this.zIndexVal = 1, this.activeImagesCount = 0, this.isIdle = true, this.threshold = 80, this.mousePos = { x: 0, y: 0 }, this.lastMousePos = { x: 0, y: 0 }, this.cacheMousePos = { x: 0, y: 0 }, this.visibleImagesCount = 0, this.visibleImagesTotal = 9, this.visibleImagesTotal = Math.min(this.visibleImagesTotal, this.imagesTotal - 1);
    const t2 = (t3) => {
      const n3 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, n3);
    };
    e2.addEventListener("mousemove", t2), e2.addEventListener("touchmove", t2);
    const n2 = (t3) => {
      const i2 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, i2), this.cacheMousePos = { ...this.mousePos }, requestAnimationFrame(() => this.render()), e2.removeEventListener("mousemove", n2), e2.removeEventListener("touchmove", n2);
    };
    e2.addEventListener("mousemove", n2), e2.addEventListener("touchmove", n2);
  }
  render() {
    const e2 = Wt(this.mousePos, this.lastMousePos);
    this.cacheMousePos.x = Yt(this.cacheMousePos.x, this.mousePos.x, 0.3), this.cacheMousePos.y = Yt(this.cacheMousePos.y, this.mousePos.y, 0.3), e2 > this.threshold && (this.showNextImage(), this.lastMousePos = { ...this.mousePos }), this.isIdle && 1 !== this.zIndexVal && (this.zIndexVal = 1), requestAnimationFrame(() => this.render());
  }
  showNextImage() {
    var _a, _b, _c, _d;
    ++this.zIndexVal, this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
    const e2 = this.images[this.imgPosition];
    ++this.visibleImagesCount, (void 0).killTweensOf(e2.DOM.el);
    const t2 = (void 0).utils.random(0.5, 1.6);
    if ((void 0).timeline({ onStart: () => this.onImageActivated(), onComplete: () => this.onImageDeactivated() }).fromTo(e2.DOM.el, { scale: t2 - Math.max((void 0).utils.random(0.2, 0.6), 0), rotationZ: 0, opacity: 1, zIndex: this.zIndexVal, x: this.cacheMousePos.x - (((_a = e2.rect) == null ? void 0 : _a.width) ?? 0) / 2, y: this.cacheMousePos.y - (((_b = e2.rect) == null ? void 0 : _b.height) ?? 0) / 2 }, { duration: 0.4, ease: "power3", scale: t2, rotationZ: (void 0).utils.random(-3, 3), x: this.mousePos.x - (((_c = e2.rect) == null ? void 0 : _c.width) ?? 0) / 2, y: this.mousePos.y - (((_d = e2.rect) == null ? void 0 : _d.height) ?? 0) / 2 }, 0), this.visibleImagesCount >= this.visibleImagesTotal) {
      const e3 = function(e4, t4, n2) {
        const i2 = Math.abs(t4) % n2.length;
        return e4 - i2 >= 0 ? e4 - i2 : n2.length - (i2 - e4);
      }(this.imgPosition, this.visibleImagesTotal, this.images), t3 = this.images[e3];
      (void 0).to(t3.DOM.el, { duration: 0.4, ease: "power4", opacity: 0, scale: 1.3, onComplete: () => {
        0 === this.activeImagesCount && (this.isIdle = true);
      } });
    }
  }
  onImageActivated() {
    this.activeImagesCount++, this.isIdle = false;
  }
  onImageDeactivated() {
    this.activeImagesCount--;
  }
}, 8: class {
  constructor(e2) {
    this.container = e2, this.DOM = { el: e2 }, this.images = [...e2.querySelectorAll(".content__img")].map((e3) => new Ht(e3)), this.imagesTotal = this.images.length, this.imgPosition = 0, this.zIndexVal = 1, this.activeImagesCount = 0, this.isIdle = true, this.threshold = 80, this.mousePos = { x: 0, y: 0 }, this.lastMousePos = { x: 0, y: 0 }, this.cacheMousePos = { x: 0, y: 0 }, this.rotation = { x: 0, y: 0 }, this.cachedRotation = { x: 0, y: 0 }, this.zValue = 0, this.cachedZValue = 0;
    const t2 = (t3) => {
      const n3 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, n3);
    };
    e2.addEventListener("mousemove", t2), e2.addEventListener("touchmove", t2);
    const n2 = (t3) => {
      const i2 = e2.getBoundingClientRect();
      this.mousePos = $t(t3, i2), this.cacheMousePos = { ...this.mousePos }, requestAnimationFrame(() => this.render()), e2.removeEventListener("mousemove", n2), e2.removeEventListener("touchmove", n2);
    };
    e2.addEventListener("mousemove", n2), e2.addEventListener("touchmove", n2);
  }
  render() {
    const e2 = Wt(this.mousePos, this.lastMousePos);
    this.cacheMousePos.x = Yt(this.cacheMousePos.x, this.mousePos.x, 0.1), this.cacheMousePos.y = Yt(this.cacheMousePos.y, this.mousePos.y, 0.1), e2 > this.threshold && (this.showNextImage(), this.lastMousePos = { ...this.mousePos }), this.isIdle && 1 !== this.zIndexVal && (this.zIndexVal = 1), requestAnimationFrame(() => this.render());
  }
  showNextImage() {
    var _a, _b, _c, _d;
    const e2 = this.container.getBoundingClientRect(), t2 = e2.width / 2, n2 = e2.height / 2, i2 = this.mousePos.x - t2, r2 = this.mousePos.y - n2;
    this.rotation.x = -r2 / n2 * 30, this.rotation.y = i2 / t2 * 30, this.cachedRotation = { ...this.rotation };
    const o2 = Math.sqrt(i2 * i2 + r2 * r2) / Math.sqrt(t2 * t2 + n2 * n2);
    this.zValue = 1200 * o2 - 600, this.cachedZValue = this.zValue;
    const a2 = 0.2 + 2.3 * ((this.zValue + 600) / 1200);
    ++this.zIndexVal, this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;
    const s2 = this.images[this.imgPosition];
    (void 0).killTweensOf(s2.DOM.el), (void 0).timeline({ onStart: () => this.onImageActivated(), onComplete: () => this.onImageDeactivated() }).set(this.DOM.el, { perspective: 1e3 }, 0).fromTo(s2.DOM.el, { opacity: 1, z: 0, scale: 1 + this.cachedZValue / 1e3, zIndex: this.zIndexVal, x: this.cacheMousePos.x - (((_a = s2.rect) == null ? void 0 : _a.width) ?? 0) / 2, y: this.cacheMousePos.y - (((_b = s2.rect) == null ? void 0 : _b.height) ?? 0) / 2, rotationX: this.cachedRotation.x, rotationY: this.cachedRotation.y, filter: `brightness(${a2})` }, { duration: 1, ease: "expo", scale: 1 + this.zValue / 1e3, x: this.mousePos.x - (((_c = s2.rect) == null ? void 0 : _c.width) ?? 0) / 2, y: this.mousePos.y - (((_d = s2.rect) == null ? void 0 : _d.height) ?? 0) / 2, rotationX: this.rotation.x, rotationY: this.rotation.y }, 0).to(s2.DOM.el, { duration: 0.4, ease: "power2", opacity: 0, z: -800 }, 0.3);
  }
  onImageActivated() {
    this.activeImagesCount++, this.isIdle = false;
  }
  onImageDeactivated() {
    this.activeImagesCount--, 0 === this.activeImagesCount && (this.isIdle = true);
  }
} };
function jt({ items: o2 = [], variant: a2 = 1 }) {
  const s2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    if (!s2.current) return;
    new (Gt[a2] || Gt[1])(s2.current);
  }, [a2, o2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: "\n    .content {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  z-index: 100;\n  border-radius: 8px;\n  background: transparent;\n  overflow: visible;\n}\n\n.content__img {\n  width: 190px;\n  aspect-ratio: 1.1;\n  border-radius: 15px;\n  position: absolute;\n  top: 0;\n  left: 0;\n  opacity: 0;\n  overflow: hidden;\n  will-change: transform, filter;\n}\n\n.content__img-inner {\n  background-position: 50% 50%;\n  width: calc(100% + 20px);\n  height: calc(100% + 20px);\n  background-size: cover;\n  position: absolute;\n  top: calc(-1 * 20px / 2);\n  left: calc(-1 * 20px / 2);\n}\n    " }), (0, import_jsx_runtime.jsx)("div", { className: "content", ref: s2, children: o2.map((t2, n2) => (0, import_jsx_runtime.jsx)("div", { className: "content__img", children: (0, import_jsx_runtime.jsx)("div", { className: "content__img-inner", style: { backgroundImage: `url(${t2})` } }) }, n2)) })] });
}
var Zt = ({ colors: o2 = ["#ff9346", "#7cff67", "#ffee51", "#5227FF"], baseSpring: a2 = 0.03, baseFriction: s2 = 0.9, baseThickness: c2 = 30, offsetFactor: l2 = 0.05, maxAge: u2 = 500, pointCount: h2 = 50, speedMultiplier: d2 = 0.6, enableFade: m2 = false, enableShaderEffect: p2 = false, effectAmplitude: f2 = 2, backgroundColor: v2 = [0, 0, 0, 0] }) => {
  const g2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = g2.current;
    if (!e2) return;
    const t2 = new Renderer({ dpr: window.devicePixelRatio || 2, alpha: true }), n2 = t2.gl;
    Array.isArray(v2) && 4 === v2.length ? n2.clearColor(v2[0], v2[1], v2[2], v2[3]) : n2.clearColor(0, 0, 0, 0), n2.canvas.style.position = "absolute", n2.canvas.style.top = "0", n2.canvas.style.left = "0", n2.canvas.style.width = "100%", n2.canvas.style.height = "100%", e2.appendChild(n2.canvas);
    const i2 = new Transform(), r2 = [];
    function x2() {
      if (!e2) return;
      const n3 = e2.clientWidth, i3 = e2.clientHeight;
      t2.setSize(n3, i3), r2.forEach((e3) => e3.polyline.resize());
    }
    window.addEventListener("resize", x2);
    const y = (o2.length - 1) / 2;
    o2.forEach((e3, t3) => {
      const o3 = a2 + 0.05 * (Math.random() - 0.5), u3 = s2 + 0.05 * (Math.random() - 0.5), d3 = c2 + 3 * (Math.random() - 0.5), v3 = new Vec3((t3 - y) * l2 + 0.01 * (Math.random() - 0.5), 0.1 * (Math.random() - 0.5), 0), g3 = { spring: o3, friction: u3, mouseVelocity: new Vec3(), mouseOffset: v3, points: [], polyline: {} }, x3 = h2, w2 = [];
      for (let e4 = 0; e4 < x3; e4++) w2.push(new Vec3());
      g3.points = w2, g3.polyline = new Polyline(n2, { points: w2, vertex: "\n      precision highp float;\n      \n      attribute vec3 position;\n      attribute vec3 next;\n      attribute vec3 prev;\n      attribute vec2 uv;\n      attribute float side;\n      \n      uniform vec2 uResolution;\n      uniform float uDPR;\n      uniform float uThickness;\n      uniform float uTime;\n      uniform float uEnableShaderEffect;\n      uniform float uEffectAmplitude;\n      \n      varying vec2 vUV;\n      \n      vec4 getPosition() {\n          vec4 current = vec4(position, 1.0);\n          vec2 aspect = vec2(uResolution.x / uResolution.y, 1.0);\n          vec2 nextScreen = next.xy * aspect;\n          vec2 prevScreen = prev.xy * aspect;\n          vec2 tangent = normalize(nextScreen - prevScreen);\n          vec2 normal = vec2(-tangent.y, tangent.x);\n          normal /= aspect;\n          normal *= mix(1.0, 0.1, pow(abs(uv.y - 0.5) * 2.0, 2.0));\n          float dist = length(nextScreen - prevScreen);\n          normal *= smoothstep(0.0, 0.02, dist);\n          float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n          float pixelWidth = current.w * pixelWidthRatio;\n          normal *= pixelWidth * uThickness;\n          current.xy -= normal * side;\n          if(uEnableShaderEffect > 0.5) {\n            current.xy += normal * sin(uTime + current.x * 10.0) * uEffectAmplitude;\n          }\n          return current;\n      }\n      \n      void main() {\n          vUV = uv;\n          gl_Position = getPosition();\n      }\n    ", fragment: "\n      precision highp float;\n      uniform vec3 uColor;\n      uniform float uOpacity;\n      uniform float uEnableFade;\n      varying vec2 vUV;\n      void main() {\n          float fadeFactor = 1.0;\n          if(uEnableFade > 0.5) {\n              fadeFactor = 1.0 - smoothstep(0.0, 1.0, vUV.y);\n          }\n          gl_FragColor = vec4(uColor, uOpacity * fadeFactor);\n      }\n    ", uniforms: { uColor: { value: new Color(e3) }, uThickness: { value: d3 }, uOpacity: { value: 1 }, uTime: { value: 0 }, uEnableShaderEffect: { value: p2 ? 1 : 0 }, uEffectAmplitude: { value: f2 }, uEnableFade: { value: m2 ? 1 : 0 } } }), g3.polyline.mesh.setParent(i2), r2.push(g3);
    }), x2();
    const w = new Vec3();
    function b(t3) {
      let n3, i3;
      if (!e2) return;
      const r3 = e2.getBoundingClientRect();
      "changedTouches" in t3 && t3.changedTouches.length ? (n3 = t3.changedTouches[0].clientX - r3.left, i3 = t3.changedTouches[0].clientY - r3.top) : t3 instanceof MouseEvent ? (n3 = t3.clientX - r3.left, i3 = t3.clientY - r3.top) : (n3 = 0, i3 = 0);
      const o3 = e2.clientWidth, a3 = e2.clientHeight;
      w.set(n3 / o3 * 2 - 1, i3 / a3 * -2 + 1, 0);
    }
    e2.addEventListener("mousemove", b), e2.addEventListener("touchstart", b), e2.addEventListener("touchmove", b);
    const M = new Vec3();
    let P, S = performance.now();
    return function e3() {
      P = requestAnimationFrame(e3);
      const n3 = performance.now(), o3 = n3 - S;
      S = n3, r2.forEach((e4) => {
        M.copy(w).add(e4.mouseOffset).sub(e4.points[0]).multiply(e4.spring), e4.mouseVelocity.add(M).multiply(e4.friction), e4.points[0].add(e4.mouseVelocity);
        for (let t3 = 1; t3 < e4.points.length; t3++) if (isFinite(u2) && u2 > 0) {
          const n4 = u2 / (e4.points.length - 1), i3 = Math.min(1, o3 * d2 / n4);
          e4.points[t3].lerp(e4.points[t3 - 1], i3);
        } else e4.points[t3].lerp(e4.points[t3 - 1], 0.9);
        e4.polyline.mesh.program.uniforms.uTime && (e4.polyline.mesh.program.uniforms.uTime.value = 1e-3 * n3), e4.polyline.updateGeometry();
      }), t2.render({ scene: i2 });
    }(), () => {
      window.removeEventListener("resize", x2), e2.removeEventListener("mousemove", b), e2.removeEventListener("touchstart", b), e2.removeEventListener("touchmove", b), cancelAnimationFrame(P), n2.canvas && n2.canvas.parentNode === e2 && e2.removeChild(n2.canvas);
    };
  }, [o2, a2, s2, c2, l2, u2, h2, d2, m2, p2, f2, v2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: "\n    .ribbons-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n    " }), (0, import_jsx_runtime.jsx)("div", { ref: g2, className: "ribbons-container" }), ";"] });
};
function Kt({ SIM_RESOLUTION: t2 = 128, DYE_RESOLUTION: n2 = 1440, CAPTURE_RESOLUTION: o2 = 512, DENSITY_DISSIPATION: a2 = 3.5, VELOCITY_DISSIPATION: s2 = 2, PRESSURE: c2 = 0.1, PRESSURE_ITERATIONS: l2 = 20, CURL: u2 = 3, SPLAT_RADIUS: h2 = 0.2, SPLAT_FORCE: d2 = 6e3, SHADING: m2 = true, COLOR_UPDATE_SPEED: p2 = 10, BACK_COLOR: f2 = { r: 0.5, g: 0, b: 0 }, TRANSPARENT: v2 = true }) {
  const g2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = g2.current;
    if (!e2) return;
    let i2 = [{ id: -1, texcoordX: 0, texcoordY: 0, prevTexcoordX: 0, prevTexcoordY: 0, deltaX: 0, deltaY: 0, down: false, moved: false, color: { r: 0, g: 0, b: 0 } }], r2 = { SIM_RESOLUTION: t2, DYE_RESOLUTION: n2, DENSITY_DISSIPATION: a2, VELOCITY_DISSIPATION: s2, PRESSURE: c2, PRESSURE_ITERATIONS: l2, CURL: u2, SPLAT_RADIUS: h2, SPLAT_FORCE: d2, SHADING: m2, COLOR_UPDATE_SPEED: p2 };
    const { gl: o3, ext: f3 } = function(e3) {
      const t3 = { alpha: true, depth: false, stencil: false, antialias: false, preserveDrawingBuffer: false };
      let n3 = e3.getContext("webgl2", t3);
      n3 || (n3 = e3.getContext("webgl", t3) || e3.getContext("experimental-webgl", t3));
      if (!n3) throw new Error("Unable to initialize WebGL.");
      const i3 = "drawBuffers" in n3;
      let r3 = false, o4 = null;
      i3 ? (n3.getExtension("EXT_color_buffer_float"), r3 = !!n3.getExtension("OES_texture_float_linear")) : (o4 = n3.getExtension("OES_texture_half_float"), r3 = !!n3.getExtension("OES_texture_half_float_linear"));
      n3.clearColor(0, 0, 0, 1);
      const a3 = i3 ? n3.HALF_FLOAT : o4 && o4.HALF_FLOAT_OES || 0;
      let s3, c3, l3;
      i3 ? (s3 = v3(n3, n3.RGBA16F, n3.RGBA, a3), c3 = v3(n3, n3.RG16F, n3.RG, a3), l3 = v3(n3, n3.R16F, n3.RED, a3)) : (s3 = v3(n3, n3.RGBA, n3.RGBA, a3), c3 = v3(n3, n3.RGBA, n3.RGBA, a3), l3 = v3(n3, n3.RGBA, n3.RGBA, a3));
      return { gl: n3, ext: { formatRGBA: s3, formatRG: c3, formatR: l3, halfFloatTexType: a3, supportLinearFiltering: r3 } };
    }(e2);
    if (!o3 || !f3) return;
    function v3(e3, t3, n3, i3) {
      if (!function(e4, t4, n4, i4) {
        const r3 = e4.createTexture();
        if (!r3) return false;
        e4.bindTexture(e4.TEXTURE_2D, r3), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MIN_FILTER, e4.NEAREST), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MAG_FILTER, e4.NEAREST), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_S, e4.CLAMP_TO_EDGE), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_T, e4.CLAMP_TO_EDGE), e4.texImage2D(e4.TEXTURE_2D, 0, t4, 4, 4, 0, n4, i4, null);
        const o4 = e4.createFramebuffer();
        if (!o4) return false;
        e4.bindFramebuffer(e4.FRAMEBUFFER, o4), e4.framebufferTexture2D(e4.FRAMEBUFFER, e4.COLOR_ATTACHMENT0, e4.TEXTURE_2D, r3, 0);
        const a3 = e4.checkFramebufferStatus(e4.FRAMEBUFFER);
        return a3 === e4.FRAMEBUFFER_COMPLETE;
      }(e3, t3, n3, i3)) {
        if ("drawBuffers" in e3) {
          const n4 = e3;
          switch (t3) {
            case n4.R16F:
              return v3(n4, n4.RG16F, n4.RG, i3);
            case n4.RG16F:
              return v3(n4, n4.RGBA16F, n4.RGBA, i3);
            default:
              return null;
          }
        }
        return null;
      }
      return { internalFormat: t3, format: n3 };
    }
    function x2(e3) {
      if (!e3.length) return 0;
      let t3 = 0;
      for (let n3 = 0; n3 < e3.length; n3++) t3 = (t3 << 5) - t3 + e3.charCodeAt(n3), t3 |= 0;
      return t3;
    }
    function y(e3, t3, n3 = null) {
      const i3 = function(e4, t4) {
        if (!t4) return e4;
        let n4 = "";
        for (const e5 of t4) n4 += `#define ${e5}
`;
        return n4 + e4;
      }(t3, n3), r3 = o3.createShader(e3);
      return r3 ? (o3.shaderSource(r3, i3), o3.compileShader(r3), o3.getShaderParameter(r3, o3.COMPILE_STATUS), r3) : null;
    }
    function w(e3, t3) {
      if (!e3 || !t3) return null;
      const n3 = o3.createProgram();
      return n3 ? (o3.attachShader(n3, e3), o3.attachShader(n3, t3), o3.linkProgram(n3), o3.getProgramParameter(n3, o3.LINK_STATUS), n3) : null;
    }
    function b(e3) {
      let t3 = {};
      const n3 = o3.getProgramParameter(e3, o3.ACTIVE_UNIFORMS);
      for (let i3 = 0; i3 < n3; i3++) {
        const n4 = o3.getActiveUniform(e3, i3);
        n4 && (t3[n4.name] = o3.getUniformLocation(e3, n4.name));
      }
      return t3;
    }
    f3.supportLinearFiltering || (r2.DYE_RESOLUTION = 256, r2.SHADING = false);
    class M {
      constructor(e3, t3) {
        this.program = w(e3, t3), this.uniforms = this.program ? b(this.program) : {};
      }
      bind() {
        this.program && o3.useProgram(this.program);
      }
    }
    const P = y(o3.VERTEX_SHADER, "\n      precision highp float;\n      attribute vec2 aPosition;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform vec2 texelSize;\n\n      void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n      }\n    "), S = y(o3.FRAGMENT_SHADER, "\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      uniform sampler2D uTexture;\n\n      void main () {\n          gl_FragColor = texture2D(uTexture, vUv);\n      }\n    "), C = y(o3.FRAGMENT_SHADER, "\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      uniform sampler2D uTexture;\n      uniform float value;\n\n      void main () {\n          gl_FragColor = value * texture2D(uTexture, vUv);\n      }\n    "), E = y(o3.FRAGMENT_SHADER, "\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      uniform sampler2D uTarget;\n      uniform float aspectRatio;\n      uniform vec3 color;\n      uniform vec2 point;\n      uniform float radius;\n\n      void main () {\n          vec2 p = vUv - point.xy;\n          p.x *= aspectRatio;\n          vec3 splat = exp(-dot(p, p) / radius) * color;\n          vec3 base = texture2D(uTarget, vUv).xyz;\n          gl_FragColor = vec4(base + splat, 1.0);\n      }\n    "), z = y(o3.FRAGMENT_SHADER, "\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      uniform sampler2D uVelocity;\n      uniform sampler2D uSource;\n      uniform vec2 texelSize;\n      uniform vec2 dyeTexelSize;\n      uniform float dt;\n      uniform float dissipation;\n\n      vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n          vec2 st = uv / tsize - 0.5;\n          vec2 iuv = floor(st);\n          vec2 fuv = fract(st);\n\n          vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n          vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n          vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n          vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n          return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n      }\n\n      void main () {\n          #ifdef MANUAL_FILTERING\n              vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n              vec4 result = bilerp(uSource, coord, dyeTexelSize);\n          #else\n              vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n              vec4 result = texture2D(uSource, coord);\n          #endif\n          float decay = 1.0 + dissipation * dt;\n          gl_FragColor = result / decay;\n      }\n    ", f3.supportLinearFiltering ? null : ["MANUAL_FILTERING"]), _ = y(o3.FRAGMENT_SHADER, "\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      varying highp vec2 vL;\n      varying highp vec2 vR;\n      varying highp vec2 vT;\n      varying highp vec2 vB;\n      uniform sampler2D uVelocity;\n\n      void main () {\n          float L = texture2D(uVelocity, vL).x;\n          float R = texture2D(uVelocity, vR).x;\n          float T = texture2D(uVelocity, vT).y;\n          float B = texture2D(uVelocity, vB).y;\n\n          vec2 C = texture2D(uVelocity, vUv).xy;\n          if (vL.x < 0.0) { L = -C.x; }\n          if (vR.x > 1.0) { R = -C.x; }\n          if (vT.y > 1.0) { T = -C.y; }\n          if (vB.y < 0.0) { B = -C.y; }\n\n          float div = 0.5 * (R - L + T - B);\n          gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n      }\n    "), T = y(o3.FRAGMENT_SHADER, "\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      varying highp vec2 vL;\n      varying highp vec2 vR;\n      varying highp vec2 vT;\n      varying highp vec2 vB;\n      uniform sampler2D uVelocity;\n\n      void main () {\n          float L = texture2D(uVelocity, vL).y;\n          float R = texture2D(uVelocity, vR).y;\n          float T = texture2D(uVelocity, vT).x;\n          float B = texture2D(uVelocity, vB).x;\n          float vorticity = R - L - T + B;\n          gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n      }\n    "), A = y(o3.FRAGMENT_SHADER, "\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform sampler2D uVelocity;\n      uniform sampler2D uCurl;\n      uniform float curl;\n      uniform float dt;\n\n      void main () {\n          float L = texture2D(uCurl, vL).x;\n          float R = texture2D(uCurl, vR).x;\n          float T = texture2D(uCurl, vT).x;\n          float B = texture2D(uCurl, vB).x;\n          float C = texture2D(uCurl, vUv).x;\n\n          vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n          force /= length(force) + 0.0001;\n          force *= curl * C;\n          force.y *= -1.0;\n\n          vec2 velocity = texture2D(uVelocity, vUv).xy;\n          velocity += force * dt;\n          velocity = min(max(velocity, -1000.0), 1000.0);\n          gl_FragColor = vec4(velocity, 0.0, 1.0);\n      }\n    "), R2 = y(o3.FRAGMENT_SHADER, "\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      varying highp vec2 vL;\n      varying highp vec2 vR;\n      varying highp vec2 vT;\n      varying highp vec2 vB;\n      uniform sampler2D uPressure;\n      uniform sampler2D uDivergence;\n\n      void main () {\n          float L = texture2D(uPressure, vL).x;\n          float R = texture2D(uPressure, vR).x;\n          float T = texture2D(uPressure, vT).x;\n          float B = texture2D(uPressure, vB).x;\n          float C = texture2D(uPressure, vUv).x;\n          float divergence = texture2D(uDivergence, vUv).x;\n          float pressure = (L + R + B + T - divergence) * 0.25;\n          gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n      }\n    "), I = y(o3.FRAGMENT_SHADER, "\n      precision mediump float;\n      precision mediump sampler2D;\n      varying highp vec2 vUv;\n      varying highp vec2 vL;\n      varying highp vec2 vR;\n      varying highp vec2 vT;\n      varying highp vec2 vB;\n      uniform sampler2D uPressure;\n      uniform sampler2D uVelocity;\n\n      void main () {\n          float L = texture2D(uPressure, vL).x;\n          float R = texture2D(uPressure, vR).x;\n          float T = texture2D(uPressure, vT).x;\n          float B = texture2D(uPressure, vB).x;\n          vec2 velocity = texture2D(uVelocity, vUv).xy;\n          velocity.xy -= vec2(R - L, T - B);\n          gl_FragColor = vec4(velocity, 0.0, 1.0);\n      }\n    "), L = (() => {
      const e3 = o3.createBuffer();
      o3.bindBuffer(o3.ARRAY_BUFFER, e3), o3.bufferData(o3.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), o3.STATIC_DRAW);
      const t3 = o3.createBuffer();
      return o3.bindBuffer(o3.ELEMENT_ARRAY_BUFFER, t3), o3.bufferData(o3.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), o3.STATIC_DRAW), o3.vertexAttribPointer(0, 2, o3.FLOAT, false, 0, 0), o3.enableVertexAttribArray(0), (e4, t4 = false) => {
        o3 && (e4 ? (o3.viewport(0, 0, e4.width, e4.height), o3.bindFramebuffer(o3.FRAMEBUFFER, e4.fbo)) : (o3.viewport(0, 0, o3.drawingBufferWidth, o3.drawingBufferHeight), o3.bindFramebuffer(o3.FRAMEBUFFER, null)), t4 && (o3.clearColor(0, 0, 0, 1), o3.clear(o3.COLOR_BUFFER_BIT)), o3.drawElements(o3.TRIANGLES, 6, o3.UNSIGNED_SHORT, 0));
      };
    })();
    let F, k, D, N, B;
    const U = new M(P, S), O = new M(P, C), V = new M(P, E), X = new M(P, z), q = new M(P, _), Y = new M(P, T), $ = new M(P, A), W = new M(P, R2), H = new M(P, I), G = new class {
      constructor(e3, t3) {
        this.vertexShader = e3, this.fragmentShaderSource = t3, this.programs = {}, this.activeProgram = null, this.uniforms = {};
      }
      setKeywords(e3) {
        let t3 = 0;
        for (const n4 of e3) t3 += x2(n4);
        let n3 = this.programs[t3];
        if (null == n3) {
          const i3 = y(o3.FRAGMENT_SHADER, this.fragmentShaderSource, e3);
          n3 = w(this.vertexShader, i3), this.programs[t3] = n3;
        }
        n3 !== this.activeProgram && (n3 && (this.uniforms = b(n3)), this.activeProgram = n3);
      }
      bind() {
        this.activeProgram && o3.useProgram(this.activeProgram);
      }
    }(P, "\n      precision highp float;\n      precision highp sampler2D;\n      varying vec2 vUv;\n      varying vec2 vL;\n      varying vec2 vR;\n      varying vec2 vT;\n      varying vec2 vB;\n      uniform sampler2D uTexture;\n      uniform sampler2D uDithering;\n      uniform vec2 ditherScale;\n      uniform vec2 texelSize;\n\n      vec3 linearToGamma (vec3 color) {\n          color = max(color, vec3(0));\n          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n      }\n\n      void main () {\n          vec3 c = texture2D(uTexture, vUv).rgb;\n          #ifdef SHADING\n              vec3 lc = texture2D(uTexture, vL).rgb;\n              vec3 rc = texture2D(uTexture, vR).rgb;\n              vec3 tc = texture2D(uTexture, vT).rgb;\n              vec3 bc = texture2D(uTexture, vB).rgb;\n\n              float dx = length(rc) - length(lc);\n              float dy = length(tc) - length(bc);\n\n              vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n              vec3 l = vec3(0.0, 0.0, 1.0);\n\n              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n              c *= diffuse;\n          #endif\n\n          float a = max(c.r, max(c.g, c.b));\n          gl_FragColor = vec4(c, a);\n      }\n    ");
    function j(e3, t3, n3, i3, r3, a3) {
      o3.activeTexture(o3.TEXTURE0);
      const s3 = o3.createTexture();
      o3.bindTexture(o3.TEXTURE_2D, s3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, a3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, a3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texImage2D(o3.TEXTURE_2D, 0, n3, e3, t3, 0, i3, r3, null);
      const c3 = o3.createFramebuffer();
      o3.bindFramebuffer(o3.FRAMEBUFFER, c3), o3.framebufferTexture2D(o3.FRAMEBUFFER, o3.COLOR_ATTACHMENT0, o3.TEXTURE_2D, s3, 0), o3.viewport(0, 0, e3, t3), o3.clear(o3.COLOR_BUFFER_BIT);
      return { texture: s3, fbo: c3, width: e3, height: t3, texelSizeX: 1 / e3, texelSizeY: 1 / t3, attach: (e4) => (o3.activeTexture(o3.TEXTURE0 + e4), o3.bindTexture(o3.TEXTURE_2D, s3), e4) };
    }
    function Z(e3, t3, n3, i3, r3, o4) {
      const a3 = j(e3, t3, n3, i3, r3, o4), s3 = j(e3, t3, n3, i3, r3, o4);
      return { width: e3, height: t3, texelSizeX: a3.texelSizeX, texelSizeY: a3.texelSizeY, read: a3, write: s3, swap() {
        const e4 = this.read;
        this.read = this.write, this.write = e4;
      } };
    }
    function K(e3, t3, n3, i3, r3, a3, s3) {
      return e3.width === t3 && e3.height === n3 || (e3.read = function(e4, t4, n4, i4, r4, a4, s4) {
        const c3 = j(t4, n4, i4, r4, a4, s4);
        return U.bind(), U.uniforms.uTexture && o3.uniform1i(U.uniforms.uTexture, e4.attach(0)), L(c3, false), c3;
      }(e3.read, t3, n3, i3, r3, a3, s3), e3.write = j(t3, n3, i3, r3, a3, s3), e3.width = t3, e3.height = n3, e3.texelSizeX = 1 / t3, e3.texelSizeY = 1 / n3), e3;
    }
    function Q() {
      const e3 = J2(r2.SIM_RESOLUTION), t3 = J2(r2.DYE_RESOLUTION), n3 = f3.halfFloatTexType, i3 = f3.formatRGBA, a3 = f3.formatRG, s3 = f3.formatR, c3 = f3.supportLinearFiltering ? o3.LINEAR : o3.NEAREST;
      o3.disable(o3.BLEND), F = F ? K(F, t3.width, t3.height, i3.internalFormat, i3.format, n3, c3) : Z(t3.width, t3.height, i3.internalFormat, i3.format, n3, c3), k = k ? K(k, e3.width, e3.height, a3.internalFormat, a3.format, n3, c3) : Z(e3.width, e3.height, a3.internalFormat, a3.format, n3, c3), D = j(e3.width, e3.height, s3.internalFormat, s3.format, n3, o3.NEAREST), N = j(e3.width, e3.height, s3.internalFormat, s3.format, n3, o3.NEAREST), B = Z(e3.width, e3.height, s3.internalFormat, s3.format, n3, o3.NEAREST);
    }
    function J2(e3) {
      const t3 = o3.drawingBufferWidth, n3 = o3.drawingBufferHeight, i3 = t3 / n3;
      let r3 = i3 < 1 ? 1 / i3 : i3;
      const a3 = Math.round(e3), s3 = Math.round(e3 * r3);
      return t3 > n3 ? { width: s3, height: a3 } : { width: a3, height: s3 };
    }
    function ee2(e3) {
      const t3 = window.devicePixelRatio || 1;
      return Math.floor(e3 * t3);
    }
    !function() {
      const e3 = [];
      r2.SHADING && e3.push("SHADING"), G.setKeywords(e3);
    }(), Q();
    let te2 = Date.now(), ne2 = 0;
    function ie2() {
      const t3 = function() {
        const e3 = Date.now();
        let t4 = (e3 - te2) / 1e3;
        return t4 = Math.min(t4, 0.016666), te2 = e3, t4;
      }();
      var n3;
      (function() {
        const t4 = ee2(e2.clientWidth), n4 = ee2(e2.clientHeight);
        if (e2.width !== t4 || e2.height !== n4) return e2.width = t4, e2.height = n4, true;
        return false;
      })() && Q(), function(e3) {
        ne2 += e3 * r2.COLOR_UPDATE_SPEED, ne2 >= 1 && (ne2 = (ne2 - (t4 = 0)) % (1 - t4) + t4, i2.forEach((e4) => {
          e4.color = le2();
        }));
        var t4;
      }(t3), function() {
        for (const e3 of i2) e3.moved && (e3.moved = false, re2(e3));
      }(), function(e3) {
        o3.disable(o3.BLEND), Y.bind(), Y.uniforms.texelSize && o3.uniform2f(Y.uniforms.texelSize, k.texelSizeX, k.texelSizeY);
        Y.uniforms.uVelocity && o3.uniform1i(Y.uniforms.uVelocity, k.read.attach(0));
        L(N), $.bind(), $.uniforms.texelSize && o3.uniform2f($.uniforms.texelSize, k.texelSizeX, k.texelSizeY);
        $.uniforms.uVelocity && o3.uniform1i($.uniforms.uVelocity, k.read.attach(0));
        $.uniforms.uCurl && o3.uniform1i($.uniforms.uCurl, N.attach(1));
        $.uniforms.curl && o3.uniform1f($.uniforms.curl, r2.CURL);
        $.uniforms.dt && o3.uniform1f($.uniforms.dt, e3);
        L(k.write), k.swap(), q.bind(), q.uniforms.texelSize && o3.uniform2f(q.uniforms.texelSize, k.texelSizeX, k.texelSizeY);
        q.uniforms.uVelocity && o3.uniform1i(q.uniforms.uVelocity, k.read.attach(0));
        L(D), O.bind(), O.uniforms.uTexture && o3.uniform1i(O.uniforms.uTexture, B.read.attach(0));
        O.uniforms.value && o3.uniform1f(O.uniforms.value, r2.PRESSURE);
        L(B.write), B.swap(), W.bind(), W.uniforms.texelSize && o3.uniform2f(W.uniforms.texelSize, k.texelSizeX, k.texelSizeY);
        W.uniforms.uDivergence && o3.uniform1i(W.uniforms.uDivergence, D.attach(0));
        for (let e4 = 0; e4 < r2.PRESSURE_ITERATIONS; e4++) W.uniforms.uPressure && o3.uniform1i(W.uniforms.uPressure, B.read.attach(1)), L(B.write), B.swap();
        H.bind(), H.uniforms.texelSize && o3.uniform2f(H.uniforms.texelSize, k.texelSizeX, k.texelSizeY);
        H.uniforms.uPressure && o3.uniform1i(H.uniforms.uPressure, B.read.attach(0));
        H.uniforms.uVelocity && o3.uniform1i(H.uniforms.uVelocity, k.read.attach(1));
        L(k.write), k.swap(), X.bind(), X.uniforms.texelSize && o3.uniform2f(X.uniforms.texelSize, k.texelSizeX, k.texelSizeY);
        !f3.supportLinearFiltering && X.uniforms.dyeTexelSize && o3.uniform2f(X.uniforms.dyeTexelSize, k.texelSizeX, k.texelSizeY);
        const t4 = k.read.attach(0);
        X.uniforms.uVelocity && o3.uniform1i(X.uniforms.uVelocity, t4);
        X.uniforms.uSource && o3.uniform1i(X.uniforms.uSource, t4);
        X.uniforms.dt && o3.uniform1f(X.uniforms.dt, e3);
        X.uniforms.dissipation && o3.uniform1f(X.uniforms.dissipation, r2.VELOCITY_DISSIPATION);
        L(k.write), k.swap(), !f3.supportLinearFiltering && X.uniforms.dyeTexelSize && o3.uniform2f(X.uniforms.dyeTexelSize, F.texelSizeX, F.texelSizeY);
        X.uniforms.uVelocity && o3.uniform1i(X.uniforms.uVelocity, k.read.attach(0));
        X.uniforms.uSource && o3.uniform1i(X.uniforms.uSource, F.read.attach(1));
        X.uniforms.dissipation && o3.uniform1f(X.uniforms.dissipation, r2.DENSITY_DISSIPATION);
        L(F.write), F.swap();
      }(t3), n3 = null, o3.blendFunc(o3.ONE, o3.ONE_MINUS_SRC_ALPHA), o3.enable(o3.BLEND), function(e3) {
        const t4 = o3.drawingBufferWidth, n4 = o3.drawingBufferHeight;
        G.bind(), r2.SHADING && G.uniforms.texelSize && o3.uniform2f(G.uniforms.texelSize, 1 / t4, 1 / n4), G.uniforms.uTexture && o3.uniform1i(G.uniforms.uTexture, F.read.attach(0)), L(e3, false);
      }(n3), requestAnimationFrame(ie2);
    }
    function re2(e3) {
      const t3 = e3.deltaX * r2.SPLAT_FORCE, n3 = e3.deltaY * r2.SPLAT_FORCE;
      oe2(e3.texcoordX, e3.texcoordY, t3, n3, e3.color);
    }
    function oe2(t3, n3, i3, a3, s3) {
      V.bind(), V.uniforms.uTarget && o3.uniform1i(V.uniforms.uTarget, k.read.attach(0)), V.uniforms.aspectRatio && o3.uniform1f(V.uniforms.aspectRatio, e2.width / e2.height), V.uniforms.point && o3.uniform2f(V.uniforms.point, t3, n3), V.uniforms.color && o3.uniform3f(V.uniforms.color, i3, a3, 0), V.uniforms.radius && o3.uniform1f(V.uniforms.radius, function(t4) {
        const n4 = e2.width / e2.height;
        n4 > 1 && (t4 *= n4);
        return t4;
      }(r2.SPLAT_RADIUS / 100)), L(k.write), k.swap(), V.uniforms.uTarget && o3.uniform1i(V.uniforms.uTarget, F.read.attach(0)), V.uniforms.color && o3.uniform3f(V.uniforms.color, s3.r, s3.g, s3.b), L(F.write), F.swap();
    }
    function ae2(t3, n3, i3, r3) {
      t3.id = n3, t3.down = true, t3.moved = false, t3.texcoordX = i3 / e2.width, t3.texcoordY = 1 - r3 / e2.height, t3.prevTexcoordX = t3.texcoordX, t3.prevTexcoordY = t3.texcoordY, t3.deltaX = 0, t3.deltaY = 0, t3.color = le2();
    }
    function se2(t3, n3, i3, r3) {
      t3.prevTexcoordX = t3.texcoordX, t3.prevTexcoordY = t3.texcoordY, t3.texcoordX = n3 / e2.width, t3.texcoordY = 1 - i3 / e2.height, t3.deltaX = function(t4) {
        const n4 = e2.width / e2.height;
        n4 < 1 && (t4 *= n4);
        return t4;
      }(t3.texcoordX - t3.prevTexcoordX), t3.deltaY = function(t4) {
        const n4 = e2.width / e2.height;
        n4 > 1 && (t4 /= n4);
        return t4;
      }(t3.texcoordY - t3.prevTexcoordY), t3.moved = Math.abs(t3.deltaX) > 0 || Math.abs(t3.deltaY) > 0, t3.color = r3;
    }
    function ce2(e3) {
      e3.down = false;
    }
    function le2() {
      const e3 = function(e4, t3, n3) {
        let i3 = 0, r3 = 0, o4 = 0;
        const a3 = Math.floor(6 * e4), s3 = 6 * e4 - a3, c3 = n3 * (1 - t3), l3 = n3 * (1 - s3 * t3), u3 = n3 * (1 - (1 - s3) * t3);
        switch (a3 % 6) {
          case 0:
            i3 = n3, r3 = u3, o4 = c3;
            break;
          case 1:
            i3 = l3, r3 = n3, o4 = c3;
            break;
          case 2:
            i3 = c3, r3 = n3, o4 = u3;
            break;
          case 3:
            i3 = c3, r3 = l3, o4 = n3;
            break;
          case 4:
            i3 = u3, r3 = c3, o4 = n3;
            break;
          case 5:
            i3 = n3, r3 = c3, o4 = l3;
        }
        return { r: i3, g: r3, b: o4 };
      }(Math.random(), 1, 1);
      return e3.r *= 0.15, e3.g *= 0.15, e3.b *= 0.15, e3;
    }
    window.addEventListener("mousedown", (e3) => {
      const t3 = i2[0];
      ae2(t3, -1, ee2(e3.clientX), ee2(e3.clientY)), function(e4) {
        const t4 = le2();
        t4.r *= 10, t4.g *= 10, t4.b *= 10;
        const n3 = 10 * (Math.random() - 0.5), i3 = 30 * (Math.random() - 0.5);
        oe2(e4.texcoordX, e4.texcoordY, n3, i3, t4);
      }(t3);
    }), document.body.addEventListener("mousemove", function e3(t3) {
      const n3 = i2[0], r3 = ee2(t3.clientX), o4 = ee2(t3.clientY), a3 = le2();
      ie2(), se2(n3, r3, o4, a3), document.body.removeEventListener("mousemove", e3);
    }), window.addEventListener("mousemove", (e3) => {
      const t3 = i2[0];
      se2(t3, ee2(e3.clientX), ee2(e3.clientY), t3.color);
    }), document.body.addEventListener("touchstart", function e3(t3) {
      const n3 = t3.targetTouches, r3 = i2[0];
      for (let e4 = 0; e4 < n3.length; e4++) {
        const t4 = ee2(n3[e4].clientX), i3 = ee2(n3[e4].clientY);
        ie2(), ae2(r3, n3[e4].identifier, t4, i3);
      }
      document.body.removeEventListener("touchstart", e3);
    }), window.addEventListener("touchstart", (e3) => {
      const t3 = e3.targetTouches, n3 = i2[0];
      for (let e4 = 0; e4 < t3.length; e4++) {
        const i3 = ee2(t3[e4].clientX), r3 = ee2(t3[e4].clientY);
        ae2(n3, t3[e4].identifier, i3, r3);
      }
    }, false), window.addEventListener("touchmove", (e3) => {
      const t3 = e3.targetTouches, n3 = i2[0];
      for (let e4 = 0; e4 < t3.length; e4++) {
        se2(n3, ee2(t3[e4].clientX), ee2(t3[e4].clientY), n3.color);
      }
    }, false), window.addEventListener("touchend", (e3) => {
      const t3 = e3.changedTouches, n3 = i2[0];
      for (let e4 = 0; e4 < t3.length; e4++) ce2(n3);
    });
  }, [t2, n2, o2, a2, s2, c2, l2, u2, h2, d2, m2, p2, f2, v2]), (0, import_jsx_runtime.jsx)("div", { style: { position: "fixed", top: 0, left: 0, zIndex: 50, pointerEvents: "none", width: "100%", height: "100%" }, children: (0, import_jsx_runtime.jsx)("canvas", { ref: g2, id: "fluid", style: { width: "100vw", height: "100vh", display: "block" } }) });
}
function Qt(e2) {
  const t2 = e2.replace("#", "");
  return [parseInt(t2.substring(0, 2), 16) / 255, parseInt(t2.substring(2, 4), 16) / 255, parseInt(t2.substring(4, 6), 16) / 255];
}
function Jt(e2) {
  return e2 - Math.floor(e2);
}
function en(e2) {
  let t2 = [0.1031 * e2, 0.103 * e2, 0.0973 * e2].map(Jt);
  const n2 = [t2[1], t2[2], t2[0]], i2 = t2[0] * (n2[0] + 33.33) + t2[1] * (n2[1] + 33.33) + t2[2] * (n2[2] + 33.33);
  for (let e3 = 0; e3 < 3; e3++) t2[e3] = Jt(t2[e3] + i2);
  return t2;
}
function tn(e2) {
  let t2 = [0.1031 * e2[0], 0.103 * e2[1], 0.0973 * e2[2]].map(Jt);
  const n2 = [t2[1], t2[0], t2[2]], i2 = t2[0] * (n2[0] + 33.33) + t2[1] * (n2[1] + 33.33) + t2[2] * (n2[2] + 33.33);
  for (let e3 = 0; e3 < 3; e3++) t2[e3] = Jt(t2[e3] + i2);
  const r2 = [t2[0], t2[0], t2[1]], o2 = [t2[1], t2[0], t2[0]], a2 = [t2[2], t2[1], t2[0]], s2 = [];
  for (let e3 = 0; e3 < 3; e3++) s2[e3] = Jt((r2[e3] + o2[e3]) * a2[e3]);
  return s2;
}
var nn = ({ color: o2 = "#ffffff", speed: a2 = 0.3, enableMouseInteraction: s2 = true, hoverSmoothness: c2 = 0.05, animationSize: l2 = 30, ballCount: u2 = 15, clumpFactor: h2 = 1, cursorBallSize: d2 = 3, cursorBallColor: m2 = "#ffffff", enableTransparency: p2 = false }) => {
  const f2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = f2.current;
    if (!e2) return;
    const t2 = new Renderer({ dpr: 1, alpha: true, premultipliedAlpha: false }), n2 = t2.gl;
    n2.clearColor(0, 0, 0, p2 ? 0 : 1), e2.appendChild(n2.canvas);
    const i2 = new Camera(n2, { left: -1, right: 1, top: 1, bottom: -1, near: 0.1, far: 10 });
    i2.position.z = 1;
    const r2 = new Triangle(n2), [v2, g2, x2] = Qt(o2), [y, w, b] = Qt(m2), M = [];
    for (let e3 = 0; e3 < 50; e3++) M.push(new Vec3(0, 0, 0));
    const P = new Program(n2, { vertex: "#version 300 es\nprecision highp float;\nlayout(location = 0) in vec2 position;\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n", fragment: "#version 300 es\nprecision highp float;\nuniform vec3 iResolution;\nuniform float iTime;\nuniform vec3 iMouse;\nuniform vec3 iColor;\nuniform vec3 iCursorColor;\nuniform float iAnimationSize;\nuniform int iBallCount;\nuniform float iCursorBallSize;\nuniform vec3 iMetaBalls[50];\nuniform float iClumpFactor;\nuniform bool enableTransparency;\nout vec4 outColor;\nconst float PI = 3.14159265359;\n \nfloat getMetaBallValue(vec2 c, float r, vec2 p) {\n    vec2 d = p - c;\n    float dist2 = dot(d, d);\n    return (r * r) / dist2;\n}\n \nvoid main() {\n    vec2 fc = gl_FragCoord.xy;\n    float scale = iAnimationSize / iResolution.y;\n    vec2 coord = (fc - iResolution.xy * 0.5) * scale;\n    vec2 mouseW = (iMouse.xy - iResolution.xy * 0.5) * scale;\n    float m1 = 0.0;\n    for (int i = 0; i < 50; i++) {\n        if (i >= iBallCount) break;\n        m1 += getMetaBallValue(iMetaBalls[i].xy, iMetaBalls[i].z, coord);\n    }\n    float m2 = getMetaBallValue(mouseW, iCursorBallSize, coord);\n    float total = m1 + m2;\n    float f = smoothstep(-1.0, 1.0, (total - 1.3) / min(1.0, fwidth(total)));\n    vec3 cFinal = vec3(0.0);\n    if (total > 0.0) {\n        float alpha1 = m1 / total;\n        float alpha2 = m2 / total;\n        cFinal = iColor * alpha1 + iCursorColor * alpha2;\n    }\n    outColor = vec4(cFinal * f, enableTransparency ? f : 1.0);\n}\n", uniforms: { iTime: { value: 0 }, iResolution: { value: new Vec3(0, 0, 0) }, iMouse: { value: new Vec3(0, 0, 0) }, iColor: { value: new Vec3(v2, g2, x2) }, iCursorColor: { value: new Vec3(y, w, b) }, iAnimationSize: { value: l2 }, iBallCount: { value: u2 }, iCursorBallSize: { value: d2 }, iMetaBalls: { value: M }, iClumpFactor: { value: h2 }, enableTransparency: { value: p2 } } }), S = new Mesh(n2, { geometry: r2, program: P }), C = new Transform();
    S.setParent(C);
    const E = Math.min(u2, 50), z = [];
    for (let e3 = 0; e3 < E; e3++) {
      const t3 = en(e3 + 1), n3 = t3[0] * (2 * Math.PI), i3 = 0.1 * Math.PI + t3[1] * (0.4 * Math.PI - 0.1 * Math.PI), r3 = 5 + 5 * t3[1], o3 = tn(t3), a3 = Math.floor(2 * o3[0]), s3 = 0.5 + 1.5 * o3[2];
      z.push({ st: n3, dtFactor: i3, baseScale: r3, toggle: a3, radius: s3 });
    }
    const _ = { x: 0, y: 0 };
    let T = false, A = 0, R2 = 0;
    function I() {
      if (!e2) return;
      const i3 = e2.clientWidth, r3 = e2.clientHeight;
      t2.setSize(1 * i3, 1 * r3), n2.canvas.style.width = `${i3}px`, n2.canvas.style.height = `${r3}px`, P.uniforms.iResolution.value.set(n2.canvas.width, n2.canvas.height, 0);
    }
    function L(t3) {
      if (!s2 || !e2) return;
      const i3 = e2.getBoundingClientRect(), r3 = t3.clientX - i3.left, o3 = t3.clientY - i3.top;
      A = r3 / i3.width * n2.canvas.width, R2 = (1 - o3 / i3.height) * n2.canvas.height;
    }
    function F() {
      s2 && (T = true);
    }
    function k() {
      s2 && (T = false);
    }
    window.addEventListener("resize", I), I(), e2.addEventListener("pointermove", L), e2.addEventListener("pointerenter", F), e2.addEventListener("pointerleave", k);
    const D = performance.now();
    let N;
    return N = requestAnimationFrame(function e3(r3) {
      N = requestAnimationFrame(e3);
      const o3 = 1e-3 * (r3 - D);
      P.uniforms.iTime.value = o3;
      for (let e4 = 0; e4 < E; e4++) {
        const t3 = z[e4], n3 = o3 * a2 * t3.dtFactor, i3 = t3.st + n3, r4 = Math.cos(i3), s4 = Math.sin(i3 + n3 * t3.toggle), c3 = r4 * t3.baseScale * h2, l4 = s4 * t3.baseScale * h2;
        M[e4].set(c3, l4, t3.radius);
      }
      let s3, l3;
      if (T) s3 = A, l3 = R2;
      else {
        const e4 = 0.5 * n2.canvas.width, t3 = 0.5 * n2.canvas.height, i3 = 0.15 * n2.canvas.width, r4 = 0.15 * n2.canvas.height;
        s3 = e4 + Math.cos(o3 * a2) * i3, l3 = t3 + Math.sin(o3 * a2) * r4;
      }
      _.x += (s3 - _.x) * c2, _.y += (l3 - _.y) * c2, P.uniforms.iMouse.value.set(_.x, _.y, 0), t2.render({ scene: C, camera: i2 });
    }), () => {
      var _a;
      cancelAnimationFrame(N), window.removeEventListener("resize", I), e2.removeEventListener("pointermove", L), e2.removeEventListener("pointerenter", F), e2.removeEventListener("pointerleave", k), e2.removeChild(n2.canvas), (_a = n2.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
    };
  }, [o2, m2, a2, s2, c2, l2, u2, h2, d2, p2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: "\n    .metaballs-container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n    " }), (0, import_jsx_runtime.jsx)("div", { ref: f2, className: "metaballs-container" })] });
};
function rn({ blobType: o2 = "circle", fillColor: a2 = "#5227FF", trailCount: s2 = 3, sizes: c2 = [60, 125, 75], innerSizes: u2 = [20, 35, 25], innerColor: h2 = "rgba(255,255,255,0.8)", opacities: d2 = [0.6, 0.6, 0.6], shadowColor: m2 = "rgba(0,0,0,0.75)", shadowBlur: p2 = 5, shadowOffsetX: v2 = 10, shadowOffsetY: g2 = 10, filterId: x2 = "blob", filterStdDeviation: y = 30, filterColorMatrixValues: w = "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 35 -10", useFilter: b = true, fastDuration: M = 0.1, slowDuration: P = 0.5, fastEase: S = "power3.out", slowEase: C = "power1.out", zIndex: E = 100 }) {
  const z = (0, import_react3.useRef)(null), _ = (0, import_react3.useRef)([]), T = (0, import_react3.useCallback)(() => {
    if (!z.current) return { left: 0, top: 0 };
    const e2 = z.current.getBoundingClientRect();
    return { left: e2.left, top: e2.top };
  }, []), A = (0, import_react3.useCallback)((e2) => {
    const { left: t2, top: n2 } = T(), i2 = "clientX" in e2 ? e2.clientX : e2.touches[0].clientX, r2 = "clientY" in e2 ? e2.clientY : e2.touches[0].clientY;
    _.current.forEach((e3, o3) => {
      if (!e3) return;
      const a3 = 0 === o3;
      import_gsap.default.to(e3, { x: i2 - t2, y: r2 - n2, duration: a3 ? M : P, ease: a3 ? S : C });
    });
  }, [T, M, P, S, C]);
  return (0, import_react3.useEffect)(() => {
    const e2 = () => T();
    return window.addEventListener("resize", e2), () => window.removeEventListener("resize", e2);
  }, [T]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".blob-container {\n  position: relative;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.blob-main {\n  pointer-events: none;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  background: transparent;\n  user-select: none;\n  cursor: default;\n}\n\n.blob {\n  position: absolute;\n  will-change: transform;\n  transform: translate(-50%, -50%);\n}\n\n.inner-dot {\n  position: absolute;\n}" }), (0, import_jsx_runtime.jsxs)("div", { ref: z, className: "blob-container", style: { zIndex: E }, onMouseMove: A, onTouchMove: A, children: [b && (0, import_jsx_runtime.jsx)("svg", { style: { position: "absolute", width: 0, height: 0 }, children: (0, import_jsx_runtime.jsxs)("filter", { id: x2, children: [(0, import_jsx_runtime.jsx)("feGaussianBlur", { in: "SourceGraphic", result: "blur", stdDeviation: y }), (0, import_jsx_runtime.jsx)("feColorMatrix", { in: "blur", values: w })] }) }), (0, import_jsx_runtime.jsx)("div", { className: "blob-main", style: { filter: b ? `url(#${x2})` : void 0 }, children: Array.from({ length: s2 }).map((t2, n2) => (0, import_jsx_runtime.jsx)("div", { ref: (e2) => {
    _.current[n2] = e2;
  }, className: "blob", style: { width: c2[n2], height: c2[n2], borderRadius: "circle" === o2 ? "50%" : "0%", backgroundColor: a2, opacity: d2[n2], boxShadow: `${v2}px ${g2}px ${p2}px 0 ${m2}` }, children: (0, import_jsx_runtime.jsx)("div", { className: "inner-dot", style: { width: u2[n2], height: u2[n2], top: (c2[n2] - u2[n2]) / 2, left: (c2[n2] - u2[n2]) / 2, backgroundColor: h2, borderRadius: "circle" === o2 ? "50%" : "0%" } }) }, n2)) })] })] });
}
var on = ({ children: t2, delay: n2 = 0, index: r2, onMouseEnter: o2, onClick: a2 }) => {
  const s2 = (0, import_react3.useRef)(null), c2 = useInView(s2, { amount: 0.5, once: false });
  return (0, import_jsx_runtime.jsx)(motion.div, { ref: s2, "data-index": r2, onMouseEnter: o2, onClick: a2, initial: { scale: 0.7, opacity: 0 }, animate: c2 ? { scale: 1, opacity: 1 } : { scale: 0.7, opacity: 0 }, transition: { duration: 0.2, delay: n2 }, style: { marginBottom: "1rem", cursor: "pointer" }, children: t2 });
};
var an = ({ items: a2 = ["Item 1", "Item 2", "Item 3", "Item 4", "Item 5", "Item 6", "Item 7", "Item 8", "Item 9", "Item 10", "Item 11", "Item 12", "Item 13", "Item 14", "Item 15"], onItemSelect: s2, showGradients: c2 = true, enableArrowNavigation: l2 = true, className: u2 = "", itemClassName: h2 = "", displayScrollbar: d2 = true, initialSelectedIndex: m2 = -1 }) => {
  const p2 = (0, import_react3.useRef)(null), [f2, v2] = (0, import_react3.useState)(m2), [g2, x2] = (0, import_react3.useState)(false), [y, w] = (0, import_react3.useState)(0), [b, M] = (0, import_react3.useState)(1);
  return (0, import_react3.useEffect)(() => {
    if (!l2) return;
    const e2 = (e3) => {
      "ArrowDown" === e3.key || "Tab" === e3.key && !e3.shiftKey ? (e3.preventDefault(), x2(true), v2((e4) => Math.min(e4 + 1, a2.length - 1))) : "ArrowUp" === e3.key || "Tab" === e3.key && e3.shiftKey ? (e3.preventDefault(), x2(true), v2((e4) => Math.max(e4 - 1, 0))) : "Enter" === e3.key && f2 >= 0 && f2 < a2.length && (e3.preventDefault(), s2 && s2(a2[f2], f2));
    };
    return window.addEventListener("keydown", e2), () => window.removeEventListener("keydown", e2);
  }, [a2, f2, s2, l2]), (0, import_react3.useEffect)(() => {
    if (!g2 || f2 < 0 || !p2.current) return;
    const e2 = p2.current, t2 = e2.querySelector(`[data-index="${f2}"]`);
    if (t2) {
      const n2 = 50, i2 = e2.scrollTop, r2 = e2.clientHeight, o2 = t2.offsetTop, a3 = o2 + t2.offsetHeight;
      o2 < i2 + n2 ? e2.scrollTo({ top: o2 - n2, behavior: "smooth" }) : a3 > i2 + r2 - n2 && e2.scrollTo({ top: a3 - r2 + n2, behavior: "smooth" });
    }
    x2(false);
  }, [f2, g2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".scroll-list-container {\n  position: relative;\n  width: 500px;\n}\n\n.scroll-list {\n  max-height: 400px;\n  overflow-y: auto;\n  padding: 16px;\n}\n\n.scroll-list::-webkit-scrollbar {\n  width: 8px;\n}\n\n.scroll-list::-webkit-scrollbar-track {\n  background: #060010;\n}\n\n.scroll-list::-webkit-scrollbar-thumb {\n  background: #271E37;\n  border-radius: 4px;\n}\n\n.no-scrollbar::-webkit-scrollbar {\n  display: none;\n}\n\n.no-scrollbar {\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n\n.item {\n  padding: 16px;\n  background-color: #170D27;\n  border-radius: 8px;\n  margin-bottom: 1rem;\n}\n\n.item.selected {\n  background-color: #271E37;\n}\n\n.item-text {\n  color: white;\n  margin: 0;\n}\n\n.top-gradient {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 50px;\n  background: linear-gradient(to bottom, #060010, transparent);\n  pointer-events: none;\n  transition: opacity 0.3s ease;\n}\n\n.bottom-gradient {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  height: 100px;\n  background: linear-gradient(to top, #060010, transparent);\n  pointer-events: none;\n  transition: opacity 0.3s ease;\n}" }), (0, import_jsx_runtime.jsxs)("div", { className: `scroll-list-container ${u2}`, children: [(0, import_jsx_runtime.jsx)("div", { ref: p2, className: "scroll-list " + (d2 ? "" : "no-scrollbar"), onScroll: (e2) => {
    const t2 = e2.target, { scrollTop: n2, scrollHeight: i2, clientHeight: r2 } = t2;
    w(Math.min(n2 / 50, 1));
    const o2 = i2 - (n2 + r2);
    M(i2 <= r2 ? 0 : Math.min(o2 / 50, 1));
  }, children: a2.map((t2, n2) => (0, import_jsx_runtime.jsx)(on, { delay: 0.1, index: n2, onMouseEnter: () => v2(n2), onClick: () => {
    v2(n2), s2 && s2(t2, n2);
  }, children: (0, import_jsx_runtime.jsx)("div", { className: `item ${f2 === n2 ? "selected" : ""} ${h2}`, children: (0, import_jsx_runtime.jsx)("p", { className: "item-text", children: t2 }) }) }, n2)) }), c2 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { className: "top-gradient", style: { opacity: y } }), (0, import_jsx_runtime.jsx)("div", { className: "bottom-gradient", style: { opacity: b } })] })] })] });
};
function sn({ children: t2, onSendToBack: n2, sensitivity: i2 }) {
  const r2 = useMotionValue(0), o2 = useMotionValue(0), a2 = useTransform(o2, [-100, 100], [60, -60]), s2 = useTransform(r2, [-100, 100], [-60, 60]);
  return (0, import_jsx_runtime.jsx)(motion.div, { className: "card-rotate", style: { x: r2, y: o2, rotateX: a2, rotateY: s2 }, drag: true, dragConstraints: { top: 0, right: 0, bottom: 0, left: 0 }, dragElastic: 0.6, whileTap: { cursor: "grabbing" }, onDragEnd: function(e2, t3) {
    Math.abs(t3.offset.x) > i2 || Math.abs(t3.offset.y) > i2 ? n2() : (r2.set(0), o2.set(0));
  }, children: t2 });
}
function cn({ randomRotation: i2 = false, sensitivity: r2 = 200, cardDimensions: a2 = { width: 208, height: 208 }, cardsData: s2 = [], animationConfig: c2 = { stiffness: 260, damping: 20 }, sendToBackOnClick: l2 = false }) {
  const [u2, h2] = (0, import_react3.useState)(s2.length ? s2 : [{ id: 1, img: "https://images.unsplash.com/photo-1480074568708-e7b720bb3f09?q=80&w=500&auto=format" }, { id: 2, img: "https://images.unsplash.com/photo-1449844908441-8829872d2607?q=80&w=500&auto=format" }, { id: 3, img: "https://images.unsplash.com/photo-1452626212852-811d58933cae?q=80&w=500&auto=format" }, { id: 4, img: "https://images.unsplash.com/photo-1572120360610-d971b9d7767c?q=80&w=500&auto=format" }]), d2 = (e2) => {
    h2((t2) => {
      const n2 = [...t2], i3 = n2.findIndex((t3) => t3.id === e2), [r3] = n2.splice(i3, 1);
      return n2.unshift(r3), n2;
    });
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".stack-container {\n  position: relative;\n  perspective: 600px;\n}\n\n.card-rotate {\n  position: absolute;\n  cursor: grab;\n}\n\n.card {\n  border-radius: 20px;\n  border: 5px solid #fff;\n  overflow: hidden;\n}\n\n.card-image {\n  pointer-events: none;\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}" }), (0, import_jsx_runtime.jsx)("div", { className: "stack-container", style: { width: a2.width, height: a2.height, perspective: 600 }, children: u2.map((t2, n2) => {
    const o2 = i2 ? 10 * Math.random() - 5 : 0;
    return (0, import_jsx_runtime.jsx)(sn, { onSendToBack: () => d2(t2.id), sensitivity: r2, children: (0, import_jsx_runtime.jsx)(motion.div, { className: "card", onClick: () => l2 && d2(t2.id), animate: { rotateZ: 4 * (u2.length - n2 - 1) + o2, scale: 1 + 0.06 * n2 - 0.06 * u2.length, transformOrigin: "90% 90%" }, initial: false, transition: { type: "spring", stiffness: c2.stiffness, damping: c2.damping }, style: { width: a2.width, height: a2.height }, children: (0, import_jsx_runtime.jsx)("img", { src: t2.img, alt: `card-${t2.id}`, className: "card-image" }) }) }, t2.id);
  }) })] });
}
var ln = { damping: 30, stiffness: 100, mass: 2 };
function un({ imageSrc: r2, altText: a2 = "Tilted card image", captionText: s2 = "", containerHeight: c2 = "300px", containerWidth: l2 = "100%", imageHeight: u2 = "300px", imageWidth: h2 = "300px", scaleOnHover: d2 = 1.1, rotateAmplitude: m2 = 14, showMobileWarning: p2 = true, showTooltip: f2 = true, overlayContent: v2 = null, displayOverlayContent: g2 = false }) {
  const x2 = (0, import_react3.useRef)(null), w = useMotionValue(0), M = useMotionValue(0), P = useSpring(useMotionValue(0), ln), S = useSpring(useMotionValue(0), ln), E = useSpring(1, ln), z = useSpring(0), _ = useSpring(0, { stiffness: 350, damping: 30, mass: 1 }), [T, A] = (0, import_react3.useState)(0);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".tilted-card-figure {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  perspective: 800px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n.tilted-card-mobile-alert {\n  position: absolute;\n  top: 1rem;\n  text-align: center;\n  font-size: 0.875rem;\n  display: none;\n}\n\n@media (max-width: 640px) {\n  .tilted-card-mobile-alert {\n    display: block;\n  }\n  .tilted-card-caption {\n    display: none;\n  }\n}\n\n.tilted-card-inner {\n  position: relative;\n  transform-style: preserve-3d;\n}\n\n.tilted-card-img {\n  position: absolute;\n  top: 0;\n  left: 0;\n  object-fit: cover;\n  border-radius: 15px;\n  will-change: transform;\n  transform: translateZ(0);\n}\n\n.tilted-card-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 2;\n  will-change: transform;\n  transform: translateZ(30px);\n}\n\n.tilted-card-caption {\n  pointer-events: none;\n  position: absolute;\n  left: 0;\n  top: 0;\n  border-radius: 4px;\n  background-color: #fff;\n  padding: 4px 10px;\n  font-size: 10px;\n  color: #2d2d2d;\n  opacity: 0;\n  z-index: 3;\n}\n" }), (0, import_jsx_runtime.jsxs)("figure", { ref: x2, className: "tilted-card-figure", style: { height: c2, width: l2 }, onMouseMove: function(e2) {
    if (!x2.current) return;
    const t2 = x2.current.getBoundingClientRect(), n2 = e2.clientX - t2.left - t2.width / 2, i2 = e2.clientY - t2.top - t2.height / 2, r3 = i2 / (t2.height / 2) * -m2, o2 = n2 / (t2.width / 2) * m2;
    P.set(r3), S.set(o2), w.set(e2.clientX - t2.left), M.set(e2.clientY - t2.top);
    const a3 = i2 - T;
    _.set(0.6 * -a3), A(i2);
  }, onMouseEnter: function() {
    E.set(d2), z.set(1);
  }, onMouseLeave: function() {
    z.set(0), E.set(1), P.set(0), S.set(0), _.set(0);
  }, children: [p2 && (0, import_jsx_runtime.jsx)("div", { className: "tilted-card-mobile-alert", children: "This effect is not optimized for mobile. Check on desktop." }), (0, import_jsx_runtime.jsxs)(motion.div, { className: "tilted-card-inner", style: { width: h2, height: u2, rotateX: P, rotateY: S, scale: E }, children: [(0, import_jsx_runtime.jsx)(motion.img, { src: r2, alt: a2, className: "tilted-card-img", style: { width: h2, height: u2 } }), g2 && v2 && (0, import_jsx_runtime.jsx)(motion.div, { className: "tilted-card-overlay", children: v2 })] }), f2 && (0, import_jsx_runtime.jsx)(motion.figcaption, { className: "tilted-card-caption", style: { x: w, y: M, opacity: z, rotate: _ }, children: s2 })] })] });
}
var hn = ({ items: o2, className: a2 = "", radius: s2 = 300, columns: c2 = 3, rows: l2 = 2, damping: u2 = 0.45, fadeOut: h2 = 0.6, ease: d2 = "power3.out" }) => {
  const m2 = (0, import_react3.useRef)(null), p2 = (0, import_react3.useRef)(null), f2 = (0, import_react3.useRef)(null), g2 = (0, import_react3.useRef)(null), x2 = (0, import_react3.useRef)({ x: 0, y: 0 }), y = (o2 == null ? void 0 : o2.length) ? o2 : [{ image: "https://i.pravatar.cc/300?img=8", title: "Alex Rivera", subtitle: "Full Stack Developer", handle: "@alexrivera", borderColor: "#4F46E5", gradient: "linear-gradient(145deg, #4F46E5, #000)", url: "https://github.com/" }, { image: "https://i.pravatar.cc/300?img=11", title: "Jordan Chen", subtitle: "DevOps Engineer", handle: "@jordanchen", borderColor: "#10B981", gradient: "linear-gradient(210deg, #10B981, #000)", url: "https://linkedin.com/in/" }, { image: "https://i.pravatar.cc/300?img=3", title: "Morgan Blake", subtitle: "UI/UX Designer", handle: "@morganblake", borderColor: "#F59E0B", gradient: "linear-gradient(165deg, #F59E0B, #000)", url: "https://dribbble.com/" }, { image: "https://i.pravatar.cc/300?img=16", title: "Casey Park", subtitle: "Data Scientist", handle: "@caseypark", borderColor: "#EF4444", gradient: "linear-gradient(195deg, #EF4444, #000)", url: "https://kaggle.com/" }, { image: "https://i.pravatar.cc/300?img=25", title: "Sam Kim", subtitle: "Mobile Developer", handle: "@thesamkim", borderColor: "#8B5CF6", gradient: "linear-gradient(225deg, #8B5CF6, #000)", url: "https://github.com/" }, { image: "https://i.pravatar.cc/300?img=60", title: "Tyler Rodriguez", subtitle: "Cloud Architect", handle: "@tylerrod", borderColor: "#06B6D4", gradient: "linear-gradient(135deg, #06B6D4, #000)", url: "https://aws.amazon.com/" }];
  (0, import_react3.useEffect)(() => {
    const e2 = m2.current;
    if (!e2) return;
    f2.current = (void 0).quickSetter(e2, "--x", "px"), g2.current = (void 0).quickSetter(e2, "--y", "px");
    const { width: t2, height: n2 } = e2.getBoundingClientRect();
    x2.current = { x: t2 / 2, y: n2 / 2 }, f2.current(x2.current.x), g2.current(x2.current.y);
  }, []);
  const w = (e2) => {
    const t2 = e2.currentTarget, n2 = t2.getBoundingClientRect(), i2 = e2.clientX - n2.left, r2 = e2.clientY - n2.top;
    t2.style.setProperty("--mouse-x", `${i2}px`), t2.style.setProperty("--mouse-y", `${r2}px`);
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: '.chroma-grid {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  display: grid;\n  grid-template-columns: repeat(var(--cols, 3), 320px);\n  grid-auto-rows: auto;\n  justify-content: center;\n  gap: 0.75rem;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 1rem;\n  box-sizing: border-box;\n\n  --x: 50%;\n  --y: 50%;\n  --r: 220px;\n}\n\n@media (max-width: 1124px) {\n  .chroma-grid {\n    grid-template-columns: repeat(auto-fit, minmax(320px, 320px));\n    gap: 0.5rem;\n    padding: 0.5rem;\n  }\n}\n\n@media (max-width: 480px) {\n  .chroma-grid {\n    grid-template-columns: 320px;\n    gap: 0.75rem;\n    padding: 1rem;\n  }\n}\n\n.chroma-card {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  width: 320px;\n  height: auto;\n  border-radius: 20px;\n  overflow: hidden;\n  border: 1px solid #333;\n  transition: border-color 0.3s ease;\n  background: var(--card-gradient);\n\n  --mouse-x: 50%;\n  --mouse-y: 50%;\n  --spotlight-color: rgba(255, 255, 255, 0.3);\n}\n\n.chroma-card:hover {\n  border-color: var(--card-border);\n}\n\n.chroma-card::before {\n  content: "";\n  position: absolute;\n  inset: 0;\n  background: radial-gradient(circle at var(--mouse-x) var(--mouse-y),\n      var(--spotlight-color),\n      transparent 70%);\n  pointer-events: none;\n  opacity: 0;\n  transition: opacity 0.5s ease;\n  z-index: 2;\n}\n\n.chroma-card:hover::before {\n  opacity: 1;\n}\n\n.chroma-img-wrapper {\n  position: relative;\n  z-index: 1;\n  flex: 1;\n  padding: 10px;\n  box-sizing: border-box;\n  background: transparent;\n  transition: background 0.3s ease;\n}\n\n.chroma-img-wrapper img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  border-radius: 10px;\n  display: block;\n}\n\n.chroma-info {\n  position: relative;\n  z-index: 1;\n  padding: 0.75rem 1rem;\n  color: #fff;\n  font-family: system-ui, sans-serif;\n  display: grid;\n  grid-template-columns: 1fr auto;\n  row-gap: 0.25rem;\n  column-gap: 0.75rem;\n}\n\n.chroma-info .role,\n.chroma-info .handle {\n  color: #aaa;\n}\n\n.chroma-overlay {\n  position: absolute;\n  inset: 0;\n  pointer-events: none;\n  z-index: 3;\n  backdrop-filter: grayscale(1) brightness(0.78);\n  -webkit-backdrop-filter: grayscale(1) brightness(0.78);\n  background: rgba(0, 0, 0, 0.001);\n\n  mask-image: radial-gradient(circle var(--r) at var(--x) var(--y),\n      transparent 0%,\n      transparent 15%,\n      rgba(0, 0, 0, 0.10) 30%,\n      rgba(0, 0, 0, 0.22) 45%,\n      rgba(0, 0, 0, 0.35) 60%,\n      rgba(0, 0, 0, 0.50) 75%,\n      rgba(0, 0, 0, 0.68) 88%,\n      white 100%);\n  -webkit-mask-image: radial-gradient(circle var(--r) at var(--x) var(--y),\n      transparent 0%,\n      transparent 15%,\n      rgba(0, 0, 0, 0.10) 30%,\n      rgba(0, 0, 0, 0.22) 45%,\n      rgba(0, 0, 0, 0.35) 60%,\n      rgba(0, 0, 0, 0.50) 75%,\n      rgba(0, 0, 0, 0.68) 88%,\n      white 100%);\n}\n\n.chroma-fade {\n  position: absolute;\n  inset: 0;\n  pointer-events: none;\n  z-index: 4;\n  backdrop-filter: grayscale(1) brightness(0.78);\n  -webkit-backdrop-filter: grayscale(1) brightness(0.78);\n  background: rgba(0, 0, 0, 0.001);\n\n  mask-image: radial-gradient(circle var(--r) at var(--x) var(--y),\n      white 0%,\n      white 15%,\n      rgba(255, 255, 255, 0.90) 30%,\n      rgba(255, 255, 255, 0.78) 45%,\n      rgba(255, 255, 255, 0.65) 60%,\n      rgba(255, 255, 255, 0.50) 75%,\n      rgba(255, 255, 255, 0.32) 88%,\n      transparent 100%);\n  -webkit-mask-image: radial-gradient(circle var(--r) at var(--x) var(--y),\n      white 0%,\n      white 15%,\n      rgba(255, 255, 255, 0.90) 30%,\n      rgba(255, 255, 255, 0.78) 45%,\n      rgba(255, 255, 255, 0.65) 60%,\n      rgba(255, 255, 255, 0.50) 75%,\n      rgba(255, 255, 255, 0.32) 88%,\n      transparent 100%);\n\n  opacity: 1;\n  transition: opacity 0.25s ease;\n}' }), (0, import_jsx_runtime.jsxs)("div", { ref: m2, className: `chroma-grid ${a2}`, style: { "--r": `${s2}px`, "--cols": c2, "--rows": l2 }, onPointerMove: (e2) => {
    const t2 = m2.current.getBoundingClientRect();
    var n2, i2;
    n2 = e2.clientX - t2.left, i2 = e2.clientY - t2.top, (void 0).to(x2.current, { x: n2, y: i2, duration: u2, ease: d2, onUpdate: () => {
      var _a, _b;
      (_a = f2.current) == null ? void 0 : _a.call(f2, x2.current.x), (_b = g2.current) == null ? void 0 : _b.call(g2, x2.current.y);
    }, overwrite: true }), (void 0).to(p2.current, { opacity: 0, duration: 0.25, overwrite: true });
  }, onPointerLeave: () => {
    (void 0).to(p2.current, { opacity: 1, duration: h2, overwrite: true });
  }, children: [y.map((n2, i2) => (0, import_jsx_runtime.jsxs)("article", { className: "chroma-card", onMouseMove: w, onClick: () => {
    var e2;
    (e2 = n2.url) && window.open(e2, "_blank", "noopener,noreferrer");
  }, style: { "--card-border": n2.borderColor || "transparent", "--card-gradient": n2.gradient, cursor: n2.url ? "pointer" : "default" }, children: [(0, import_jsx_runtime.jsx)("div", { className: "chroma-img-wrapper", children: (0, import_jsx_runtime.jsx)("img", { src: n2.image, alt: n2.title, loading: "lazy" }) }), (0, import_jsx_runtime.jsxs)("footer", { className: "chroma-info", children: [(0, import_jsx_runtime.jsx)("h3", { className: "name", children: n2.title }), n2.handle && (0, import_jsx_runtime.jsx)("span", { className: "handle", children: n2.handle }), (0, import_jsx_runtime.jsx)("p", { className: "role", children: n2.subtitle }), n2.location && (0, import_jsx_runtime.jsx)("span", { className: "location", children: n2.location })] })] }, i2)), (0, import_jsx_runtime.jsx)("div", { className: "chroma-overlay" }), (0, import_jsx_runtime.jsx)("div", { ref: p2, className: "chroma-fade" })] })] });
};
var dn = (e2, t2) => {
  let n2 = e2.startsWith("#") ? e2.slice(1) : e2;
  3 === n2.length && (n2 = n2.split("").map((e3) => e3 + e3).join(""));
  const i2 = parseInt(n2, 16);
  let r2 = i2 >> 16 & 255, o2 = i2 >> 8 & 255, a2 = 255 & i2;
  return r2 = Math.max(0, Math.min(255, Math.floor(r2 * (1 - t2)))), o2 = Math.max(0, Math.min(255, Math.floor(o2 * (1 - t2)))), a2 = Math.max(0, Math.min(255, Math.floor(a2 * (1 - t2)))), "#" + ((1 << 24) + (r2 << 16) + (o2 << 8) + a2).toString(16).slice(1).toUpperCase();
};
var mn = ({ color: i2 = "#5227FF", size: r2 = 1, items: a2 = [], className: s2 = "" }) => {
  const c2 = a2.slice(0, 3);
  for (; c2.length < 3; ) c2.push(null);
  const [l2, u2] = (0, import_react3.useState)(false), [h2, d2] = (0, import_react3.useState)(Array.from({ length: 3 }, () => ({ x: 0, y: 0 }))), m2 = dn(i2, 0.08), p2 = dn("#ffffff", 0.1), f2 = dn("#ffffff", 0.05), v2 = { "--folder-color": i2, "--folder-back-color": m2, "--paper-1": p2, "--paper-2": f2, "--paper-3": "#ffffff" }, g2 = ("folder " + (l2 ? "open" : "")).trim(), x2 = { transform: `scale(${r2})` };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ':root {\n  --folder-color: #70a1ff;\n  --folder-back-color: #4785ff;\n  --paper-1: #e6e6e6;\n  --paper-2: #f2f2f2;\n  --paper-3: #ffffff;\n}\n\n.folder {\n  transition: all 0.2s ease-in;\n  cursor: pointer;\n}\n\n.folder:not(.folder--click):hover {\n  transform: translateY(-8px);\n}\n\n.folder:not(.folder--click):hover .paper {\n  transform: translate(-50%, 0%);\n}\n\n.folder:not(.folder--click):hover .folder__front {\n  transform: skew(15deg) scaleY(0.6);\n}\n\n.folder:not(.folder--click):hover .right {\n  transform: skew(-15deg) scaleY(0.6);\n}\n\n.folder.open {\n  transform: translateY(-8px);\n}\n\n.folder.open .paper:nth-child(1) {\n  transform: translate(-120%, -70%) rotateZ(-15deg);\n}\n\n.folder.open .paper:nth-child(1):hover {\n  transform: translate(-120%, -70%) rotateZ(-15deg) scale(1.1);\n}\n\n.folder.open .paper:nth-child(2) {\n  transform: translate(10%, -70%) rotateZ(15deg);\n  height: 80%;\n}\n\n.folder.open .paper:nth-child(2):hover {\n  transform: translate(10%, -70%) rotateZ(15deg) scale(1.1);\n}\n\n.folder.open .paper:nth-child(3) {\n  transform: translate(-50%, -100%) rotateZ(5deg);\n  height: 80%;\n}\n\n.folder.open .paper:nth-child(3):hover {\n  transform: translate(-50%, -100%) rotateZ(5deg) scale(1.1);\n}\n\n.folder.open .folder__front {\n  transform: skew(15deg) scaleY(0.6);\n}\n\n.folder.open .right {\n  transform: skew(-15deg) scaleY(0.6);\n}\n\n.folder__back {\n  position: relative;\n  width: 100px;\n  height: 80px;\n  background: var(--folder-back-color);\n  border-radius: 0px 10px 10px 10px;\n}\n\n.folder__back::after {\n  position: absolute;\n  z-index: 0;\n  bottom: 98%;\n  left: 0;\n  content: "";\n  width: 30px;\n  height: 10px;\n  background: var(--folder-back-color);\n  border-radius: 5px 5px 0 0;\n}\n\n.paper {\n  position: absolute;\n  z-index: 2;\n  bottom: 10%;\n  left: 50%;\n  transform: translate(-50%, 10%);\n  width: 70%;\n  height: 80%;\n  background: var(--paper-1);\n  border-radius: 10px;\n  transition: all 0.3s ease-in-out;\n}\n\n.paper:nth-child(2) {\n  background: var(--paper-2);\n  width: 80%;\n  height: 70%;\n}\n\n.paper:nth-child(3) {\n  background: var(--paper-3);\n  width: 90%;\n  height: 60%;\n}\n\n.folder__front {\n  position: absolute;\n  z-index: 3;\n  width: 100%;\n  height: 100%;\n  background: var(--folder-color);\n  border-radius: 5px 10px 10px 10px;\n  transform-origin: bottom;\n  transition: all 0.3s ease-in-out;\n}' }), (0, import_jsx_runtime.jsx)("div", { style: x2, className: s2, children: (0, import_jsx_runtime.jsx)("div", { className: g2, style: v2, onClick: () => {
    u2((e2) => !e2), l2 && d2(Array.from({ length: 3 }, () => ({ x: 0, y: 0 })));
  }, children: (0, import_jsx_runtime.jsxs)("div", { className: "folder__back", children: [c2.map((t2, n2) => {
    var _a, _b;
    return (0, import_jsx_runtime.jsx)("div", { className: `paper paper-${n2 + 1}`, onMouseMove: (e2) => ((e3, t3) => {
      if (!l2) return;
      const n3 = e3.currentTarget.getBoundingClientRect(), i3 = n3.left + n3.width / 2, r3 = n3.top + n3.height / 2, o2 = 0.15 * (e3.clientX - i3), a3 = 0.15 * (e3.clientY - r3);
      d2((e4) => {
        const n4 = [...e4];
        return n4[t3] = { x: o2, y: a3 }, n4;
      });
    })(e2, n2), onMouseLeave: (e2) => {
      return t3 = n2, void d2((e3) => {
        const n3 = [...e3];
        return n3[t3] = { x: 0, y: 0 }, n3;
      });
      var t3;
    }, style: l2 ? { "--magnet-x": `${((_a = h2[n2]) == null ? void 0 : _a.x) || 0}px`, "--magnet-y": `${((_b = h2[n2]) == null ? void 0 : _b.y) || 0}px` } : {}, children: t2 }, n2);
  }), (0, import_jsx_runtime.jsx)("div", { className: "folder__front" }), (0, import_jsx_runtime.jsx)("div", { className: "folder__front right" })] }) }) })] });
};
var pn = "undefined" != typeof window && ("ontouchstart" in window || navigator.maxTouchPoints > 0);
var fn = (e2) => e2 * Math.PI / 180;
var vn = 5e-3;
var gn = fn(6);
var xn = ({ placeholderSrc: t2 }) => {
  const { progress: n2, active: i2 } = (void 0)();
  return !i2 && t2 ? null : (0, import_jsx_runtime.jsx)(void 0, { center: true, children: t2 ? (0, import_jsx_runtime.jsx)("img", { src: t2, width: 128, height: 128, style: { filter: "blur(8px)", borderRadius: 8 } }) : `${Math.round(n2)} %` });
};
var yn = ({ pivot: t2, min: n2, max: r2, zoomEnabled: o2 }) => {
  const a2 = (0, import_react3.useRef)(null);
  return (void 0)(() => {
    var _a;
    return (_a = a2.current) == null ? void 0 : _a.target.copy(t2);
  }), (0, import_jsx_runtime.jsx)(void 0, { ref: a2, makeDefault: true, enablePan: false, enableRotate: false, enableZoom: o2, minDistance: n2, maxDistance: r2 });
};
var wn = ({ url: t2, xOff: n2, yOff: o2, pivot: c2, initYaw: l2, initPitch: u2, minZoom: h2, maxZoom: d2, enableMouseParallax: m2, enableManualRotation: p2, enableHoverRotation: f2, enableManualZoom: v2, autoFrame: g2, fadeIn: x2, autoRotate: y, autoRotateSpeed: w, onLoaded: b }) => {
  const M = (0, import_react3.useRef)(null), P = (0, import_react3.useRef)(null), { camera: S, gl: C } = (void 0)(), E = (0, import_react3.useRef)({ x: 0, y: 0 }), z = (0, import_react3.useRef)({ x: 0, y: 0 }), _ = (0, import_react3.useRef)({ x: 0, y: 0 }), T = (0, import_react3.useRef)({ x: 0, y: 0 }), A = (0, import_react3.useRef)({ x: 0, y: 0 }), R2 = (0, import_react3.useMemo)(() => t2.split(".").pop().toLowerCase(), [t2]), L = (0, import_react3.useMemo)(() => "glb" === R2 || "gltf" === R2 ? (void 0)(t2).scene.clone() : "fbx" === R2 ? (void 0)(t2).clone() : "obj" === R2 ? (void 0)(void 0, t2).clone() : null, [t2, R2]), F = (0, import_react3.useRef)(new Vector3());
  return (0, import_react3.useLayoutEffect)(() => {
    if (!L) return;
    const e2 = P.current;
    e2.updateWorldMatrix(true, true);
    const t3 = new Box3().setFromObject(e2).getBoundingSphere(new Sphere()), n3 = 1 / (2 * t3.radius);
    if (e2.position.set(-t3.center.x, -t3.center.y, -t3.center.z), e2.scale.setScalar(n3), e2.traverse((e3) => {
      e3.isMesh && (e3.castShadow = true, e3.receiveShadow = true, x2 && (e3.material.transparent = true, e3.material.opacity = 0));
    }), e2.getWorldPosition(F.current), c2.copy(F.current), M.current.rotation.set(u2, l2, 0), g2 && S.isPerspectiveCamera) {
      const e3 = S, i2 = 1.2 * (t3.radius * n3) / Math.sin(e3.fov * Math.PI / 180 / 2);
      e3.position.set(F.current.x, F.current.y, F.current.z + i2), e3.near = i2 / 10, e3.far = 10 * i2, e3.updateProjectionMatrix();
    }
    if (x2) {
      let t4 = 0;
      const n4 = setInterval(() => {
        t4 += 0.05;
        const i2 = Math.min(t4, 1);
        e2.traverse((e3) => {
          e3.isMesh && (e3.material.opacity = i2);
        }), (void 0)(), 1 === i2 && (clearInterval(n4), b == null ? void 0 : b());
      }, 16);
      return () => clearInterval(n4);
    }
    b == null ? void 0 : b();
  }, [L]), (0, import_react3.useEffect)(() => {
    if (!p2 || pn) return;
    const e2 = C.domElement;
    let t3 = false, n3 = 0, i2 = 0;
    const r2 = (e3) => {
      "mouse" !== e3.pointerType && "pen" !== e3.pointerType || (t3 = true, n3 = e3.clientX, i2 = e3.clientY, window.addEventListener("pointerup", a2));
    }, o3 = (e3) => {
      if (!t3) return;
      const r3 = e3.clientX - n3, o4 = e3.clientY - i2;
      n3 = e3.clientX, i2 = e3.clientY, M.current.rotation.y += r3 * vn, M.current.rotation.x += o4 * vn, E.current = { x: r3 * vn, y: o4 * vn }, (void 0)();
    }, a2 = () => t3 = false;
    return e2.addEventListener("pointerdown", r2), e2.addEventListener("pointermove", o3), () => {
      e2.removeEventListener("pointerdown", r2), e2.removeEventListener("pointermove", o3), window.removeEventListener("pointerup", a2);
    };
  }, [C, p2]), (0, import_react3.useEffect)(() => {
    if (!pn) return;
    const e2 = C.domElement, t3 = /* @__PURE__ */ new Map();
    let n3 = "idle", i2 = 0, r2 = 0, o3 = 0, a2 = 0, s2 = 0, c3 = 0;
    const l3 = (e3) => {
      if ("touch" === e3.pointerType) {
        if (t3.set(e3.pointerId, { x: e3.clientX, y: e3.clientY }), 1 === t3.size) n3 = "decide", i2 = o3 = e3.clientX, r2 = a2 = e3.clientY;
        else if (2 === t3.size && v2) {
          n3 = "pinch";
          const [i3, r3] = [...t3.values()];
          s2 = Math.hypot(i3.x - r3.x, i3.y - r3.y), c3 = S.position.z, e3.preventDefault();
        }
        (void 0)();
      }
    }, u3 = (l4) => {
      const u4 = t3.get(l4.pointerId);
      if (u4) {
        if (u4.x = l4.clientX, u4.y = l4.clientY, "decide" === n3) {
          const o4 = l4.clientX - i2, a3 = l4.clientY - r2;
          (Math.abs(o4) > 8 || Math.abs(a3) > 8) && (p2 && Math.abs(o4) > Math.abs(a3) ? (n3 = "rotate", e2.setPointerCapture(l4.pointerId)) : (n3 = "idle", t3.clear()));
        }
        if ("rotate" === n3) {
          l4.preventDefault();
          const e3 = l4.clientX - o3, t4 = l4.clientY - a2;
          o3 = l4.clientX, a2 = l4.clientY, M.current.rotation.y += e3 * vn, M.current.rotation.x += t4 * vn, E.current = { x: e3 * vn, y: t4 * vn }, (void 0)();
        } else if ("pinch" === n3 && 2 === t3.size) {
          l4.preventDefault();
          const [e3, n4] = [...t3.values()], i3 = Math.hypot(e3.x - n4.x, e3.y - n4.y), r3 = s2 / i3;
          S.position.z = MathUtils.clamp(c3 * r3, h2, d2), (void 0)();
        }
      }
    }, m3 = (e3) => {
      t3.delete(e3.pointerId), "rotate" === n3 && 0 === t3.size && (n3 = "idle"), "pinch" === n3 && t3.size < 2 && (n3 = "idle");
    };
    return e2.addEventListener("pointerdown", l3, { passive: true }), window.addEventListener("pointermove", u3, { passive: false }), window.addEventListener("pointerup", m3, { passive: true }), window.addEventListener("pointercancel", m3, { passive: true }), () => {
      e2.removeEventListener("pointerdown", l3), window.removeEventListener("pointermove", u3), window.removeEventListener("pointerup", m3), window.removeEventListener("pointercancel", m3);
    };
  }, [C, p2, v2, h2, d2]), (0, import_react3.useEffect)(() => {
    if (pn) return;
    const e2 = (e3) => {
      if ("mouse" !== e3.pointerType) return;
      const t3 = e3.clientX / window.innerWidth * 2 - 1, n3 = e3.clientY / window.innerHeight * 2 - 1;
      m2 && (z.current = { x: 0.05 * -t3, y: 0.05 * -n3 }), f2 && (T.current = { x: n3 * gn, y: t3 * gn }), (void 0)();
    };
    return window.addEventListener("pointermove", e2), () => window.removeEventListener("pointermove", e2);
  }, [m2, f2]), (void 0)((e2, t3) => {
    let i2 = false;
    _.current.x += 0.12 * (z.current.x - _.current.x), _.current.y += 0.12 * (z.current.y - _.current.y);
    const r2 = A.current.x, a2 = A.current.y;
    A.current.x += 0.15 * (T.current.x - A.current.x), A.current.y += 0.15 * (T.current.y - A.current.y);
    const s2 = F.current.clone().project(S);
    s2.x += n2 + _.current.x, s2.y += o2 + _.current.y, M.current.position.copy(s2.unproject(S)), M.current.rotation.x += A.current.x - r2, M.current.rotation.y += A.current.y - a2, y && (M.current.rotation.y += w * t3, i2 = true), M.current.rotation.y += E.current.x, M.current.rotation.x += E.current.y, E.current.x *= 0.925, E.current.y *= 0.925, (Math.abs(E.current.x) > 1e-4 || Math.abs(E.current.y) > 1e-4) && (i2 = true), (Math.abs(_.current.x - z.current.x) > 1e-4 || Math.abs(_.current.y - z.current.y) > 1e-4 || Math.abs(A.current.x - T.current.x) > 1e-4 || Math.abs(A.current.y - T.current.y) > 1e-4) && (i2 = true), i2 && (void 0)();
  }), L ? (0, import_jsx_runtime.jsx)("group", { ref: M, children: (0, import_jsx_runtime.jsx)("group", { ref: P, children: (0, import_jsx_runtime.jsx)("primitive", { object: L }) }) }) : null;
};
var bn = ({ url: o2, width: a2 = 400, height: s2 = 400, modelXOffset: c2 = 0, modelYOffset: l2 = 0, defaultRotationX: h2 = -50, defaultRotationY: d2 = 20, defaultZoom: m2 = 0.5, minZoomDistance: p2 = 0.5, maxZoomDistance: f2 = 10, enableMouseParallax: v2 = true, enableManualRotation: g2 = true, enableHoverRotation: x2 = true, enableManualZoom: y = true, ambientIntensity: w = 0.3, keyLightIntensity: b = 1, fillLightIntensity: M = 0.5, rimLightIntensity: P = 0.8, environmentPreset: S = "forest", autoFrame: C = false, placeholderSrc: E, showScreenshotButton: z = true, fadeIn: _ = false, autoRotate: T = false, autoRotateSpeed: A = 0.35, onModelLoaded: R2 }) => {
  (0, import_react3.useEffect)(() => {
    (void 0).preload(o2);
  }, [o2]);
  const L = (0, import_react3.useRef)(new Vector3()).current, F = (0, import_react3.useRef)(null), k = (0, import_react3.useRef)(null), D = (0, import_react3.useRef)(null), N = (0, import_react3.useRef)(null), B = fn(h2), U = fn(d2), O = Math.min(Math.max(m2, p2), f2);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsxs)("div", { style: { width: a2, height: s2, position: "relative", touchAction: "pan-y pinch-zoom" }, children: [z && (0, import_jsx_runtime.jsx)("button", { onClick: () => {
    const e2 = k.current, t2 = D.current, n2 = N.current;
    if (!e2 || !t2 || !n2) return;
    e2.shadowMap.enabled = false;
    const i2 = [];
    t2.traverse((e3) => {
      e3.isLight && "castShadow" in e3 && (i2.push({ l: e3, cast: e3.castShadow }), e3.castShadow = false);
    }), F.current && (F.current.visible = false), e2.render(t2, n2);
    const r2 = e2.domElement.toDataURL("image/png"), o3 = document.createElement("a");
    o3.download = "model.png", o3.href = r2, o3.click(), e2.shadowMap.enabled = true, i2.forEach(({ l: e3, cast: t3 }) => e3.castShadow = t3), F.current && (F.current.visible = true), (void 0)();
  }, style: { position: "absolute", border: "1px solid #fff", right: 16, top: 16, zIndex: 10, cursor: "pointer", padding: "8px 16px", borderRadius: 10 }, children: "Take Screenshot" }), (0, import_jsx_runtime.jsxs)(void 0, { shadows: true, frameloop: "demand", gl: { preserveDrawingBuffer: true }, onCreated: ({ gl: e2, scene: t2, camera: n2 }) => {
    k.current = e2, D.current = t2, N.current = n2, e2.toneMapping = ACESFilmicToneMapping, e2.outputColorSpace = SRGBColorSpace;
  }, camera: { fov: 50, position: [0, 0, O], near: 0.01, far: 100 }, style: { touchAction: "pan-y pinch-zoom" }, children: ["none" !== S && (0, import_jsx_runtime.jsx)(void 0, { preset: S, background: false }), (0, import_jsx_runtime.jsx)("ambientLight", { intensity: w }), (0, import_jsx_runtime.jsx)("directionalLight", { position: [5, 5, 5], intensity: b, castShadow: true }), (0, import_jsx_runtime.jsx)("directionalLight", { position: [-5, 2, 5], intensity: M }), (0, import_jsx_runtime.jsx)("directionalLight", { position: [0, 4, -5], intensity: P }), (0, import_jsx_runtime.jsx)(void 0, { ref: F, position: [0, -0.5, 0], opacity: 0.35, scale: 10, blur: 2 }), (0, import_jsx_runtime.jsx)(import_react3.Suspense, { fallback: (0, import_jsx_runtime.jsx)(xn, { placeholderSrc: E }), children: (0, import_jsx_runtime.jsx)(wn, { url: o2, xOff: c2, yOff: l2, pivot: L, initYaw: B, initPitch: U, minZoom: p2, maxZoom: f2, enableMouseParallax: v2, enableManualRotation: g2, enableHoverRotation: x2, enableManualZoom: y, autoFrame: C, fadeIn: _, autoRotate: T, autoRotateSpeed: A, onLoaded: R2 }) }), !pn && (0, import_jsx_runtime.jsx)(yn, { pivot: L, min: p2, max: f2, zoomEnabled: y })] })] }) });
};
var Mn = 600;
var Pn = 1500;
var Sn = 70;
var Cn = 60;
var En = (e2, t2 = 0, n2 = 100) => Math.min(Math.max(e2, t2), n2);
var zn = (e2, t2 = 3) => parseFloat(e2.toFixed(t2));
var _n = (e2, t2, n2, i2, r2) => zn(i2 + (r2 - i2) * (e2 - t2) / (n2 - t2));
var Tn = import_react3.default.memo(({ avatarUrl: o2 = "<Placeholder for avatar URL>", iconUrl: s2 = "<Placeholder for icon URL>", grainUrl: c2 = "<Placeholder for grain URL>", behindGradient: u2, innerGradient: h2, showBehindGradient: d2 = true, className: m2 = "", enableTilt: p2 = true, miniAvatarUrl: f2, name: v2 = "Javi A. Torres", title: g2 = "Software Engineer", handle: x2 = "javicodes", status: y = "Online", contactText: w = "Contact", showUserInfo: b = true, onContactClick: M }) => {
  const P = (0, import_react3.useRef)(null), S = (0, import_react3.useRef)(null), C = (0, import_react3.useMemo)(() => {
    if (!p2) return null;
    let e2 = null;
    const t2 = (e3, t3, n2, i2) => {
      const r2 = n2.clientWidth, o3 = n2.clientHeight, a2 = En(100 / r2 * e3), s3 = En(100 / o3 * t3), c3 = a2 - 50, l2 = s3 - 50, u3 = { "--pointer-x": `${a2}%`, "--pointer-y": `${s3}%`, "--background-x": `${_n(a2, 0, 100, 35, 65)}%`, "--background-y": `${_n(s3, 0, 100, 35, 65)}%`, "--pointer-from-center": `${En(Math.hypot(s3 - 50, a2 - 50) / 50, 0, 1)}`, "--pointer-from-top": "" + s3 / 100, "--pointer-from-left": "" + a2 / 100, "--rotate-x": `${zn(-c3 / 5)}deg`, "--rotate-y": `${zn(l2 / 4)}deg` };
      Object.entries(u3).forEach(([e4, t4]) => {
        i2.style.setProperty(e4, t4);
      });
    };
    return { updateCardTransform: t2, createSmoothAnimation: (n2, i2, r2, o3, a2) => {
      const s3 = performance.now(), c3 = a2.clientWidth / 2, l2 = a2.clientHeight / 2, u3 = (h3) => {
        const d3 = En((h3 - s3) / n2), m3 = (p3 = d3) < 0.5 ? 4 * p3 * p3 * p3 : 1 - Math.pow(-2 * p3 + 2, 3) / 2;
        var p3;
        const f3 = _n(m3, 0, 1, i2, c3), v3 = _n(m3, 0, 1, r2, l2);
        t2(f3, v3, o3, a2), d3 < 1 && (e2 = requestAnimationFrame(u3));
      };
      e2 = requestAnimationFrame(u3);
    }, cancelAnimation: () => {
      e2 && (cancelAnimationFrame(e2), e2 = null);
    } };
  }, [p2]), E = (0, import_react3.useCallback)((e2) => {
    const t2 = S.current, n2 = P.current;
    if (!t2 || !n2 || !C) return;
    const i2 = t2.getBoundingClientRect();
    C.updateCardTransform(e2.clientX - i2.left, e2.clientY - i2.top, t2, n2);
  }, [C]), z = (0, import_react3.useCallback)(() => {
    const e2 = S.current, t2 = P.current;
    e2 && t2 && C && (C.cancelAnimation(), t2.classList.add("active"), e2.classList.add("active"));
  }, [C]), _ = (0, import_react3.useCallback)((e2) => {
    const t2 = S.current, n2 = P.current;
    t2 && n2 && C && (C.createSmoothAnimation(Mn, e2.offsetX, e2.offsetY, t2, n2), n2.classList.remove("active"), t2.classList.remove("active"));
  }, [C]);
  (0, import_react3.useEffect)(() => {
    if (!p2 || !C) return;
    const e2 = S.current, t2 = P.current;
    if (!e2 || !t2) return;
    const n2 = E, i2 = z, r2 = _;
    e2.addEventListener("pointerenter", i2), e2.addEventListener("pointermove", n2), e2.addEventListener("pointerleave", r2);
    const o3 = t2.clientWidth - Sn, a2 = Cn;
    return C.updateCardTransform(o3, a2, e2, t2), C.createSmoothAnimation(Pn, o3, a2, e2, t2), () => {
      e2.removeEventListener("pointerenter", i2), e2.removeEventListener("pointermove", n2), e2.removeEventListener("pointerleave", r2), C.cancelAnimation();
    };
  }, [p2, C, E, z, _]);
  const T = (0, import_react3.useMemo)(() => ({ "--icon": s2 ? `url(${s2})` : "none", "--grain": c2 ? `url(${c2})` : "none", "--behind-gradient": d2 ? u2 ?? "radial-gradient(farthest-side circle at var(--pointer-x) var(--pointer-y),hsla(266,100%,90%,var(--card-opacity)) 4%,hsla(266,50%,80%,calc(var(--card-opacity)*0.75)) 10%,hsla(266,25%,70%,calc(var(--card-opacity)*0.5)) 50%,hsla(266,0%,60%,0) 100%),radial-gradient(35% 52% at 55% 20%,#00ffaac4 0%,#073aff00 100%),radial-gradient(100% 100% at 50% 50%,#00c1ffff 1%,#073aff00 76%),conic-gradient(from 124deg at 50% 50%,#c137ffff 0%,#07c6ffff 40%,#07c6ffff 60%,#c137ffff 100%)" : "none", "--inner-gradient": h2 ?? "linear-gradient(145deg,#60496e8c 0%,#71C4FF44 100%)" }), [s2, c2, d2, u2, h2]), A = (0, import_react3.useCallback)(() => {
    M == null ? void 0 : M();
  }, [M]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: `:root {
  --pointer-x: 50%;
  --pointer-y: 50%;
  --pointer-from-center: 0;
  --pointer-from-top: 0.5;
  --pointer-from-left: 0.5;
  --card-opacity: 0;
  --rotate-x: 0deg;
  --rotate-y: 0deg;
  --background-x: 50%;
  --background-y: 50%;
  --grain: none;
  --icon: none;
  --behind-gradient: none;
  --inner-gradient: none;
  --sunpillar-1: hsl(2, 100%, 73%);
  --sunpillar-2: hsl(53, 100%, 69%);
  --sunpillar-3: hsl(93, 100%, 69%);
  --sunpillar-4: hsl(176, 100%, 76%);
  --sunpillar-5: hsl(228, 100%, 74%);
  --sunpillar-6: hsl(283, 100%, 73%);
  --sunpillar-clr-1: var(--sunpillar-1);
  --sunpillar-clr-2: var(--sunpillar-2);
  --sunpillar-clr-3: var(--sunpillar-3);
  --sunpillar-clr-4: var(--sunpillar-4);
  --sunpillar-clr-5: var(--sunpillar-5);
  --sunpillar-clr-6: var(--sunpillar-6);
  --card-radius: 30px;
}

.pc-card-wrapper {
  perspective: 500px;
  transform: translate3d(0, 0, 0.1px);
  position: relative;
  touch-action: none;
}

.pc-card-wrapper::before {
  content: '';
  position: absolute;
  inset: -10px;
  background: inherit;
  background-position: inherit;
  border-radius: inherit;
  transition: all 0.5s ease;
  filter: contrast(2) saturate(2) blur(36px);
  transform: scale(0.8) translate3d(0, 0, 0.1px);
  background-size: 100% 100%;
  background-image: var(--behind-gradient);
}

.pc-card-wrapper:hover,
.pc-card-wrapper.active {
  --card-opacity: 1;
}

.pc-card-wrapper:hover::before,
.pc-card-wrapper.active::before {
  filter: contrast(1) saturate(2) blur(40px) opacity(1);
  transform: scale(0.9) translate3d(0, 0, 0.1px);
}

.pc-card {
  height: 80svh;
  max-height: 540px;
  display: grid;
  aspect-ratio: 0.718;
  border-radius: var(--card-radius);
  position: relative;
  background-blend-mode: color-dodge, normal, normal, normal;
  animation: glow-bg 12s linear infinite;
  box-shadow: rgba(0, 0, 0, 0.8) calc((var(--pointer-from-left) * 10px) - 3px) calc((var(--pointer-from-top) * 20px) - 6px) 20px -5px;
  transition: transform 1s ease;
  transform: translate3d(0, 0, 0.1px) rotateX(0deg) rotateY(0deg);
  background-size: 100% 100%;
  background-position: 0 0, 0 0, 50% 50%, 0 0;
  background-image: radial-gradient(farthest-side circle at var(--pointer-x) var(--pointer-y), hsla(266, 100%, 90%, var(--card-opacity)) 4%, hsla(266, 50%, 80%, calc(var(--card-opacity) * 0.75)) 10%, hsla(266, 25%, 70%, calc(var(--card-opacity) * 0.5)) 50%, hsla(266, 0%, 60%, 0) 100%), radial-gradient(35% 52% at 55% 20%, #00ffaac4 0%, #073aff00 100%), radial-gradient(100% 100% at 50% 50%, #00c1ffff 1%, #073aff00 76%), conic-gradient(from 124deg at 50% 50%, #c137ffff 0%, #07c6ffff 40%, #07c6ffff 60%, #c137ffff 100%);
  overflow: hidden;
}

.pc-card:hover,
.pc-card.active {
  transition: none;
  transform: translate3d(0, 0, 0.1px) rotateX(var(--rotate-y)) rotateY(var(--rotate-x));
}

.pc-card * {
  display: grid;
  grid-area: 1/-1;
  border-radius: var(--card-radius);
  transform: translate3d(0, 0, 0.1px);
  pointer-events: none;
}

.pc-inside {
  inset: 1px;
  position: absolute;
  background-image: var(--inner-gradient);
  background-color: rgba(0, 0, 0, 0.9);
  transform: translate3d(0, 0, 0.01px);
}

.pc-shine {
  mask-image: var(--icon);
  mask-mode: luminance;
  mask-repeat: repeat;
  mask-size: 150%;
  mask-position: top calc(200% - (var(--background-y) * 5)) left calc(100% - var(--background-x));
  transition: filter 0.6s ease;
  filter: brightness(0.66) contrast(1.33) saturate(0.33) opacity(0.5);
  animation: holo-bg 18s linear infinite;
  mix-blend-mode: color-dodge;
}

.pc-shine,
.pc-shine::after {
  --space: 5%;
  --angle: -45deg;
  transform: translate3d(0, 0, 1px);
  overflow: hidden;
  z-index: 3;
  background: transparent;
  background-size: cover;
  background-position: center;
  background-image: repeating-linear-gradient(0deg, var(--sunpillar-clr-1) calc(var(--space) * 1), var(--sunpillar-clr-2) calc(var(--space) * 2), var(--sunpillar-clr-3) calc(var(--space) * 3), var(--sunpillar-clr-4) calc(var(--space) * 4), var(--sunpillar-clr-5) calc(var(--space) * 5), var(--sunpillar-clr-6) calc(var(--space) * 6), var(--sunpillar-clr-1) calc(var(--space) * 7)), repeating-linear-gradient(var(--angle), #0e152e 0%, hsl(180, 10%, 60%) 3.8%, hsl(180, 29%, 66%) 4.5%, hsl(180, 10%, 60%) 5.2%, #0e152e 10%, #0e152e 12%), radial-gradient(farthest-corner circle at var(--pointer-x) var(--pointer-y), hsla(0, 0%, 0%, 0.1) 12%, hsla(0, 0%, 0%, 0.15) 20%, hsla(0, 0%, 0%, 0.25) 120%);
  background-position: 0 var(--background-y), var(--background-x) var(--background-y), center;
  background-blend-mode: color, hard-light;
  background-size: 500% 500%, 300% 300%, 200% 200%;
  background-repeat: repeat;
}

.pc-shine::before,
.pc-shine::after {
  content: '';
  background-position: center;
  background-size: cover;
  grid-area: 1/1;
  opacity: 0;
}

.pc-card:hover .pc-shine,
.pc-card.active .pc-shine {
  filter: brightness(0.85) contrast(1.5) saturate(0.5);
  animation: none;
}

.pc-card:hover .pc-shine::before,
.pc-card.active .pc-shine::before,
.pc-card:hover .pc-shine::after,
.pc-card.active .pc-shine::after {
  opacity: 1;
}

.pc-shine::before {
  background-image: linear-gradient(45deg, var(--sunpillar-4), var(--sunpillar-5), var(--sunpillar-6), var(--sunpillar-1), var(--sunpillar-2), var(--sunpillar-3)), radial-gradient(circle at var(--pointer-x) var(--pointer-y), hsl(0, 0%, 70%) 0%, hsla(0, 0%, 30%, 0.2) 90%), var(--grain);
  background-size: 250% 250%, 100% 100%, 220px 220px;
  background-position: var(--pointer-x) var(--pointer-y), center, calc(var(--pointer-x) * 0.01) calc(var(--pointer-y) * 0.01);
  background-blend-mode: color-dodge;
  filter: brightness(calc(2 - var(--pointer-from-center))) contrast(calc(var(--pointer-from-center) + 2)) saturate(calc(0.5 + var(--pointer-from-center)));
  mix-blend-mode: luminosity;
}

.pc-shine::after {
  background-position: 0 var(--background-y), calc(var(--background-x) * 0.4) calc(var(--background-y) * 0.5), center;
  background-size: 200% 300%, 700% 700%, 100% 100%;
  mix-blend-mode: difference;
  filter: brightness(0.8) contrast(1.5);
}

.pc-glare {
  transform: translate3d(0, 0, 1.1px);
  overflow: hidden;
  background-image: radial-gradient(farthest-corner circle at var(--pointer-x) var(--pointer-y), hsl(248, 25%, 80%) 12%, hsla(207, 40%, 30%, 0.8) 90%);
  mix-blend-mode: overlay;
  filter: brightness(0.8) contrast(1.2);
  z-index: 4;
}

.pc-avatar-content {
  mix-blend-mode: screen;
  overflow: hidden;
}

.pc-avatar-content .avatar {
  width: 100%;
  position: absolute;
  left: 50%;
  transform: translateX(-50%) scale(1);
  bottom: 2px;
  opacity: calc(1.75 - var(--pointer-from-center));
}

.pc-avatar-content::before {
  content: "";
  position: absolute;
  inset: 0;
  z-index: 1;
  backdrop-filter: blur(30px);
  mask: linear-gradient(to bottom,
      rgba(0, 0, 0, 0) 0%,
      rgba(0, 0, 0, 0) 60%,
      rgba(0, 0, 0, 1) 90%,
      rgba(0, 0, 0, 1) 100%);
  pointer-events: none;
}

.pc-user-info {
  position: absolute;
  bottom: 20px;
  left: 20px;
  right: 20px;
  z-index: 2;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(30px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 15px;
  padding: 12px 14px;
  pointer-events: auto;
}

.pc-user-details {
  display: flex;
  align-items: center;
  gap: 12px;
}

.pc-mini-avatar {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.1);
  flex-shrink: 0;
}

.pc-mini-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 50%;
}

.pc-user-text {
  display: flex;
  align-items: flex-start;
  flex-direction: column;
  gap: 6px;
}

.pc-handle {
  font-size: 14px;
  font-weight: 500;
  color: rgba(255, 255, 255, 0.9);
  line-height: 1;
}

.pc-status {
  font-size: 14px;
  color: rgba(255, 255, 255, 0.7);
  line-height: 1;
}

.pc-contact-btn {
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.9);
  cursor: pointer;
  transition: all 0.2s ease;
  backdrop-filter: blur(10px);
}

.pc-contact-btn:hover {
  border-color: rgba(255, 255, 255, 0.4);
  transform: translateY(-1px);
  transition: all 0.2s ease;
}

.pc-content {
  max-height: 100%;
  overflow: hidden;
  text-align: center;
  position: relative;
  transform: translate3d(calc(var(--pointer-from-left) * -6px + 3px), calc(var(--pointer-from-top) * -6px + 3px), 0.1px) !important;
  z-index: 5;
  mix-blend-mode: luminosity;
}

.pc-details {
  width: 100%;
  position: absolute;
  top: 3em;
  display: flex;
  flex-direction: column;
}

.pc-details h3 {
  font-weight: 600;
  margin: 0;
  font-size: min(5svh, 3em);
  margin: 0;
  background-image: linear-gradient(to bottom, #fff, #6f6fbe);
  background-size: 1em 1.5em;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  -webkit-background-clip: text;
}

.pc-details p {
  font-weight: 600;
  position: relative;
  top: -12px;
  white-space: nowrap;
  font-size: 16px;
  margin: 0 auto;
  width: min-content;
  background-image: linear-gradient(to bottom, #fff, #4a4ac0);
  background-size: 1em 1.5em;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  -webkit-background-clip: text;
}

@keyframes glow-bg {
  0% {
    --bgrotate: 0deg;
  }

  100% {
    --bgrotate: 360deg;
  }
}

@keyframes holo-bg {
  0% {
    background-position: 0 var(--background-y), 0 0, center;
  }

  100% {
    background-position: 0 var(--background-y), 90% 90%, center;
  }
}

@media (max-width: 768px) {
  .pc-card {
    height: 70svh;
    max-height: 450px;
  }

  .pc-details {
    top: 2em;
  }

  .pc-details h3 {
    font-size: min(4svh, 2.5em);
  }

  .pc-details p {
    font-size: 14px;
  }

  .pc-user-info {
    bottom: 15px;
    left: 15px;
    right: 15px;
    padding: 10px 12px;
  }

  .pc-mini-avatar {
    width: 28px;
    height: 28px;
  }

  .pc-user-details {
    gap: 10px;
  }

  .pc-handle {
    font-size: 13px;
  }

  .pc-status {
    font-size: 10px;
  }

  .pc-contact-btn {
    padding: 6px 12px;
    font-size: 11px;
  }
}

@media (max-width: 480px) {
  .pc-card {
    height: 60svh;
    max-height: 380px;
  }

  .pc-details {
    top: 1.5em;
  }

  .pc-details h3 {
    font-size: min(3.5svh, 2em);
  }

  .pc-details p {
    font-size: 12px;
    top: -8px;
  }

  .pc-user-info {
    bottom: 12px;
    left: 12px;
    right: 12px;
    padding: 8px 10px;
    border-radius: 50px;
  }

  .pc-mini-avatar {
    width: 24px;
    height: 24px;
  }

  .pc-user-details {
    gap: 8px;
  }

  .pc-handle {
    font-size: 12px;
  }

  .pc-status {
    font-size: 9px;
  }

  .pc-contact-btn {
    padding: 5px 10px;
    font-size: 10px;
    border-radius: 50px;
  }
}

@media (max-width: 320px) {
  .pc-card {
    height: 55svh;
    max-height: 320px;
  }

  .pc-details h3 {
    font-size: min(3svh, 1.5em);
  }

  .pc-details p {
    font-size: 11px;
  }

  .pc-user-info {
    padding: 6px 8px;
    border-radius: 50px;
  }

  .pc-mini-avatar {
    width: 20px;
    height: 20px;
  }

  .pc-user-details {
    gap: 6px;
  }

  .pc-handle {
    font-size: 11px;
  }

  .pc-status {
    font-size: 8px;
  }

  .pc-contact-btn {
    padding: 4px 8px;
    font-size: 9px;
    border-radius: 50px;
  }
}` }), (0, import_jsx_runtime.jsx)("div", { ref: P, className: `pc-card-wrapper ${m2}`.trim(), style: T, children: (0, import_jsx_runtime.jsx)("section", { ref: S, className: "pc-card", children: (0, import_jsx_runtime.jsxs)("div", { className: "pc-inside", children: [(0, import_jsx_runtime.jsx)("div", { className: "pc-shine" }), (0, import_jsx_runtime.jsx)("div", { className: "pc-glare" }), (0, import_jsx_runtime.jsxs)("div", { className: "pc-content pc-avatar-content", children: [(0, import_jsx_runtime.jsx)("img", { className: "avatar", src: o2, alt: `${v2 || "User"} avatar`, loading: "lazy", onError: (e2) => {
    e2.target.style.display = "none";
  } }), b && (0, import_jsx_runtime.jsxs)("div", { className: "pc-user-info", children: [(0, import_jsx_runtime.jsxs)("div", { className: "pc-user-details", children: [(0, import_jsx_runtime.jsx)("div", { className: "pc-mini-avatar", children: (0, import_jsx_runtime.jsx)("img", { src: f2 || o2, alt: `${v2 || "User"} mini avatar`, loading: "lazy", onError: (e2) => {
    const t2 = e2.target;
    t2.style.opacity = "0.5", t2.src = o2;
  } }) }), (0, import_jsx_runtime.jsxs)("div", { className: "pc-user-text", children: [(0, import_jsx_runtime.jsxs)("div", { className: "pc-handle", children: ["@", x2] }), (0, import_jsx_runtime.jsx)("div", { className: "pc-status", children: y })] })] }), (0, import_jsx_runtime.jsx)("button", { className: "pc-contact-btn", onClick: A, style: { pointerEvents: "auto" }, type: "button", "aria-label": `Contact ${v2 || "user"}`, children: w })] })] }), (0, import_jsx_runtime.jsx)("div", { className: "pc-content", children: (0, import_jsx_runtime.jsxs)("div", { className: "pc-details", children: [(0, import_jsx_runtime.jsx)("h3", { children: v2 }), (0, import_jsx_runtime.jsx)("p", { children: g2 })] }) })] }) }) })] });
});
function An({ children: t2, className: n2 = "", onClick: r2, mouseX: o2, spring: a2, distance: s2, magnification: c2, baseItemSize: l2 }) {
  const u2 = (0, import_react3.useRef)(null), d2 = useMotionValue(0), m2 = useTransform(o2, (e2) => {
    var _a;
    return e2 - (((_a = u2.current) == null ? void 0 : _a.getBoundingClientRect()) ?? { x: 0 }).x - l2 / 2;
  }), p2 = useTransform(m2, [-s2, 0, s2], [l2, c2, l2]), f2 = useSpring(p2, a2);
  return (0, import_jsx_runtime.jsx)(motion.div, { ref: u2, style: { width: f2, height: f2 }, onHoverStart: () => d2.set(1), onHoverEnd: () => d2.set(0), onFocus: () => d2.set(1), onBlur: () => d2.set(0), onClick: r2, className: `dock-item ${n2}`, tabIndex: 0, role: "button", "aria-haspopup": "true", children: import_react3.Children.map(t2, (e2) => import_react3.default.isValidElement(e2) && e2.type === Rn ? import_react3.default.cloneElement(e2, { isHovered: d2 }) : e2) });
}
function Rn({ children: t2, className: n2 = "", isHovered: i2, ...a2 }) {
  const [s2, c2] = (0, import_react3.useState)(false);
  return (0, import_react3.useEffect)(() => {
    if (!i2) return;
    const e2 = i2.on("change", (e3) => {
      c2(1 === e3);
    });
    return () => e2();
  }, [i2]), (0, import_jsx_runtime.jsx)(AnimatePresence, { children: s2 && (0, import_jsx_runtime.jsx)(motion.div, { initial: { opacity: 0, y: 0 }, animate: { opacity: 1, y: -10 }, exit: { opacity: 0, y: 0 }, transition: { duration: 0.2 }, className: `dock-label ${n2}`, role: "tooltip", style: { x: "-50%" }, children: t2 }) });
}
function In({ children: t2, className: n2 = "" }) {
  return (0, import_jsx_runtime.jsx)("div", { className: `dock-icon ${n2}`, children: t2 });
}
function Ln({ items: i2, className: r2 = "", spring: o2 = { mass: 0.1, stiffness: 150, damping: 12 }, magnification: s2 = 70, distance: c2 = 200, panelHeight: l2 = 68, dockHeight: u2 = 256, baseItemSize: h2 = 50 }) {
  const d2 = useMotionValue(1 / 0), m2 = useMotionValue(0), p2 = (0, import_react3.useMemo)(() => Math.max(u2, s2 + s2 / 2 + 4), [s2, u2]), f2 = useTransform(m2, [0, 1], [l2, p2]), v2 = useSpring(f2, o2);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".dock-outer {\n  margin: 0 0.5rem;\n  display: flex;\n  max-width: 100%;\n  align-items: center;\n}\n\n.dock-panel {\n  position: absolute;\n  bottom: 0.5rem;\n  left: 50%;\n  transform: translateX(-50%);\n  display: flex;\n  align-items: flex-end;\n  width: fit-content;\n  gap: 1rem;\n  border-radius: 1rem;\n  background-color: #060010;\n  border: 1px solid #222;\n  padding: 0 0.5rem 0.5rem;\n}\n\n.dock-item {\n  position: relative;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 10px;\n  background-color: #060010;\n  border: 1px solid #222;\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),\n    0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  cursor: pointer;\n  outline: none;\n}\n\n.dock-icon {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.dock-label {\n  position: absolute;\n  top: -1.5rem;\n  left: 50%;\n  width: fit-content;\n  white-space: pre;\n  border-radius: 0.375rem;\n  border: 1px solid #222;\n  background-color: #060010;\n  padding: 0.125rem 0.5rem;\n  font-size: 0.75rem;\n  color: #fff;\n  transform: translateX(-50%);\n}" }), (0, import_jsx_runtime.jsx)(motion.div, { style: { height: v2, scrollbarWidth: "none" }, className: "dock-outer", children: (0, import_jsx_runtime.jsx)(motion.div, { onMouseMove: ({ pageX: e2 }) => {
    m2.set(1), d2.set(e2);
  }, onMouseLeave: () => {
    m2.set(0), d2.set(1 / 0);
  }, className: `dock-panel ${r2}`, style: { height: l2 }, role: "toolbar", "aria-label": "Application dock", children: i2.map((n2, i3) => (0, import_jsx_runtime.jsxs)(An, { onClick: n2.onClick, className: n2.className, mouseX: d2, spring: o2, distance: c2, magnification: s2, baseItemSize: h2, children: [(0, import_jsx_runtime.jsx)(In, { children: n2.icon }), (0, import_jsx_runtime.jsx)(Rn, { children: n2.label })] }, i3)) }) })] });
}
var Fn = ({ items: a2, animationTime: s2 = 600, particleCount: c2 = 15, particleDistances: l2 = [90, 10], particleR: u2 = 100, timeVariance: h2 = 300, colors: d2 = [1, 2, 3, 1, 2, 3, 1, 4], initialActiveIndex: m2 = 0 }) => {
  const p2 = (0, import_react3.useRef)(null), f2 = (0, import_react3.useRef)(null), v2 = (0, import_react3.useRef)(null), g2 = (0, import_react3.useRef)(null), [x2, y] = (0, import_react3.useState)(m2), w = (e2 = 1) => e2 / 2 - Math.random() * e2, b = (e2, t2, n2) => {
    const i2 = (360 + w(8)) / n2 * t2 * (Math.PI / 180);
    return [e2 * Math.cos(i2), e2 * Math.sin(i2)];
  }, M = (e2, t2, n2, i2) => {
    let r2 = w(i2 / 10);
    return { start: b(n2[0], c2 - e2, c2), end: b(n2[1] + w(7), c2 - e2, c2), time: t2, scale: 1 + w(0.2), color: d2[Math.floor(Math.random() * d2.length)], rotate: r2 > 0 ? 10 * (r2 + i2 / 20) : 10 * (r2 - i2 / 20) };
  }, P = (e2) => {
    if (!p2.current || !v2.current || !g2.current) return;
    const t2 = p2.current.getBoundingClientRect(), n2 = e2.getBoundingClientRect(), i2 = { left: n2.x - t2.x + "px", top: n2.y - t2.y + "px", width: `${n2.width}px`, height: `${n2.height}px` };
    Object.assign(v2.current.style, i2), Object.assign(g2.current.style, i2), g2.current.innerText = e2.innerText;
  }, S = (e2, t2) => {
    const n2 = e2.currentTarget;
    if (x2 !== t2) {
      if (y(t2), P(n2), v2.current) {
        v2.current.querySelectorAll(".particle").forEach((e3) => v2.current.removeChild(e3));
      }
      g2.current && (g2.current.classList.remove("active"), g2.current.offsetWidth, g2.current.classList.add("active")), v2.current && ((e3) => {
        const t3 = l2, n3 = u2, i2 = 2 * s2 + h2;
        e3.style.setProperty("--time", `${i2}ms`);
        for (let i3 = 0; i3 < c2; i3++) {
          const r2 = 2 * s2 + w(2 * h2), o2 = M(i3, r2, t3, n3);
          e3.classList.remove("active"), setTimeout(() => {
            const t4 = document.createElement("span"), n4 = document.createElement("span");
            t4.classList.add("particle"), t4.style.setProperty("--start-x", `${o2.start[0]}px`), t4.style.setProperty("--start-y", `${o2.start[1]}px`), t4.style.setProperty("--end-x", `${o2.end[0]}px`), t4.style.setProperty("--end-y", `${o2.end[1]}px`), t4.style.setProperty("--time", `${o2.time}ms`), t4.style.setProperty("--scale", `${o2.scale}`), t4.style.setProperty("--color", `var(--color-${o2.color}, white)`), t4.style.setProperty("--rotate", `${o2.rotate}deg`), n4.classList.add("point"), t4.appendChild(n4), e3.appendChild(t4), requestAnimationFrame(() => {
              e3.classList.add("active");
            }), setTimeout(() => {
              try {
                e3.removeChild(t4);
              } catch {
              }
            }, r2);
          }, 30);
        }
      })(v2.current);
    }
  };
  return (0, import_react3.useEffect)(() => {
    var _a;
    if (!f2.current || !p2.current) return;
    const e2 = f2.current.querySelectorAll("li")[x2];
    e2 && (P(e2), (_a = g2.current) == null ? void 0 : _a.classList.add("active"));
    const t2 = new ResizeObserver(() => {
      var _a2;
      const e3 = (_a2 = f2.current) == null ? void 0 : _a2.querySelectorAll("li")[x2];
      e3 && P(e3);
    });
    return t2.observe(p2.current), () => t2.disconnect();
  }, [x2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ':root {\n  --linear-ease: linear(0, 0.068, 0.19 2.7%, 0.804 8.1%, 1.037, 1.199 13.2%, 1.245, 1.27 15.8%, 1.274, 1.272 17.4%, 1.249 19.1%, 0.996 28%, 0.949, 0.928 33.3%, 0.926, 0.933 36.8%, 1.001 45.6%, 1.013, 1.019 50.8%, 1.018 54.4%, 1 63.1%, 0.995 68%, 1.001 85%, 1);\n}\n\n.gooey-nav-container {\n  position: relative;\n}\n\n.gooey-nav-container nav {\n  display: flex;\n  position: relative;\n  transform: translate3d(0, 0, 0.01px);\n}\n\n.gooey-nav-container nav ul {\n  display: flex;\n  gap: 2em;\n  list-style: none;\n  padding: 0 1em;\n  margin: 0;\n  position: relative;\n  z-index: 3;\n  color: white;\n  text-shadow: 0 1px 1px hsl(205deg 30% 10% / 0.2);\n}\n\n.gooey-nav-container nav ul li {\n  padding: 0.6em 1em;\n  border-radius: 100vw;\n  position: relative;\n  cursor: pointer;\n  transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;\n  box-shadow: 0 0 0.5px 1.5px transparent;\n  color: white;\n}\n\n.gooey-nav-container nav ul li:focus-within:has(:focus-visible) {\n  box-shadow: 0 0 0.5px 1.5px white;\n}\n\n.gooey-nav-container nav ul li::after {\n  content: "";\n  position: absolute;\n  inset: 0;\n  border-radius: 10px;\n  background: white;\n  opacity: 0;\n  transform: scale(0);\n  transition: all 0.3s ease;\n  z-index: -1;\n}\n\n.gooey-nav-container nav ul li.active {\n  color: black;\n  text-shadow: none;\n}\n\n.gooey-nav-container nav ul li.active::after {\n  opacity: 1;\n  transform: scale(1);\n}\n\n.gooey-nav-container .effect {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n  opacity: 1;\n  pointer-events: none;\n  display: grid;\n  place-items: center;\n  z-index: 1;\n}\n\n.gooey-nav-container .effect.text {\n  color: white;\n  transition: color 0.3s ease;\n}\n\n.gooey-nav-container .effect.text.active {\n  color: black;\n}\n\n.gooey-nav-container .effect.filter {\n  filter: blur(7px) contrast(100) blur(0);\n  mix-blend-mode: lighten;\n}\n\n.gooey-nav-container .effect.filter::before {\n  content: "";\n  position: absolute;\n  inset: -75px;\n  z-index: -2;\n  background: black;\n}\n\n.gooey-nav-container .effect.filter::after {\n  content: "";\n  position: absolute;\n  inset: 0;\n  background: white;\n  transform: scale(0);\n  opacity: 0;\n  z-index: -1;\n  border-radius: 100vw;\n}\n\n.gooey-nav-container .effect.active::after {\n  animation: pill 0.3s ease both;\n}\n\n@keyframes pill {\n  to {\n    transform: scale(1);\n    opacity: 1;\n  }\n}\n\n.particle,\n.point {\n  display: block;\n  opacity: 0;\n  width: 20px;\n  height: 20px;\n  border-radius: 100%;\n  transform-origin: center;\n}\n\n.particle {\n  --time: 5s;\n  position: absolute;\n  top: calc(50% - 8px);\n  left: calc(50% - 8px);\n  animation: particle calc(var(--time)) ease 1 -350ms;\n}\n\n.point {\n  background: var(--color);\n  opacity: 1;\n  animation: point calc(var(--time)) ease 1 -350ms;\n}\n\n@keyframes particle {\n  0% {\n    transform: rotate(0deg) translate(calc(var(--start-x)), calc(var(--start-y)));\n    opacity: 1;\n    animation-timing-function: cubic-bezier(0.55, 0, 1, 0.45);\n  }\n\n  70% {\n    transform: rotate(calc(var(--rotate) * 0.5)) translate(calc(var(--end-x) * 1.2), calc(var(--end-y) * 1.2));\n    opacity: 1;\n    animation-timing-function: ease;\n  }\n\n  85% {\n    transform: rotate(calc(var(--rotate) * 0.66)) translate(calc(var(--end-x)), calc(var(--end-y)));\n    opacity: 1;\n  }\n\n  100% {\n    transform: rotate(calc(var(--rotate) * 1.2)) translate(calc(var(--end-x) * 0.5), calc(var(--end-y) * 0.5));\n    opacity: 1;\n  }\n}\n\n@keyframes point {\n  0% {\n    transform: scale(0);\n    opacity: 0;\n    animation-timing-function: cubic-bezier(0.55, 0, 1, 0.45);\n  }\n\n  25% {\n    transform: scale(calc(var(--scale) * 0.25));\n  }\n\n  38% {\n    opacity: 1;\n  }\n\n  65% {\n    transform: scale(var(--scale));\n    opacity: 1;\n    animation-timing-function: ease;\n  }\n\n  85% {\n    transform: scale(var(--scale));\n    opacity: 1;\n  }\n\n  100% {\n    transform: scale(0);\n    opacity: 0;\n  }\n}' }), (0, import_jsx_runtime.jsxs)("div", { className: "gooey-nav-container", ref: p2, children: [(0, import_jsx_runtime.jsx)("nav", { children: (0, import_jsx_runtime.jsx)("ul", { ref: f2, children: a2.map((t2, n2) => (0, import_jsx_runtime.jsx)("li", { className: x2 === n2 ? "active" : "", onClick: (e2) => S(e2, n2), children: (0, import_jsx_runtime.jsx)("a", { href: t2.href, onKeyDown: (e2) => ((e3, t3) => {
    if ("Enter" === e3.key || " " === e3.key) {
      e3.preventDefault();
      const n3 = e3.currentTarget.parentElement;
      n3 && S({ currentTarget: n3 }, t3);
    }
  })(e2, n2), children: t2.label }) }, n2)) }) }), (0, import_jsx_runtime.jsx)("span", { className: "effect filter", ref: v2 }), (0, import_jsx_runtime.jsx)("span", { className: "effect text", ref: g2 })] })] });
};
var kn = class {
  constructor(e2, t2, n2, i2, r2, o2, a2) {
    this.width = e2.width, this.height = e2.height, this.ctx = t2, this.x = n2, this.y = i2, this.color = r2, this.speed = this.getRandomValue(0.1, 0.9) * o2, this.size = 0, this.sizeStep = 0.4 * Math.random(), this.minSize = 0.5, this.maxSizeInteger = 2, this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger), this.delay = a2, this.counter = 0, this.counterStep = 4 * Math.random() + 0.01 * (this.width + this.height), this.isIdle = false, this.isReverse = false, this.isShimmer = false;
  }
  getRandomValue(e2, t2) {
    return Math.random() * (t2 - e2) + e2;
  }
  draw() {
    const e2 = 0.5 * this.maxSizeInteger - 0.5 * this.size;
    this.ctx.fillStyle = this.color, this.ctx.fillRect(this.x + e2, this.y + e2, this.size, this.size);
  }
  appear() {
    this.isIdle = false, this.counter <= this.delay ? this.counter += this.counterStep : (this.size >= this.maxSize && (this.isShimmer = true), this.isShimmer ? this.shimmer() : this.size += this.sizeStep, this.draw());
  }
  disappear() {
    this.isShimmer = false, this.counter = 0, this.size <= 0 ? this.isIdle = true : (this.size -= 0.1, this.draw());
  }
  shimmer() {
    this.size >= this.maxSize ? this.isReverse = true : this.size <= this.minSize && (this.isReverse = false), this.isReverse ? this.size -= this.speed : this.size += this.speed;
  }
};
function Dn(e2, t2) {
  return e2 <= 0 || t2 ? 0 : e2 >= 100 ? 0.1 : 1e-3 * e2;
}
var Nn = { default: { activeColor: null, gap: 5, speed: 35, colors: "#f8fafc,#f1f5f9,#cbd5e1", noFocus: false }, blue: { activeColor: "#e0f2fe", gap: 10, speed: 25, colors: "#e0f2fe,#7dd3fc,#0ea5e9", noFocus: false }, yellow: { activeColor: "#fef08a", gap: 3, speed: 20, colors: "#fef08a,#fde047,#eab308", noFocus: false }, pink: { activeColor: "#fecdd3", gap: 6, speed: 80, colors: "#fecdd3,#fda4af,#e11d48", noFocus: true } };
function Bn({ variant: o2 = "default", gap: a2, speed: s2, colors: c2, noFocus: l2, className: u2 = "", children: h2 }) {
  const d2 = (0, import_react3.useRef)(null), m2 = (0, import_react3.useRef)(null), p2 = (0, import_react3.useRef)([]), f2 = (0, import_react3.useRef)(null), v2 = (0, import_react3.useRef)(performance.now()), g2 = (0, import_react3.useRef)(window.matchMedia("(prefers-reduced-motion: reduce)").matches).current, x2 = Nn[o2] || Nn.default, y = a2 ?? x2.gap, w = s2 ?? x2.speed, b = c2 ?? x2.colors, M = l2 ?? x2.noFocus, P = () => {
    if (!d2.current || !m2.current) return;
    const e2 = d2.current.getBoundingClientRect(), t2 = Math.floor(e2.width), n2 = Math.floor(e2.height), i2 = m2.current.getContext("2d");
    m2.current.width = t2, m2.current.height = n2, m2.current.style.width = `${t2}px`, m2.current.style.height = `${n2}px`;
    const r2 = b.split(","), o3 = [];
    for (let e3 = 0; e3 < t2; e3 += parseInt(y.toString(), 10)) for (let a3 = 0; a3 < n2; a3 += parseInt(y.toString(), 10)) {
      const s3 = r2[Math.floor(Math.random() * r2.length)], c3 = e3 - t2 / 2, l3 = a3 - n2 / 2, u3 = Math.sqrt(c3 * c3 + l3 * l3), h3 = g2 ? 0 : u3;
      if (!i2) return;
      o3.push(new kn(m2.current, i2, e3, a3, s3, Dn(w, g2), h3));
    }
    p2.current = o3;
  }, S = (e2) => {
    var _a;
    f2.current = requestAnimationFrame(() => S(e2));
    const t2 = performance.now(), n2 = t2 - v2.current, i2 = 1e3 / 60;
    if (n2 < i2) return;
    v2.current = t2 - n2 % i2;
    const r2 = (_a = m2.current) == null ? void 0 : _a.getContext("2d");
    if (!r2 || !m2.current) return;
    r2.clearRect(0, 0, m2.current.width, m2.current.height);
    let o3 = true;
    for (let t3 = 0; t3 < p2.current.length; t3++) {
      const n3 = p2.current[t3];
      n3[e2](), n3.isIdle || (o3 = false);
    }
    o3 && cancelAnimationFrame(f2.current);
  }, C = (e2) => {
    null !== f2.current && cancelAnimationFrame(f2.current), f2.current = requestAnimationFrame(() => S(e2));
  };
  return (0, import_react3.useEffect)(() => {
    P();
    const e2 = new ResizeObserver(() => {
      P();
    });
    return d2.current && e2.observe(d2.current), () => {
      e2.disconnect(), null !== f2.current && cancelAnimationFrame(f2.current);
    };
  }, [y, w, b, M]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: '.pixel-canvas {\n  width: 100%;\n  height: 100%;\n  display: block;\n}\n\n.pixel-card {\n  height: 400px;\n  width: 300px;\n  position: relative;\n  overflow: hidden;\n  display: grid;\n  place-items: center;\n  aspect-ratio: 4 / 5;\n  border: 1px solid #27272a;\n  border-radius: 25px;\n  isolation: isolate;\n  transition: border-color 200ms cubic-bezier(0.5, 1, 0.89, 1);\n  user-select: none;\n}\n\n.pixel-card::before {\n  content: "";\n  position: absolute;\n  inset: 0;\n  margin: auto;\n  aspect-ratio: 1;\n  background: radial-gradient(circle, #09090b, transparent 85%);\n  opacity: 0;\n  transition: opacity 800ms cubic-bezier(0.5, 1, 0.89, 1);\n}\n\n.pixel-card:hover::before,\n.pixel-card:focus-within::before {\n  opacity: 1;\n}\n' }), (0, import_jsx_runtime.jsxs)("div", { ref: d2, className: `pixel-card ${u2}`, onMouseEnter: () => C("appear"), onMouseLeave: () => C("disappear"), onFocus: M ? void 0 : (e2) => {
    e2.currentTarget.contains(e2.relatedTarget) || C("appear");
  }, onBlur: M ? void 0 : (e2) => {
    e2.currentTarget.contains(e2.relatedTarget) || C("disappear");
  }, tabIndex: M ? -1 : 0, children: [(0, import_jsx_runtime.jsx)("canvas", { className: "pixel-canvas", ref: m2 }), h2] })] });
}
function Un(e2, t2, n2 = "bold 30px monospace", i2 = "black") {
  const r2 = document.createElement("canvas"), o2 = r2.getContext("2d");
  if (!o2) throw new Error("Could not get 2d context");
  o2.font = n2;
  const a2 = o2.measureText(t2), s2 = Math.ceil(a2.width), c2 = function(e3) {
    const t3 = e3.match(/(\d+)px/);
    return t3 ? parseInt(t3[1], 10) : 30;
  }(n2), l2 = Math.ceil(1.2 * c2);
  r2.width = s2 + 20, r2.height = l2 + 20, o2.font = n2, o2.fillStyle = i2, o2.textBaseline = "middle", o2.textAlign = "center", o2.clearRect(0, 0, r2.width, r2.height), o2.fillText(t2, r2.width / 2, r2.height / 2);
  const u2 = new Texture(e2, { generateMipmaps: false });
  return u2.image = r2, { texture: u2, width: r2.width, height: r2.height };
}
var On = class {
  constructor({ gl: e2, plane: t2, renderer: n2, text: i2, textColor: r2 = "#545050", font: o2 = "30px sans-serif" }) {
    !function(e3) {
      const t3 = Object.getPrototypeOf(e3);
      Object.getOwnPropertyNames(t3).forEach((t4) => {
        "constructor" !== t4 && "function" == typeof e3[t4] && (e3[t4] = e3[t4].bind(e3));
      });
    }(this), this.gl = e2, this.plane = t2, this.renderer = n2, this.text = i2, this.textColor = r2, this.font = o2, this.createMesh();
  }
  createMesh() {
    const { texture: e2, width: t2, height: n2 } = Un(this.gl, this.text, this.font, this.textColor), i2 = new Plane(this.gl), r2 = new Program(this.gl, { vertex: "\n        attribute vec3 position;\n        attribute vec2 uv;\n        uniform mat4 modelViewMatrix;\n        uniform mat4 projectionMatrix;\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ", fragment: "\n        precision highp float;\n        uniform sampler2D tMap;\n        varying vec2 vUv;\n        void main() {\n          vec4 color = texture2D(tMap, vUv);\n          if (color.a < 0.1) discard;\n          gl_FragColor = color;\n        }\n      ", uniforms: { tMap: { value: e2 } }, transparent: true });
    this.mesh = new Mesh(this.gl, { geometry: i2, program: r2 });
    const o2 = t2 / n2, a2 = 0.15 * this.plane.scale.y, s2 = a2 * o2;
    this.mesh.scale.set(s2, a2, 1), this.mesh.position.y = 0.5 * -this.plane.scale.y - 0.5 * a2 - 0.05, this.mesh.setParent(this.plane);
  }
};
var Vn = class {
  constructor({ geometry: e2, gl: t2, image: n2, index: i2, length: r2, renderer: o2, scene: a2, screen: s2, text: c2, viewport: l2, bend: u2, textColor: h2, borderRadius: d2 = 0, font: m2 }) {
    this.extra = 0, this.speed = 0, this.isBefore = false, this.isAfter = false, this.geometry = e2, this.gl = t2, this.image = n2, this.index = i2, this.length = r2, this.renderer = o2, this.scene = a2, this.screen = s2, this.text = c2, this.viewport = l2, this.bend = u2, this.textColor = h2, this.borderRadius = d2, this.font = m2, this.createShader(), this.createMesh(), this.createTitle(), this.onResize();
  }
  createShader() {
    const e2 = new Texture(this.gl, { generateMipmaps: false });
    this.program = new Program(this.gl, { depthTest: false, depthWrite: false, vertex: "\n        precision highp float;\n        attribute vec3 position;\n        attribute vec2 uv;\n        uniform mat4 modelViewMatrix;\n        uniform mat4 projectionMatrix;\n        uniform float uTime;\n        uniform float uSpeed;\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          vec3 p = position;\n          p.z = (sin(p.x * 4.0 + uTime) * 1.5 + cos(p.y * 2.0 + uTime) * 1.5) * (0.1 + uSpeed * 0.5);\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);\n        }\n      ", fragment: "\n        precision highp float;\n        uniform vec2 uImageSizes;\n        uniform vec2 uPlaneSizes;\n        uniform sampler2D tMap;\n        uniform float uBorderRadius;\n        varying vec2 vUv;\n        \n        float roundedBoxSDF(vec2 p, vec2 b, float r) {\n          vec2 d = abs(p) - b;\n          return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0) - r;\n        }\n        \n        void main() {\n          vec2 ratio = vec2(\n            min((uPlaneSizes.x / uPlaneSizes.y) / (uImageSizes.x / uImageSizes.y), 1.0),\n            min((uPlaneSizes.y / uPlaneSizes.x) / (uImageSizes.y / uImageSizes.x), 1.0)\n          );\n          vec2 uv = vec2(\n            vUv.x * ratio.x + (1.0 - ratio.x) * 0.5,\n            vUv.y * ratio.y + (1.0 - ratio.y) * 0.5\n          );\n          vec4 color = texture2D(tMap, uv);\n          \n          float d = roundedBoxSDF(vUv - 0.5, vec2(0.5 - uBorderRadius), uBorderRadius);\n          if(d > 0.0) {\n            discard;\n          }\n          \n          gl_FragColor = vec4(color.rgb, 1.0);\n        }\n      ", uniforms: { tMap: { value: e2 }, uPlaneSizes: { value: [0, 0] }, uImageSizes: { value: [0, 0] }, uSpeed: { value: 0 }, uTime: { value: 100 * Math.random() }, uBorderRadius: { value: this.borderRadius } }, transparent: true });
    const t2 = new Image();
    t2.crossOrigin = "anonymous", t2.src = this.image, t2.onload = () => {
      e2.image = t2, this.program.uniforms.uImageSizes.value = [t2.naturalWidth, t2.naturalHeight];
    };
  }
  createMesh() {
    this.plane = new Mesh(this.gl, { geometry: this.geometry, program: this.program }), this.plane.setParent(this.scene);
  }
  createTitle() {
    this.title = new On({ gl: this.gl, plane: this.plane, renderer: this.renderer, text: this.text, textColor: this.textColor, font: this.font });
  }
  update(e2, t2) {
    this.plane.position.x = this.x - e2.current - this.extra;
    const n2 = this.plane.position.x, i2 = this.viewport.width / 2;
    if (0 === this.bend) this.plane.position.y = 0, this.plane.rotation.z = 0;
    else {
      const e3 = Math.abs(this.bend), t3 = (i2 * i2 + e3 * e3) / (2 * e3), r3 = Math.min(Math.abs(n2), i2), o3 = t3 - Math.sqrt(t3 * t3 - r3 * r3);
      this.bend > 0 ? (this.plane.position.y = -o3, this.plane.rotation.z = -Math.sign(n2) * Math.asin(r3 / t3)) : (this.plane.position.y = o3, this.plane.rotation.z = Math.sign(n2) * Math.asin(r3 / t3));
    }
    this.speed = e2.current - e2.last, this.program.uniforms.uTime.value += 0.04, this.program.uniforms.uSpeed.value = this.speed;
    const r2 = this.plane.scale.x / 2, o2 = this.viewport.width / 2;
    this.isBefore = this.plane.position.x + r2 < -o2, this.isAfter = this.plane.position.x - r2 > o2, "right" === t2 && this.isBefore && (this.extra -= this.widthTotal, this.isBefore = this.isAfter = false), "left" === t2 && this.isAfter && (this.extra += this.widthTotal, this.isBefore = this.isAfter = false);
  }
  onResize({ screen: e2, viewport: t2 } = {}) {
    e2 && (this.screen = e2), t2 && (this.viewport = t2, this.plane.program.uniforms.uViewportSizes && (this.plane.program.uniforms.uViewportSizes.value = [this.viewport.width, this.viewport.height])), this.scale = this.screen.height / 1500, this.plane.scale.y = this.viewport.height * (900 * this.scale) / this.screen.height, this.plane.scale.x = this.viewport.width * (700 * this.scale) / this.screen.width, this.plane.program.uniforms.uPlaneSizes.value = [this.plane.scale.x, this.plane.scale.y], this.padding = 2, this.width = this.plane.scale.x + this.padding, this.widthTotal = this.width * this.length, this.x = this.width * this.index;
  }
};
var Xn = class {
  constructor(e2, { items: t2, bend: n2 = 1, textColor: i2 = "#ffffff", borderRadius: r2 = 0, font: o2 = "bold 30px Figtree" }) {
    this.medias = [], this.mediasImages = [], this.raf = 0, this.isDown = false, this.start = 0, document.documentElement.classList.remove("no-js"), this.container = e2, this.scroll = { ease: 0.05, current: 0, target: 0, last: 0 }, this.onCheckDebounce = /* @__PURE__ */ function(e3, t3) {
      let n3;
      return function(...i3) {
        window.clearTimeout(n3), n3 = window.setTimeout(() => e3.apply(this, i3), t3);
      };
    }(this.onCheck.bind(this), 200), this.createRenderer(), this.createCamera(), this.createScene(), this.onResize(), this.createGeometry(), this.createMedias(t2, n2, i2, r2, o2), this.update(), this.addEventListeners();
  }
  createRenderer() {
    this.renderer = new Renderer({ alpha: true }), this.gl = this.renderer.gl, this.gl.clearColor(0, 0, 0, 0), this.container.appendChild(this.renderer.gl.canvas);
  }
  createCamera() {
    this.camera = new Camera(this.gl), this.camera.fov = 45, this.camera.position.z = 20;
  }
  createScene() {
    this.scene = new Transform();
  }
  createGeometry() {
    this.planeGeometry = new Plane(this.gl, { heightSegments: 50, widthSegments: 100 });
  }
  createMedias(e2, t2 = 1, n2, i2, r2) {
    const o2 = [{ image: "https://picsum.photos/seed/1/800/600?grayscale", text: "Bridge" }, { image: "https://picsum.photos/seed/2/800/600?grayscale", text: "Desk Setup" }, { image: "https://picsum.photos/seed/3/800/600?grayscale", text: "Waterfall" }, { image: "https://picsum.photos/seed/4/800/600?grayscale", text: "Strawberries" }, { image: "https://picsum.photos/seed/5/800/600?grayscale", text: "Deep Diving" }, { image: "https://picsum.photos/seed/16/800/600?grayscale", text: "Train Track" }, { image: "https://picsum.photos/seed/17/800/600?grayscale", text: "Santorini" }, { image: "https://picsum.photos/seed/8/800/600?grayscale", text: "Blurry Lights" }, { image: "https://picsum.photos/seed/9/800/600?grayscale", text: "New York" }, { image: "https://picsum.photos/seed/10/800/600?grayscale", text: "Good Boy" }, { image: "https://picsum.photos/seed/21/800/600?grayscale", text: "Coastline" }, { image: "https://picsum.photos/seed/12/800/600?grayscale", text: "Palm Trees" }], a2 = e2 && e2.length ? e2 : o2;
    this.mediasImages = a2.concat(a2), this.medias = this.mediasImages.map((e3, o3) => new Vn({ geometry: this.planeGeometry, gl: this.gl, image: e3.image, index: o3, length: this.mediasImages.length, renderer: this.renderer, scene: this.scene, screen: this.screen, text: e3.text, viewport: this.viewport, bend: t2, textColor: n2, borderRadius: i2, font: r2 }));
  }
  onTouchDown(e2) {
    this.isDown = true, this.scroll.position = this.scroll.current, this.start = "touches" in e2 ? e2.touches[0].clientX : e2.clientX;
  }
  onTouchMove(e2) {
    if (!this.isDown) return;
    const t2 = "touches" in e2 ? e2.touches[0].clientX : e2.clientX, n2 = 0.05 * (this.start - t2);
    this.scroll.target = (this.scroll.position ?? 0) + n2;
  }
  onTouchUp() {
    this.isDown = false, this.onCheck();
  }
  onWheel() {
    this.scroll.target += 2, this.onCheckDebounce();
  }
  onCheck() {
    if (!this.medias || !this.medias[0]) return;
    const e2 = this.medias[0].width, t2 = e2 * Math.round(Math.abs(this.scroll.target) / e2);
    this.scroll.target = this.scroll.target < 0 ? -t2 : t2;
  }
  onResize() {
    this.screen = { width: this.container.clientWidth, height: this.container.clientHeight }, this.renderer.setSize(this.screen.width, this.screen.height), this.camera.perspective({ aspect: this.screen.width / this.screen.height });
    const e2 = this.camera.fov * Math.PI / 180, t2 = 2 * Math.tan(e2 / 2) * this.camera.position.z, n2 = t2 * this.camera.aspect;
    this.viewport = { width: n2, height: t2 }, this.medias && this.medias.forEach((e3) => e3.onResize({ screen: this.screen, viewport: this.viewport }));
  }
  update() {
    var e2, t2, n2;
    this.scroll.current = (e2 = this.scroll.current, t2 = this.scroll.target, n2 = this.scroll.ease, e2 + (t2 - e2) * n2);
    const i2 = this.scroll.current > this.scroll.last ? "right" : "left";
    this.medias && this.medias.forEach((e3) => e3.update(this.scroll, i2)), this.renderer.render({ scene: this.scene, camera: this.camera }), this.scroll.last = this.scroll.current, this.raf = window.requestAnimationFrame(this.update.bind(this));
  }
  addEventListeners() {
    this.boundOnResize = this.onResize.bind(this), this.boundOnWheel = this.onWheel.bind(this), this.boundOnTouchDown = this.onTouchDown.bind(this), this.boundOnTouchMove = this.onTouchMove.bind(this), this.boundOnTouchUp = this.onTouchUp.bind(this), window.addEventListener("resize", this.boundOnResize), window.addEventListener("mousewheel", this.boundOnWheel), window.addEventListener("wheel", this.boundOnWheel), window.addEventListener("mousedown", this.boundOnTouchDown), window.addEventListener("mousemove", this.boundOnTouchMove), window.addEventListener("mouseup", this.boundOnTouchUp), window.addEventListener("touchstart", this.boundOnTouchDown), window.addEventListener("touchmove", this.boundOnTouchMove), window.addEventListener("touchend", this.boundOnTouchUp);
  }
  destroy() {
    window.cancelAnimationFrame(this.raf), window.removeEventListener("resize", this.boundOnResize), window.removeEventListener("mousewheel", this.boundOnWheel), window.removeEventListener("wheel", this.boundOnWheel), window.removeEventListener("mousedown", this.boundOnTouchDown), window.removeEventListener("mousemove", this.boundOnTouchMove), window.removeEventListener("mouseup", this.boundOnTouchUp), window.removeEventListener("touchstart", this.boundOnTouchDown), window.removeEventListener("touchmove", this.boundOnTouchMove), window.removeEventListener("touchend", this.boundOnTouchUp), this.renderer && this.renderer.gl && this.renderer.gl.canvas.parentNode && this.renderer.gl.canvas.parentNode.removeChild(this.renderer.gl.canvas);
  }
};
function qn({ items: o2, bend: a2 = 3, textColor: s2 = "#ffffff", borderRadius: c2 = 0.05, font: l2 = "bold 30px Figtree" }) {
  const u2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    if (!u2.current) return;
    const e2 = new Xn(u2.current, { items: o2, bend: a2, textColor: s2, borderRadius: c2, font: l2 });
    return () => {
      e2.destroy();
    };
  }, [o2, a2, s2, c2, l2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".circular-gallery {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  cursor: grab;\n}\n\n.circular-gallery:active {\n  cursor: grabbing;\n}" }), (0, import_jsx_runtime.jsx)("div", { className: "circular-gallery", ref: u2 })] });
}
var Yn = [{ title: "Text Animations", description: "Cool text animations for your projects.", id: 1, icon: (0, import_jsx_runtime.jsx)(FiFileText, { className: "carousel-icon" }) }, { title: "Animations", description: "Smooth animations for your projects.", id: 2, icon: (0, import_jsx_runtime.jsx)(FiCircle, { className: "carousel-icon" }) }, { title: "Components", description: "Reusable components for your projects.", id: 3, icon: (0, import_jsx_runtime.jsx)(FiLayers, { className: "carousel-icon" }) }, { title: "Backgrounds", description: "Beautiful backgrounds and patterns for your projects.", id: 4, icon: (0, import_jsx_runtime.jsx)(FiLayout, { className: "carousel-icon" }) }, { title: "Common UI", description: "Common UI components are coming soon!", id: 5, icon: (0, import_jsx_runtime.jsx)(FiCode, { className: "carousel-icon" }) }];
var $n = { type: "spring", stiffness: 300, damping: 30 };
function Wn({ items: a2 = Yn, baseWidth: s2 = 300, autoplay: c2 = false, autoplayDelay: l2 = 3e3, pauseOnHover: u2 = false, loop: h2 = false, round: d2 = false }) {
  const m2 = s2 - 32, p2 = m2 + 16, f2 = h2 ? [...a2, a2[0]] : a2, [v2, g2] = (0, import_react3.useState)(0), x2 = useMotionValue(0), [w, M] = (0, import_react3.useState)(false), [P, S] = (0, import_react3.useState)(false), C = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    if (u2 && C.current) {
      const e2 = C.current, t2 = () => M(true), n2 = () => M(false);
      return e2.addEventListener("mouseenter", t2), e2.addEventListener("mouseleave", n2), () => {
        e2.removeEventListener("mouseenter", t2), e2.removeEventListener("mouseleave", n2);
      };
    }
  }, [u2]), (0, import_react3.useEffect)(() => {
    if (c2 && (!u2 || !w)) {
      const e2 = setInterval(() => {
        g2((e3) => e3 === a2.length - 1 && h2 ? e3 + 1 : e3 === f2.length - 1 ? h2 ? 0 : e3 : e3 + 1);
      }, l2);
      return () => clearInterval(e2);
    }
  }, [c2, l2, w, h2, a2.length, f2.length, u2]);
  const z = P ? { duration: 0 } : $n, _ = h2 ? {} : { dragConstraints: { left: -p2 * (f2.length - 1), right: 0 } };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".carousel-container {\n  position: relative;\n  overflow: hidden;\n  border: 1px solid #555;\n  border-radius: 24px;\n  padding: 16px;\n  --outer-r: 24px;\n  --p-distance: 12px;\n}\n\n.carousel-track {\n  display: flex;\n}\n\n.carousel-item {\n  position: relative;\n  display: flex;\n  flex-shrink: 0;\n  flex-direction: column;\n  align-items: flex-start;\n  justify-content: space-between;\n  border: 1px solid #555;\n  border-radius: calc(var(--outer-r) - var(--p-distance));\n  background-color: #0D0716;\n  overflow: hidden;\n  cursor: grab;\n}\n\n.carousel-item:active {\n  cursor: grabbing;\n}\n\n.carousel-container.round {\n  border: 1px solid #555;\n}\n\n.carousel-item.round {\n  background-color: #0D0716;\n  position: relative;\n  bottom: .1em;\n  border: 1px solid #555;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n}\n\n.carousel-item-header.round {\n  padding: 0;\n  margin: 0;\n}\n\n.carousel-indicators-container.round {\n  position: absolute;\n  z-index: 2;\n  bottom: 3em;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.carousel-indicator.active {\n  background-color: #333333;\n}\n\n.carousel-indicator.inactive {\n  background-color: rgba(51, 51, 51, 0.4);\n}\n\n.carousel-item-header {\n  margin-bottom: 16px;\n  padding: 20px;\n  padding-top: 20px;\n}\n\n.carousel-icon-container {\n  display: flex;\n  height: 28px;\n  width: 28px;\n  align-items: center;\n  justify-content: center;\n  border-radius: 50%;\n  background-color: #fff;\n}\n\n.carousel-icon {\n  height: 16px;\n  width: 16px;\n  color: #060010;\n}\n\n.carousel-item-content {\n  padding: 20px;\n  padding-bottom: 20px;\n}\n\n.carousel-item-title {\n  margin-bottom: 4px;\n  font-weight: 900;\n  font-size: 18px;\n  color: #fff;\n}\n\n.carousel-item-description {\n  font-size: 14px;\n  color: #fff;\n}\n\n.carousel-indicators-container {\n  display: flex;\n  width: 100%;\n  justify-content: center;\n}\n\n.carousel-indicators {\n  margin-top: 16px;\n  display: flex;\n  width: 150px;\n  justify-content: space-between;\n  padding: 0 32px;\n}\n\n.carousel-indicator {\n  height: 8px;\n  width: 8px;\n  border-radius: 50%;\n  cursor: pointer;\n  transition: background-color 150ms;\n}\n\n.carousel-indicator.active {\n  background-color: #fff;\n}\n\n.carousel-indicator.inactive {\n  background-color: #555;\n}" }), (0, import_jsx_runtime.jsxs)("div", { ref: C, className: "carousel-container " + (d2 ? "round" : ""), style: { width: `${s2}px`, ...d2 && { height: `${s2}px`, borderRadius: "50%" } }, children: [(0, import_jsx_runtime.jsx)(motion.div, { className: "carousel-track", drag: "x", ..._, style: { width: m2, gap: "16px", perspective: 1e3, perspectiveOrigin: v2 * p2 + m2 / 2 + "px 50%", x: x2 }, onDragEnd: (e2, t2) => {
    const n2 = t2.offset.x, i2 = t2.velocity.x;
    n2 < -0 || i2 < -500 ? h2 && v2 === a2.length - 1 ? g2(v2 + 1) : g2((e3) => Math.min(e3 + 1, f2.length - 1)) : (n2 > 0 || i2 > 500) && g2(h2 && 0 === v2 ? a2.length - 1 : (e3) => Math.max(e3 - 1, 0));
  }, animate: { x: -v2 * p2 }, transition: z, onAnimationComplete: () => {
    h2 && v2 === f2.length - 1 && (S(true), x2.set(0), g2(0), setTimeout(() => S(false), 50));
  }, children: f2.map((n2, i2) => {
    const r2 = useTransform(x2, [-(i2 + 1) * p2, -i2 * p2, -(i2 - 1) * p2], [90, 0, -90], { clamp: false });
    return (0, import_jsx_runtime.jsxs)(motion.div, { className: "carousel-item " + (d2 ? "round" : ""), style: { width: m2, height: d2 ? m2 : "100%", rotateY: r2, ...d2 && { borderRadius: "50%" } }, transition: z, children: [(0, import_jsx_runtime.jsx)("div", { className: "carousel-item-header " + (d2 ? "round" : ""), children: (0, import_jsx_runtime.jsx)("span", { className: "carousel-icon-container", children: n2.icon }) }), (0, import_jsx_runtime.jsxs)("div", { className: "carousel-item-content", children: [(0, import_jsx_runtime.jsx)("div", { className: "carousel-item-title", children: n2.title }), (0, import_jsx_runtime.jsx)("p", { className: "carousel-item-description", children: n2.description })] })] }, i2);
  }) }), (0, import_jsx_runtime.jsx)("div", { className: "carousel-indicators-container " + (d2 ? "round" : ""), children: (0, import_jsx_runtime.jsx)("div", { className: "carousel-indicators", children: a2.map((t2, n2) => (0, import_jsx_runtime.jsx)(motion.div, { className: "carousel-indicator " + (v2 % a2.length === n2 ? "active" : "inactive"), animate: { scale: v2 % a2.length === n2 ? 1.2 : 1 }, onClick: () => g2(n2), transition: { duration: 0.15 } }, n2)) }) })] })] });
}
var Hn = ({ children: r2, className: o2 = "", spotlightColor: a2 = "rgba(255, 255, 255, 0.25)" }) => {
  const s2 = (0, import_react3.useRef)(null);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: '.card-spotlight {\n  position: relative;\n  border-radius: 1.5rem;\n  border: 1px solid #222;\n  background-color: #111;\n  padding: 2rem;\n  overflow: hidden;\n  --mouse-x: 50%;\n  --mouse-y: 50%;\n  --spotlight-color: rgba(255, 255, 255, 0.05);\n}\n\n.card-spotlight::before {\n  content: "";\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: radial-gradient(circle at var(--mouse-x) var(--mouse-y), var(--spotlight-color), transparent 80%);\n  opacity: 0;\n  transition: opacity 0.5s ease;\n  pointer-events: none;\n}\n\n.card-spotlight:hover::before,\n.card-spotlight:focus-within::before {\n  opacity: 0.6;\n}\n' }), (0, import_jsx_runtime.jsx)("div", { ref: s2, onMouseMove: (e2) => {
    if (!s2.current) return;
    const t2 = s2.current.getBoundingClientRect(), n2 = e2.clientX - t2.left, i2 = e2.clientY - t2.top;
    s2.current.style.setProperty("--mouse-x", `${n2}px`), s2.current.style.setProperty("--mouse-y", `${i2}px`), s2.current.style.setProperty("--spotlight-color", a2);
  }, className: `card-spotlight ${o2}`, children: r2 })] });
};
function Gn(e2, { include: t2, exclude: n2 } = {}) {
  const i2 = (e3) => {
    const i3 = (t3) => "string" == typeof t3 ? e3 === t3 : t3.test(e3.toString());
    return t2 ? t2.some(i3) : !n2 || !n2.some(i3);
  };
  for (const [t3, n3] of ((e3) => {
    const t4 = /* @__PURE__ */ new Set();
    do {
      for (const n4 of Reflect.ownKeys(e3)) t4.add([e3, n4]);
    } while ((e3 = Reflect.getPrototypeOf(e3)) && e3 !== Object.prototype);
    return t4;
  })(e2.constructor.prototype)) {
    if ("constructor" === n3 || !i2(n3)) continue;
    const r2 = Reflect.getOwnPropertyDescriptor(t3, n3);
    r2 && "function" == typeof r2.value && (e2[n3] = e2[n3].bind(e2));
  }
  return e2;
}
var jn = class {
  constructor({ gl: e2, geometry: t2, scene: n2, screen: i2, viewport: r2, image: o2, length: a2, index: s2, planeWidth: c2, planeHeight: l2, distortion: u2 }) {
    this.extra = 0, this.padding = 0, this.height = 0, this.heightTotal = 0, this.y = 0, this.gl = e2, this.geometry = t2, this.scene = n2, this.screen = i2, this.viewport = r2, this.image = o2, this.length = a2, this.index = s2, this.planeWidth = c2, this.planeHeight = l2, this.distortion = u2, this.createShader(), this.createMesh(), this.onResize();
  }
  createShader() {
    const e2 = new Texture(this.gl, { generateMipmaps: false });
    this.program = new Program(this.gl, { depthTest: false, depthWrite: false, fragment: "\nprecision highp float;\n\nuniform vec2 uImageSize;\nuniform vec2 uPlaneSize;\nuniform sampler2D tMap;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 imageSize = uImageSize;\n  vec2 planeSize = uPlaneSize;\n\n  float imageAspect = imageSize.x / imageSize.y;\n  float planeAspect = planeSize.x / planeSize.y;\n  vec2 scale = vec2(1.0, 1.0);\n\n  if (planeAspect > imageAspect) {\n      scale.x = imageAspect / planeAspect;\n  } else {\n      scale.y = planeAspect / imageAspect;\n  }\n\n  vec2 uv = vUv * scale + (1.0 - scale) * 0.5;\n\n  gl_FragColor = texture2D(tMap, uv);\n}\n", vertex: "\nprecision highp float;\n\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n\nuniform float uPosition;\nuniform float uTime;\nuniform float uSpeed;\nuniform vec3 distortionAxis;\nuniform vec3 rotationAxis;\nuniform float uDistortion;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\n\nfloat PI = 3.141592653589793238;\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(\n      oc * axis.x * axis.x + c,         oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n      oc * axis.x * axis.y + axis.z * s,oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n      oc * axis.z * axis.x - axis.y * s,oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n      0.0,                              0.0,                                0.0,                                1.0\n    );\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n  mat4 m = rotationMatrix(axis, angle);\n  return (m * vec4(v, 1.0)).xyz;\n}\n\nfloat qinticInOut(float t) {\n  return t < 0.5\n    ? 16.0 * pow(t, 5.0)\n    : -0.5 * abs(pow(2.0 * t - 2.0, 5.0)) + 1.0;\n}\n\nvoid main() {\n  vUv = uv;\n  \n  float norm = 0.5;\n  vec3 newpos = position;\n  float offset = (dot(distortionAxis, position) + norm / 2.) / norm;\n  float localprogress = clamp(\n    (fract(uPosition * 5.0 * 0.01) - 0.01 * uDistortion * offset) / (1. - 0.01 * uDistortion),\n    0.,\n    2.\n  );\n  localprogress = qinticInOut(localprogress) * PI;\n  newpos = rotate(newpos, rotationAxis, localprogress);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newpos, 1.0);\n}\n", uniforms: { tMap: { value: e2 }, uPosition: { value: 0 }, uPlaneSize: { value: [0, 0] }, uImageSize: { value: [0, 0] }, uSpeed: { value: 0 }, rotationAxis: { value: [0, 1, 0] }, distortionAxis: { value: [1, 1, 0] }, uDistortion: { value: this.distortion }, uViewportSize: { value: [this.viewport.width, this.viewport.height] }, uTime: { value: 0 } }, cullFace: false });
    const t2 = new Image();
    t2.crossOrigin = "anonymous", t2.src = this.image, t2.onload = () => {
      e2.image = t2, this.program.uniforms.uImageSize.value = [t2.naturalWidth, t2.naturalHeight];
    };
  }
  createMesh() {
    this.plane = new Mesh(this.gl, { geometry: this.geometry, program: this.program }), this.plane.setParent(this.scene);
  }
  setScale() {
    this.plane.scale.x = this.viewport.width * this.planeWidth / this.screen.width, this.plane.scale.y = this.viewport.height * this.planeHeight / this.screen.height, this.plane.position.x = 0, this.program.uniforms.uPlaneSize.value = [this.plane.scale.x, this.plane.scale.y];
  }
  onResize({ screen: e2, viewport: t2 } = {}) {
    e2 && (this.screen = e2), t2 && (this.viewport = t2, this.program.uniforms.uViewportSize.value = [t2.width, t2.height]), this.setScale(), this.padding = 5, this.height = this.plane.scale.y + this.padding, this.heightTotal = this.height * this.length, this.y = -this.heightTotal / 2 + (this.index + 0.5) * this.height;
  }
  update(e2) {
    this.plane.position.y = this.y - e2.current - this.extra;
    const t2 = function(e3, t3, n3, i3, r3, o3 = false) {
      const a2 = (e3 - t3) / (n3 - t3) * (r3 - i3) + i3;
      return o3 ? Math.round(a2) : a2;
    }(this.plane.position.y, -this.viewport.height, this.viewport.height, 5, 15);
    this.program.uniforms.uPosition.value = t2, this.program.uniforms.uTime.value += 0.04, this.program.uniforms.uSpeed.value = e2.current;
    const n2 = this.plane.scale.y, i2 = this.viewport.height, r2 = this.plane.position.y + n2 / 2, o2 = this.plane.position.y - n2 / 2;
    r2 < -i2 / 2 ? this.extra -= this.heightTotal : o2 > i2 / 2 && (this.extra += this.heightTotal);
  }
};
var Zn = class {
  constructor({ container: e2, canvas: t2, items: n2, planeWidth: i2, planeHeight: r2, distortion: o2, scrollEase: a2, cameraFov: s2, cameraZ: c2 }) {
    this.isDown = false, this.start = 0, this.loaded = 0, this.container = e2, this.canvas = t2, this.items = n2, this.planeWidth = i2, this.planeHeight = r2, this.distortion = o2, this.scroll = { ease: a2, current: 0, target: 0, last: 0 }, this.cameraFov = s2, this.cameraZ = c2, Gn(this), this.createRenderer(), this.createCamera(), this.createScene(), this.onResize(), this.createGeometry(), this.createMedias(), this.update(), this.addEventListeners(), this.createPreloader();
  }
  createRenderer() {
    this.renderer = new Renderer({ canvas: this.canvas, alpha: true, antialias: true, dpr: Math.min(window.devicePixelRatio, 2) }), this.gl = this.renderer.gl;
  }
  createCamera() {
    this.camera = new Camera(this.gl), this.camera.fov = this.cameraFov, this.camera.position.z = this.cameraZ;
  }
  createScene() {
    this.scene = new Transform();
  }
  createGeometry() {
    this.planeGeometry = new Plane(this.gl, { heightSegments: 1, widthSegments: 100 });
  }
  createMedias() {
    this.medias = this.items.map((e2, t2) => new jn({ gl: this.gl, geometry: this.planeGeometry, scene: this.scene, screen: this.screen, viewport: this.viewport, image: e2, length: this.items.length, index: t2, planeWidth: this.planeWidth, planeHeight: this.planeHeight, distortion: this.distortion }));
  }
  createPreloader() {
    this.loaded = 0, this.items.forEach((e2) => {
      const t2 = new Image();
      t2.crossOrigin = "anonymous", t2.src = e2, t2.onload = () => {
        ++this.loaded === this.items.length && (document.documentElement.classList.remove("loading"), document.documentElement.classList.add("loaded"));
      };
    });
  }
  onResize() {
    var _a;
    const e2 = this.container.getBoundingClientRect();
    this.screen = { width: e2.width, height: e2.height }, this.renderer.setSize(this.screen.width, this.screen.height), this.camera.perspective({ aspect: this.gl.canvas.width / this.gl.canvas.height });
    const t2 = this.camera.fov * Math.PI / 180, n2 = 2 * Math.tan(t2 / 2) * this.camera.position.z, i2 = n2 * this.camera.aspect;
    this.viewport = { width: i2, height: n2 }, (_a = this.medias) == null ? void 0 : _a.forEach((e3) => e3.onResize({ screen: this.screen, viewport: this.viewport }));
  }
  onTouchDown(e2) {
    this.isDown = true, this.scroll.position = this.scroll.current, this.start = e2 instanceof TouchEvent ? e2.touches[0].clientY : e2.clientY;
  }
  onTouchMove(e2) {
    if (!this.isDown || !this.scroll.position) return;
    const t2 = e2 instanceof TouchEvent ? e2.touches[0].clientY : e2.clientY, n2 = 0.1 * (this.start - t2);
    this.scroll.target = this.scroll.position + n2;
  }
  onTouchUp() {
    this.isDown = false;
  }
  onWheel(e2) {
    this.scroll.target += 5e-3 * e2.deltaY;
  }
  update() {
    var _a;
    var e2, t2, n2;
    this.scroll.current = (e2 = this.scroll.current, t2 = this.scroll.target, n2 = this.scroll.ease, e2 + (t2 - e2) * n2), (_a = this.medias) == null ? void 0 : _a.forEach((e3) => e3.update(this.scroll)), this.renderer.render({ scene: this.scene, camera: this.camera }), this.scroll.last = this.scroll.current, requestAnimationFrame(this.update);
  }
  addEventListeners() {
    window.addEventListener("resize", this.onResize), window.addEventListener("wheel", this.onWheel), window.addEventListener("mousedown", this.onTouchDown), window.addEventListener("mousemove", this.onTouchMove), window.addEventListener("mouseup", this.onTouchUp), window.addEventListener("touchstart", this.onTouchDown), window.addEventListener("touchmove", this.onTouchMove), window.addEventListener("touchend", this.onTouchUp);
  }
  destroy() {
    window.removeEventListener("resize", this.onResize), window.removeEventListener("wheel", this.onWheel), window.removeEventListener("mousedown", this.onTouchDown), window.removeEventListener("mousemove", this.onTouchMove), window.removeEventListener("mouseup", this.onTouchUp), window.removeEventListener("touchstart", this.onTouchDown), window.removeEventListener("touchmove", this.onTouchMove), window.removeEventListener("touchend", this.onTouchUp);
  }
};
function Kn({ items: o2 = [], planeWidth: a2 = 320, planeHeight: s2 = 320, distortion: c2 = 3, scrollEase: l2 = 0.01, cameraFov: u2 = 45, cameraZ: h2 = 20, className: d2, ...m2 }) {
  const p2 = (0, import_react3.useRef)(null), f2 = (0, import_react3.useRef)(null), v2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    if (p2.current && f2.current) return v2.current = new Zn({ container: p2.current, canvas: f2.current, items: o2, planeWidth: a2, planeHeight: s2, distortion: c2, scrollEase: l2, cameraFov: u2, cameraZ: h2 }), () => {
      var _a;
      (_a = v2.current) == null ? void 0 : _a.destroy(), v2.current = null;
    };
  }, [o2, a2, s2, c2, l2, u2, h2]), (0, import_react3.useEffect)(() => {
    if (!f2.current) return;
    const e2 = f2.current, t2 = (e3) => {
      e3.preventDefault(), v2.current && v2.current.onWheel(e3);
    }, n2 = (e3) => {
      e3.preventDefault();
    };
    return e2.addEventListener("wheel", t2, { passive: false }), e2.addEventListener("touchmove", n2, { passive: false }), () => {
      e2.removeEventListener("wheel", t2), e2.removeEventListener("touchmove", n2);
    };
  }, []), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".posters-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n  z-index: 2;\n}\n\n.posters-canvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: p2, className: `posters-container ${d2 ?? ""}`, ...m2, children: (0, import_jsx_runtime.jsx)("canvas", { ref: f2, className: "posters-canvas" }) })] });
}
(0, import_react3.forwardRef)(({ customClass: t2, ...n2 }, i2) => (0, import_jsx_runtime.jsx)("div", { ref: i2, ...n2, className: `card ${t2 ?? ""} ${n2.className ?? ""}`.trim() })).displayName = "Card";
var Qn = (e2, t2, n2, i2) => ({ x: e2 * t2, y: -e2 * n2, z: -e2 * t2 * 1.5, zIndex: i2 - e2 });
var Jn = ({ width: o2 = 500, height: s2 = 400, cardDistance: c2 = 60, verticalDistance: l2 = 70, delay: u2 = 5e3, pauseOnHover: p2 = false, onCardClick: v2, skewAmount: g2 = 6, easing: x2 = "elastic", children: y }) => {
  const w = "elastic" === x2 ? { ease: "elastic.out(0.6,0.9)", durDrop: 2, durMove: 2, durReturn: 2, promoteOverlap: 0.9, returnDelay: 0.05 } : { ease: "power1.inOut", durDrop: 0.8, durMove: 0.8, durReturn: 0.8, promoteOverlap: 0.45, returnDelay: 0.2 }, b = (0, import_react3.useMemo)(() => import_react3.Children.toArray(y), [y]), M = (0, import_react3.useMemo)(() => b.map(() => import_react3.default.createRef()), [b.length]), P = (0, import_react3.useRef)(Array.from({ length: b.length }, (e2, t2) => t2)), S = (0, import_react3.useRef)(null), C = (0, import_react3.useRef)(void 0), E = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    const e2 = M.length;
    M.forEach((t3, n2) => {
      return i2 = t3.current, r2 = Qn(n2, c2, l2, e2), o3 = g2, import_gsap.default.set(i2, { x: r2.x, y: r2.y, z: r2.z, xPercent: -50, yPercent: -50, skewY: o3, transformOrigin: "center center", zIndex: r2.zIndex, force3D: true });
      var i2, r2, o3;
    });
    const t2 = () => {
      if (P.current.length < 2) return;
      const [e3, ...t3] = P.current, n2 = M[e3].current, i2 = import_gsap.default.timeline();
      S.current = i2, i2.to(n2, { y: "+=500", duration: w.durDrop, ease: w.ease }), i2.addLabel("promote", "-=" + w.durDrop * w.promoteOverlap), t3.forEach((e4, t4) => {
        const n3 = M[e4].current, r3 = Qn(t4, c2, l2, M.length);
        i2.set(n3, { zIndex: r3.zIndex }, "promote"), i2.to(n3, { x: r3.x, y: r3.y, z: r3.z, duration: w.durMove, ease: w.ease }, "promote+=" + 0.15 * t4);
      });
      const r2 = Qn(M.length - 1, c2, l2, M.length);
      i2.addLabel("return", "promote+=" + w.durMove * w.returnDelay), i2.call(() => {
        import_gsap.default.set(n2, { zIndex: r2.zIndex });
      }, void 0, "return"), i2.set(n2, { x: r2.x, z: r2.z }, "return"), i2.to(n2, { y: r2.y, duration: w.durReturn, ease: w.ease }, "return"), i2.call(() => {
        P.current = [...t3, e3];
      });
    };
    if (t2(), C.current = window.setInterval(t2, u2), p2) {
      const e3 = E.current, n2 = () => {
        var _a;
        (_a = S.current) == null ? void 0 : _a.pause(), clearInterval(C.current);
      }, i2 = () => {
        var _a;
        (_a = S.current) == null ? void 0 : _a.play(), C.current = window.setInterval(t2, u2);
      };
      return e3.addEventListener("mouseenter", n2), e3.addEventListener("mouseleave", i2), () => {
        e3.removeEventListener("mouseenter", n2), e3.removeEventListener("mouseleave", i2), clearInterval(C.current);
      };
    }
    return () => clearInterval(C.current);
  }, [c2, l2, u2, p2, g2, x2]);
  const z = b.map((e2, t2) => (0, import_react3.isValidElement)(e2) ? (0, import_react3.cloneElement)(e2, { key: t2, ref: M[t2], style: { width: o2, height: s2, ...e2.props.style ?? {} }, onClick: (n2) => {
    var _a, _b;
    (_b = (_a = e2.props).onClick) == null ? void 0 : _b.call(_a, n2), v2 == null ? void 0 : v2(t2);
  } }) : e2);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".card-swap-container {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  transform: translate(5%, 20%);\n  transform-origin: bottom right;\n\n  perspective: 900px;\n  overflow: visible;\n}\n\n.card {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  border-radius: 12px;\n  border: 1px solid #fff;\n  background: #000;\n\n  transform-style: preserve-3d;\n  will-change: transform;\n  backface-visibility: hidden;\n}\n\n@media (max-width: 768px) {\n  .card-swap-container {\n    transform: scale(0.75) translate(25%, 25%);\n  }\n}\n\n@media (max-width: 480px) {\n  .card-swap-container {\n    transform: scale(0.55) translate(25%, 25%);\n  }\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: E, className: "card-swap-container", style: { width: o2, height: s2 }, children: z })] });
};
(void 0).registerPlugin(void 0);
var ei = ({ width: o2 = "30rem", maxHeight: a2 = "100%", negativeMargin: s2 = "-0.5em", items: c2 = [], itemMinHeight: l2 = 150, isTilted: u2 = false, tiltDirection: h2 = "left", autoplay: d2 = false, autoplaySpeed: m2 = 0.5, autoplayDirection: p2 = "down", pauseOnHover: f2 = false }) => {
  const g2 = (0, import_react3.useRef)(null), x2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = x2.current;
    if (!e2) return;
    if (0 === c2.length) return;
    const t2 = (void 0).utils.toArray(e2.children);
    if (!t2.length) return;
    const n2 = t2[0], i2 = getComputedStyle(n2), r2 = n2.offsetHeight, o3 = parseFloat(i2.marginTop) || 0, a3 = r2 + o3, s3 = r2 * c2.length + o3 * (c2.length - 1), l3 = (void 0).utils.wrap(-s3, s3);
    t2.forEach((e3, t3) => {
      const n3 = t3 * a3;
      (void 0).set(e3, { y: n3 });
    });
    const u3 = (void 0).create({ target: e2, type: "wheel,touch,pointer", preventDefault: true, onPress: ({ target: e3 }) => {
      e3.style.cursor = "grabbing";
    }, onRelease: ({ target: e3 }) => {
      e3.style.cursor = "grab";
    }, onChange: ({ deltaY: e3, isDragging: n3, event: i3 }) => {
      const r3 = "wheel" === i3.type ? -e3 : e3, o4 = n3 ? 5 * r3 : 10 * r3;
      t2.forEach((e4) => {
        (void 0).to(e4, { duration: 0.5, ease: "expo.out", y: `+=${o4}`, modifiers: { y: (void 0).utils.unitize(l3) } });
      });
    } });
    let h3;
    if (d2) {
      const n3 = m2 * ("down" === p2 ? 1 : -1), i3 = () => {
        t2.forEach((e3) => {
          (void 0).set(e3, { y: `+=${n3}`, modifiers: { y: (void 0).utils.unitize(l3) } });
        }), h3 = requestAnimationFrame(i3);
      };
      if (h3 = requestAnimationFrame(i3), f2) {
        const t3 = () => h3 && cancelAnimationFrame(h3), n4 = () => {
          h3 = requestAnimationFrame(i3);
        };
        return e2.addEventListener("mouseenter", t3), e2.addEventListener("mouseleave", n4), () => {
          u3.kill(), t3(), e2.removeEventListener("mouseenter", t3), e2.removeEventListener("mouseleave", n4);
        };
      }
      return () => {
        u3.kill(), h3 && cancelAnimationFrame(h3);
      };
    }
    return () => {
      u3.kill(), h3 && cancelAnimationFrame(h3);
    };
  }, [c2, d2, m2, p2, f2, u2, h2, s2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: `
          .infinite-scroll-wrapper {
            max-height: ${a2};
          }
  
          .infinite-scroll-container {
            width: ${o2};
          }
  
          .infinite-scroll-item {
            height: ${l2}px;
            margin-top: ${s2};
          }

          .infinite-scroll-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  overflow: hidden;
  overscroll-behavior: none;
}

.infinite-scroll-wrapper::before,
.infinite-scroll-wrapper::after {
  content: "";
  position: absolute;
  background: linear-gradient(var(--dir, to bottom), 060010, transparent);
  height: 25%;
  width: 100%;
  z-index: 1;
  pointer-events: none;
}

.infinite-scroll-wrapper::before {
  top: 0;
}

.infinite-scroll-wrapper::after {
  --dir: to top;
  bottom: 0;
}

.infinite-scroll-container {
  display: flex;
  flex-direction: column;
  overscroll-behavior: contain;
  padding-inline: 1rem;
  cursor: grab;
  transform-origin: center center;
}

.infinite-scroll-item {
  --accent-color: #ffffff;
  border-radius: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  font-size: 1.25rem;
  font-weight: 600;
  text-align: center;
  border: 2px solid var(--accent-color);
  user-select: none;
  box-sizing: border-box;
  position: relative;
}
        ` }), (0, import_jsx_runtime.jsx)("div", { className: "infinite-scroll-wrapper", ref: g2, children: (0, import_jsx_runtime.jsx)("div", { className: "infinite-scroll-container", ref: x2, style: { transform: u2 ? "left" === h2 ? "rotateX(20deg) rotateZ(-20deg) skewX(20deg)" : "rotateX(20deg) rotateZ(20deg) skewX(-20deg)" : "none" }, children: c2.map((t2, n2) => (0, import_jsx_runtime.jsx)("div", { className: "infinite-scroll-item", children: t2.content }, n2)) }) })] });
};
var ti = { blue: "linear-gradient(hsl(223, 90%, 50%), hsl(208, 90%, 50%))", purple: "linear-gradient(hsl(283, 90%, 50%), hsl(268, 90%, 50%))", red: "linear-gradient(hsl(3, 90%, 50%), hsl(348, 90%, 50%))", indigo: "linear-gradient(hsl(253, 90%, 50%), hsl(238, 90%, 50%))", orange: "linear-gradient(hsl(43, 90%, 50%), hsl(28, 90%, 50%))", green: "linear-gradient(hsl(123, 90%, 40%), hsl(108, 90%, 40%))" };
var ni = ({ items: i2, className: r2 }) => (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".icon-btns {\n  display: grid;\n  grid-gap: 5em;\n  grid-template-columns: repeat(2, 1fr);\n  margin: auto;\n  padding: 3em 0;\n  overflow: visible;\n}\n\n.icon-btn {\n  background-color: transparent;\n  outline: none;\n  position: relative;\n  width: 4.5em;\n  height: 4.5em;\n  perspective: 24em;\n  transform-style: preserve-3d;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.icon-btn__back,\n.icon-btn__front,\n.icon-btn__label {\n  transition: opacity 0.3s cubic-bezier(0.83, 0, 0.17, 1),\n    transform 0.3s cubic-bezier(0.83, 0, 0.17, 1);\n}\n\n.icon-btn__back,\n.icon-btn__front {\n  border-radius: 1.25em;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.icon-btn__back {\n  box-shadow: 0.5em -0.5em 0.75em hsla(223, 10%, 10%, 0.15);\n  display: block;\n  transform: rotate(15deg);\n  transform-origin: 100% 100%;\n}\n\n.icon-btn__front {\n  background-color: hsla(0, 0%, 100%, 0.15);\n  box-shadow: 0 0 0 0.1em hsla(0, 0%, 100%, 0.3) inset;\n  backdrop-filter: blur(0.75em);\n  -webkit-backdrop-filter: blur(0.75em);\n  display: flex;\n  transform-origin: 80% 50%;\n}\n\n.icon-btn__icon {\n  margin: auto;\n  width: 1.5em;\n  height: 1.5em;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.icon-btn__label {\n  font-size: 1em;\n  white-space: nowrap;\n  text-align: center;\n  line-height: 2;\n  opacity: 0;\n  position: absolute;\n  top: 100%;\n  right: 0;\n  left: 0;\n  transform: translateY(0);\n}\n\n.icon-btn:focus-visible .icon-btn__back,\n.icon-btn:hover .icon-btn__back {\n  transform: rotate(25deg) translate3d(-0.5em, -0.5em, 0.5em);\n}\n\n.icon-btn:focus-visible .icon-btn__front,\n.icon-btn:hover .icon-btn__front {\n  transform: translateZ(2em);\n}\n\n.icon-btn:focus-visible .icon-btn__label,\n.icon-btn:hover .icon-btn__label {\n  opacity: 1;\n  transform: translateY(20%);\n}\n\n@media (min-width: 768px) {\n  .icon-btns {\n    grid-template-columns: repeat(3, 1fr);\n  }\n}" }), (0, import_jsx_runtime.jsx)("div", { className: `icon-btns ${r2 || ""}`, children: i2.map((n2, i3) => {
  return (0, import_jsx_runtime.jsxs)("button", { type: "button", className: `icon-btn ${n2.customClass || ""}`, "aria-label": n2.label, children: [(0, import_jsx_runtime.jsx)("span", { className: "icon-btn__back", style: (r3 = n2.color, ti[r3] ? { background: ti[r3] } : { background: r3 }) }), (0, import_jsx_runtime.jsx)("span", { className: "icon-btn__front", children: (0, import_jsx_runtime.jsx)("span", { className: "icon-btn__icon", "aria-hidden": "true", children: n2.icon }) }), (0, import_jsx_runtime.jsx)("span", { className: "icon-btn__label", children: n2.label })] }, i3);
  var r3;
}) })] });
var ii = ({ width: o2 = 300, height: a2 = 400, image: s2 = "https://picsum.photos/300/400?grayscale", children: c2 }) => {
  const l2 = (0, import_react3.useRef)(null), u2 = (0, import_react3.useRef)(null), h2 = (0, import_react3.useRef)({ x: window.innerWidth / 2, y: window.innerHeight / 2 }), d2 = (0, import_react3.useRef)({ ...h2.current }), m2 = (0, import_react3.useRef)({ width: window.innerWidth, height: window.innerHeight });
  return (0, import_react3.useEffect)(() => {
    const e2 = (e3, t3, n3) => (1 - n3) * e3 + n3 * t3, t2 = (e3, t3, n3, i3, r3) => (e3 - t3) * (r3 - i3) / (n3 - t3) + i3, n2 = () => {
      m2.current = { width: window.innerWidth, height: window.innerHeight };
    }, i2 = (e3) => {
      h2.current = { x: e3.clientX, y: e3.clientY };
    };
    window.addEventListener("resize", n2), window.addEventListener("mousemove", i2);
    const r2 = { imgTransforms: { x: 0, y: 0, rz: 0 }, displacementScale: 0 }, o3 = () => {
      let n3 = e2(r2.imgTransforms.x, t2(h2.current.x, 0, m2.current.width, -120, 120), 0.1), i3 = e2(r2.imgTransforms.y, t2(h2.current.y, 0, m2.current.height, -120, 120), 0.1), a3 = e2(r2.imgTransforms.rz, t2(h2.current.x, 0, m2.current.width, -10, 10), 0.1);
      const s3 = 50;
      n3 > s3 && (n3 = s3 + 0.2 * (n3 - s3)), n3 < -50 && (n3 = 0.2 * (n3 + s3) - 50), i3 > s3 && (i3 = s3 + 0.2 * (i3 - s3)), i3 < -50 && (i3 = 0.2 * (i3 + s3) - 50), r2.imgTransforms.x = n3, r2.imgTransforms.y = i3, r2.imgTransforms.rz = a3, l2.current && (void 0).set(l2.current, { x: r2.imgTransforms.x, y: r2.imgTransforms.y, rotateZ: r2.imgTransforms.rz });
      const c3 = ((e3, t3, n4, i4) => {
        const r3 = e3 - t3, o4 = n4 - i4;
        return Math.hypot(r3, o4);
      })(d2.current.x, h2.current.x, d2.current.y, h2.current.y);
      r2.displacementScale = e2(r2.displacementScale, t2(c3, 0, 200, 0, 400), 0.06), u2.current && (void 0).set(u2.current, { attr: { scale: r2.displacementScale } }), d2.current = { ...h2.current }, requestAnimationFrame(o3);
    };
    return o3(), () => {
      window.removeEventListener("resize", n2), window.removeEventListener("mousemove", i2);
    };
  }, []), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".content {\n  position: relative;\n}\n\n.svg {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  display: block;\n  will-change: transform;\n}\n\n.card-text {\n  position: absolute;\n  bottom: 1.2em;\n  letter-spacing: -.5px;\n  font-weight: 900;\n  left: 1em;\n  font-size: 2.5rem;\n  line-height: 1.5em;\n}\n\n.card-text::first-line {\n  font-size: 4rem;\n}" }), (0, import_jsx_runtime.jsxs)("div", { className: "content", style: { width: `${o2}px`, height: `${a2}px` }, ref: l2, children: [(0, import_jsx_runtime.jsxs)("svg", { viewBox: "-60 -75 720 900", preserveAspectRatio: "xMidYMid slice", className: "svg", children: [(0, import_jsx_runtime.jsxs)("filter", { id: "imgFilter", children: [(0, import_jsx_runtime.jsx)("feTurbulence", { type: "turbulence", baseFrequency: "0.015", numOctaves: "5", seed: "4", stitchTiles: "stitch", x: "0%", y: "0%", width: "100%", height: "100%", result: "turbulence1" }), (0, import_jsx_runtime.jsx)("feDisplacementMap", { ref: u2, in: "SourceGraphic", in2: "turbulence1", scale: "0", xChannelSelector: "R", yChannelSelector: "B", x: "0%", y: "0%", width: "100%", height: "100%", result: "displacementMap3" })] }), (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)("image", { href: s2, x: "0", y: "0", width: "600", height: "750", filter: "url(#imgFilter)", preserveAspectRatio: "xMidYMid slice" }) })] }), (0, import_jsx_runtime.jsx)("div", { className: "card-text", children: c2 })] })] });
};
var ri = ({ items: t2 = [] }) => (0, import_jsx_runtime.jsx)("div", { className: "menu-wrap", children: (0, import_jsx_runtime.jsx)("nav", { className: "menu", children: t2.map((t3, n2) => (0, import_jsx_runtime.jsx)(oi, { ...t3 }, n2)) }) });
var oi = ({ link: i2, text: r2, image: o2 }) => {
  const a2 = import_react3.default.useRef(null), s2 = import_react3.default.useRef(null), c2 = import_react3.default.useRef(null), l2 = { duration: 0.6, ease: "expo" }, u2 = (e2, t2, n2, i3) => {
    const r3 = e2 - n2, o3 = t2 - i3;
    return r3 * r3 + o3 * o3;
  }, h2 = (e2, t2, n2, i3) => u2(e2, t2, n2 / 2, 0) < u2(e2, t2, n2 / 2, i3) ? "top" : "bottom", d2 = import_react3.default.useMemo(() => Array.from({ length: 4 }).map((n2, i3) => (0, import_jsx_runtime.jsxs)(import_react3.default.Fragment, { children: [(0, import_jsx_runtime.jsx)("span", { children: r2 }), (0, import_jsx_runtime.jsx)("div", { className: "marquee__img", style: { backgroundImage: `url(${o2})` } })] }, i3)), [r2, o2]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".menu-wrap {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\n.menu {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n}\n\n.menu__item {\n  flex: 1;\n  position: relative;\n  overflow: hidden;\n  text-align: center;\n  box-shadow: 0 -1px #fff;\n}\n\n.menu__item-link {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  position: relative;\n  cursor: pointer;\n  text-transform: uppercase;\n  text-decoration: none;\n  white-space: nowrap;\n  font-weight: 600;\n  color: #fff;\n  font-size: 4vh;\n}\n\n.menu__item-link:hover {\n  color: #060010;\n}\n\n.menu__item-link:focus:not(:focus-visible) {\n  color: #fff;\n}\n\n.marquee {\n  position: absolute;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  background: #fff;\n  transform: translate3d(0, 101%, 0);\n  transition: transform 0.6s ease-expo;\n}\n\n.marquee__inner-wrap {\n  height: 100%;\n  width: 200%;\n  display: flex;\n  transform: translateX(0);\n}\n\n.marquee__inner {\n  display: flex;\n  align-items: center;\n  position: relative;\n  height: 100%;\n  width: 200%;\n  will-change: transform;\n  animation: marquee 15s linear infinite;\n}\n\n.marquee span {\n  color: #060010;\n  white-space: nowrap;\n  text-transform: uppercase;\n  font-weight: 400;\n  font-size: 4vh;\n  line-height: 1.2;\n  padding: 1vh 1vw 0;\n}\n\n.marquee__img {\n  width: 200px;\n  height: 7vh;\n  margin: 2em 2vw;\n  padding: 1em 0;\n  border-radius: 50px;\n  background-size: cover;\n  background-position: 50% 50%;\n}\n\n.menu__item-link:hover+.marquee {\n  transform: translate3d(0, 0%, 0);\n}\n\n@keyframes marquee {\n  from {\n    transform: translateX(0);\n  }\n\n  to {\n    transform: translateX(-50%);\n  }\n}" }), (0, import_jsx_runtime.jsxs)("div", { className: "menu__item", ref: a2, children: [(0, import_jsx_runtime.jsx)("a", { className: "menu__item-link", href: i2, onMouseEnter: (e2) => {
    if (!a2.current || !s2.current || !c2.current) return;
    const t2 = a2.current.getBoundingClientRect(), n2 = e2.clientX - t2.left, i3 = e2.clientY - t2.top, r3 = h2(n2, i3, t2.width, t2.height);
    (void 0).timeline({ defaults: l2 }).set(s2.current, { y: "top" === r3 ? "-101%" : "101%" }, 0).set(c2.current, { y: "top" === r3 ? "101%" : "-101%" }, 0).to([s2.current, c2.current], { y: "0%" }, 0);
  }, onMouseLeave: (e2) => {
    if (!a2.current || !s2.current || !c2.current) return;
    const t2 = a2.current.getBoundingClientRect(), n2 = e2.clientX - t2.left, i3 = e2.clientY - t2.top, r3 = h2(n2, i3, t2.width, t2.height);
    (void 0).timeline({ defaults: l2 }).to(s2.current, { y: "top" === r3 ? "-101%" : "101%" }, 0).to(c2.current, { y: "top" === r3 ? "101%" : "-101%" }, 0);
  }, children: r2 }), (0, import_jsx_runtime.jsx)("div", { className: "marquee", ref: s2, children: (0, import_jsx_runtime.jsx)("div", { className: "marquee__inner-wrap", ref: c2, children: (0, import_jsx_runtime.jsx)("div", { className: "marquee__inner", "aria-hidden": "true", children: d2 }) }) })] })] });
};
var ai = ({ defaultValue: t2 = 50, startingValue: n2 = 0, maxValue: i2 = 100, className: r2 = "", isStepped: o2 = false, stepSize: a2 = 1, leftIcon: s2 = (0, import_jsx_runtime.jsx)(void 0, { as: RiVolumeDownFill }), rightIcon: c2 = (0, import_jsx_runtime.jsx)(void 0, { as: RiVolumeUpFill }) }) => (0, import_jsx_runtime.jsx)("div", { className: `slider-container ${r2}`, children: (0, import_jsx_runtime.jsx)(si, { defaultValue: t2, startingValue: n2, maxValue: i2, isStepped: o2, stepSize: a2, leftIcon: s2, rightIcon: c2 }) });
var si = ({ defaultValue: a2, startingValue: s2, maxValue: c2, isStepped: l2, stepSize: u2, leftIcon: h2, rightIcon: d2 }) => {
  const [m2, p2] = (0, import_react3.useState)(a2), f2 = (0, import_react3.useRef)(null), [v2, g2] = (0, import_react3.useState)("middle"), x2 = useMotionValue(0), w = useMotionValue(0), M = useMotionValue(1);
  (0, import_react3.useEffect)(() => {
    p2(a2);
  }, [a2]), useMotionValueEvent(x2, "change", (e2) => {
    if (f2.current) {
      const { left: t2, right: n2 } = f2.current.getBoundingClientRect();
      let i2;
      e2 < t2 ? (g2("left"), i2 = t2 - e2) : e2 > n2 ? (g2("right"), i2 = e2 - n2) : (g2("middle"), i2 = 0), w.jump(function(e3, t3) {
        const n3 = e3 / t3;
        return 2 * (1 / (1 + Math.exp(-n3)) - 0.5) * t3;
      }(i2, 50));
    }
  });
  const P = (e2) => {
    if (e2.buttons > 0 && f2.current) {
      const { left: t2, width: n2 } = f2.current.getBoundingClientRect();
      let i2 = s2 + (e2.clientX - t2) / n2 * (c2 - s2);
      l2 && (i2 = Math.round(i2 / u2) * u2), i2 = Math.min(Math.max(i2, s2), c2), p2(i2), x2.jump(e2.clientX);
    }
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".slider-container {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: 1rem;\n  width: 12rem;\n}\n\n.slider-wrapper {\n  display: flex;\n  width: 100%;\n  touch-action: none;\n  user-select: none;\n  align-items: center;\n  justify-content: center;\n  gap: 1rem;\n}\n\n.slider-root {\n  position: relative;\n  display: flex;\n  width: 100%;\n  max-width: 200px;\n  flex-grow: 1;\n  cursor: grab;\n  touch-action: none;\n  user-select: none;\n  align-items: center;\n  padding: 1rem 0;\n}\n\n.slider-root:active {\n  cursor: grabbing;\n}\n\n.slider-track-wrapper {\n  display: flex;\n  flex-grow: 1;\n}\n\n.slider-track {\n  position: relative;\n  height: 100%;\n  flex-grow: 1;\n  overflow: hidden;\n  border-radius: 9999px;\n  background-color: rgba(128, 128, 128, 0.4);\n}\n\n.slider-range {\n  position: absolute;\n  height: 100%;\n  background-color: #888;\n  border-radius: 9999px;\n}\n\n.value-indicator {\n  color: #808080;\n  position: absolute;\n  transform: translateY(-1rem);\n  font-size: 0.75rem;\n  font-weight: 500;\n  letter-spacing: 0.05em;\n}\n\n.icon {\n  width: 24px;\n  height: 24px;\n  color: #888;\n}\n\n.icon.dark {\n  color: #ddd;\n}\n" }), (0, import_jsx_runtime.jsxs)(motion.div, { onHoverStart: () => animate(M, 1.2), onHoverEnd: () => animate(M, 1), onTouchStart: () => animate(M, 1.2), onTouchEnd: () => animate(M, 1), style: { scale: M, opacity: useTransform(M, [1, 1.2], [0.7, 1]) }, className: "slider-wrapper", children: [(0, import_jsx_runtime.jsx)(motion.div, { animate: { scale: "left" === v2 ? [1, 1.4, 1] : 1, transition: { duration: 0.25 } }, style: { x: useTransform(() => "left" === v2 ? -w.get() / M.get() : 0) }, children: h2 }), (0, import_jsx_runtime.jsx)("div", { ref: f2, className: "slider-root", onPointerMove: P, onPointerDown: (e2) => {
    P(e2), e2.currentTarget.setPointerCapture(e2.pointerId);
  }, onPointerUp: () => {
    animate(w, 0, { type: "spring", bounce: 0.5 });
  }, children: (0, import_jsx_runtime.jsx)(motion.div, { style: { scaleX: useTransform(() => {
    if (f2.current) {
      const { width: e2 } = f2.current.getBoundingClientRect();
      return 1 + w.get() / e2;
    }
    return 1;
  }), scaleY: useTransform(w, [0, 50], [1, 0.8]), transformOrigin: useTransform(() => {
    if (f2.current) {
      const { left: e2, width: t2 } = f2.current.getBoundingClientRect();
      return x2.get() < e2 + t2 / 2 ? "right" : "left";
    }
    return "center";
  }), height: useTransform(M, [1, 1.2], [6, 12]), marginTop: useTransform(M, [1, 1.2], [0, -3]), marginBottom: useTransform(M, [1, 1.2], [0, -3]) }, className: "slider-track-wrapper", children: (0, import_jsx_runtime.jsx)("div", { className: "slider-track", children: (0, import_jsx_runtime.jsx)("div", { className: "slider-range", style: { width: `${(() => {
    const e2 = c2 - s2;
    return 0 === e2 ? 0 : (m2 - s2) / e2 * 100;
  })()}%` } }) }) }) }), (0, import_jsx_runtime.jsx)(motion.div, { animate: { scale: "right" === v2 ? [1, 1.4, 1] : 1, transition: { duration: 0.25 } }, style: { x: useTransform(() => "right" === v2 ? w.get() / M.get() : 0) }, children: d2 })] }), (0, import_jsx_runtime.jsx)("p", { className: "value-indicator", children: Math.round(m2) })] });
};
function ci({ mv: t2, number: n2, height: i2 }) {
  let r2 = useTransform(t2, (e2) => {
    let t3 = (10 + n2 - e2 % 10) % 10, r3 = t3 * i2;
    return t3 > 5 && (r3 -= 10 * i2), r3;
  });
  return (0, import_jsx_runtime.jsx)(motion.span, { className: "counter-number", style: { y: r2 }, children: n2 });
}
function li({ place: t2, value: n2, height: i2, digitStyle: o2 }) {
  let a2 = Math.floor(n2 / t2), s2 = useSpring(a2);
  return (0, import_react3.useEffect)(() => {
    s2.set(a2);
  }, [s2, a2]), (0, import_jsx_runtime.jsx)("div", { className: "counter-digit", style: { height: i2, ...o2 }, children: Array.from({ length: 10 }, (t3, n3) => (0, import_jsx_runtime.jsx)(ci, { mv: s2, number: n3, height: i2 }, n3)) });
}
function ui({ value: i2, fontSize: r2 = 100, padding: o2 = 0, places: a2 = [100, 10, 1], gap: s2 = 8, borderRadius: c2 = 4, horizontalPadding: l2 = 8, textColor: u2 = "white", fontWeight: h2 = "bold", containerStyle: d2, counterStyle: m2, digitStyle: p2, gradientHeight: f2 = 16, gradientFrom: v2 = "black", gradientTo: g2 = "transparent", topGradientStyle: x2, bottomGradientStyle: y }) {
  const w = r2 + o2, b = { fontSize: r2, gap: s2, borderRadius: c2, paddingLeft: l2, paddingRight: l2, color: u2, fontWeight: h2 }, M = { height: f2, background: `linear-gradient(to bottom, ${v2}, ${g2})` }, P = { height: f2, background: `linear-gradient(to top, ${v2}, ${g2})` };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".counter-container {\n  position: relative;\n  display: inline-block;\n}\n\n.counter-counter {\n  display: flex;\n  overflow: hidden;\n  line-height: 1;\n}\n\n.counter-digit {\n  position: relative;\n  width: 1ch;\n  font-variant-numeric: tabular-nums;\n}\n\n.counter-number {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.gradient-container {\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.bottom-gradient {\n  position: absolute;\n  bottom: 0;\n  width: 100%;\n}" }), (0, import_jsx_runtime.jsxs)("div", { className: "counter-container", style: d2, children: [(0, import_jsx_runtime.jsx)("div", { className: "counter-counter", style: { ...b, ...m2 }, children: a2.map((t2) => (0, import_jsx_runtime.jsx)(li, { place: t2, value: i2, height: w, digitStyle: p2 }, t2)) }), (0, import_jsx_runtime.jsxs)("div", { className: "gradient-container", children: [(0, import_jsx_runtime.jsx)("div", { className: "top-gradient", style: x2 || M }), (0, import_jsx_runtime.jsx)("div", { className: "bottom-gradient", style: y || P })] })] })] });
}
var hi = class {
  constructor(e2, t2, n2) {
    this.a = e2, this.b = t2, this.c = n2;
  }
};
var di = class {
  constructor(e2, t2, n2) {
    this.position = (void 0).fromValues(e2, t2, n2), this.normal = (void 0).create(), this.uv = (void 0).create();
  }
};
var mi = class {
  constructor() {
    this.vertices = [], this.faces = [];
  }
  addVertex(...e2) {
    for (let t2 = 0; t2 < e2.length; t2 += 3) this.vertices.push(new di(e2[t2], e2[t2 + 1], e2[t2 + 2]));
    return this;
  }
  addFace(...e2) {
    for (let t2 = 0; t2 < e2.length; t2 += 3) this.faces.push(new hi(e2[t2], e2[t2 + 1], e2[t2 + 2]));
    return this;
  }
  get lastVertex() {
    return this.vertices[this.vertices.length - 1];
  }
  subdivide(e2 = 1) {
    const t2 = {};
    let n2 = this.faces;
    for (let i2 = 0; i2 < e2; ++i2) {
      const e3 = new Array(4 * n2.length);
      n2.forEach((n3, i3) => {
        const r2 = this.getMidPoint(n3.a, n3.b, t2), o2 = this.getMidPoint(n3.b, n3.c, t2), a2 = this.getMidPoint(n3.c, n3.a, t2), s2 = 4 * i3;
        e3[s2 + 0] = new hi(n3.a, r2, a2), e3[s2 + 1] = new hi(n3.b, o2, r2), e3[s2 + 2] = new hi(n3.c, a2, o2), e3[s2 + 3] = new hi(r2, o2, a2);
      }), n2 = e3;
    }
    return this.faces = n2, this;
  }
  spherize(e2 = 1) {
    return this.vertices.forEach((t2) => {
      (void 0).normalize(t2.normal, t2.position), (void 0).scale(t2.position, t2.normal, e2);
    }), this;
  }
  get data() {
    return { vertices: this.vertexData, indices: this.indexData, normals: this.normalData, uvs: this.uvData };
  }
  get vertexData() {
    return new Float32Array(this.vertices.flatMap((e2) => Array.from(e2.position)));
  }
  get normalData() {
    return new Float32Array(this.vertices.flatMap((e2) => Array.from(e2.normal)));
  }
  get uvData() {
    return new Float32Array(this.vertices.flatMap((e2) => Array.from(e2.uv)));
  }
  get indexData() {
    return new Uint16Array(this.faces.flatMap((e2) => [e2.a, e2.b, e2.c]));
  }
  getMidPoint(e2, t2, n2) {
    const i2 = e2 < t2 ? `k_${t2}_${e2}` : `k_${e2}_${t2}`;
    if (Object.prototype.hasOwnProperty.call(n2, i2)) return n2[i2];
    const r2 = this.vertices[e2].position, o2 = this.vertices[t2].position, a2 = this.vertices.length;
    return n2[i2] = a2, this.addVertex(0.5 * (r2[0] + o2[0]), 0.5 * (r2[1] + o2[1]), 0.5 * (r2[2] + o2[2])), a2;
  }
};
var pi = class extends mi {
  constructor() {
    super();
    const e2 = 0.5 * Math.sqrt(5) + 0.5;
    this.addVertex(-1, e2, 0, 1, e2, 0, -1, -e2, 0, 1, -e2, 0, 0, -1, e2, 0, 1, e2, 0, -1, -e2, 0, 1, -e2, e2, 0, -1, e2, 0, 1, -e2, 0, -1, -e2, 0, 1).addFace(0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1);
  }
};
var fi = class extends mi {
  constructor(e2 = 4, t2 = 1) {
    super();
    const n2 = Math.max(4, e2), i2 = 2 * Math.PI / n2;
    this.addVertex(0, 0, 0), this.lastVertex.uv[0] = 0.5, this.lastVertex.uv[1] = 0.5;
    for (let e3 = 0; e3 < n2; ++e3) {
      const n3 = Math.cos(i2 * e3), r2 = Math.sin(i2 * e3);
      this.addVertex(t2 * n3, t2 * r2, 0), this.lastVertex.uv[0] = 0.5 * n3 + 0.5, this.lastVertex.uv[1] = 0.5 * r2 + 0.5, e3 > 0 && this.addFace(0, e3, e3 + 1);
    }
    this.addFace(0, n2, 1);
  }
};
function vi(e2, t2, n2) {
  const i2 = e2.createBuffer();
  if (!i2) throw new Error("Failed to create WebGL buffer.");
  return e2.bindBuffer(e2.ARRAY_BUFFER, i2), e2.bufferData(e2.ARRAY_BUFFER, t2, n2), e2.bindBuffer(e2.ARRAY_BUFFER, null), i2;
}
var gi = class {
  constructor(e2, t2) {
    this.isPointerDown = false, this.orientation = (void 0).create(), this.pointerRotation = (void 0).create(), this.rotationVelocity = 0, this.rotationAxis = (void 0).fromValues(1, 0, 0), this.snapDirection = (void 0).fromValues(0, 0, -1), this.snapTargetDirection = null, this.pointerPos = (void 0).create(), this.previousPointerPos = (void 0).create(), this._rotationVelocity = 0, this._combinedQuat = (void 0).create(), this.EPSILON = 0.1, this.IDENTITY_QUAT = (void 0).create(), this.canvas = e2, this.updateCallback = t2 || (() => {
    }), e2.addEventListener("pointerdown", (e3) => {
      (void 0).set(this.pointerPos, e3.clientX, e3.clientY), (void 0).copy(this.previousPointerPos, this.pointerPos), this.isPointerDown = true;
    }), e2.addEventListener("pointerup", () => {
      this.isPointerDown = false;
    }), e2.addEventListener("pointerleave", () => {
      this.isPointerDown = false;
    }), e2.addEventListener("pointermove", (e3) => {
      this.isPointerDown && (void 0).set(this.pointerPos, e3.clientX, e3.clientY);
    }), e2.style.touchAction = "none";
  }
  update(e2, t2 = 16) {
    const n2 = e2 / t2 + 1e-5;
    let i2 = n2;
    const r2 = (void 0).create();
    if (this.isPointerDown) {
      const e3 = 0.3 * n2, t3 = 5 / n2, r3 = (void 0).sub((void 0).create(), this.pointerPos, this.previousPointerPos);
      if ((void 0).scale(r3, r3, e3), (void 0).sqrLen(r3) > this.EPSILON) {
        (void 0).add(r3, this.previousPointerPos, r3);
        const e4 = this.project(r3), n3 = this.project(this.previousPointerPos), o3 = (void 0).normalize((void 0).create(), e4), a3 = (void 0).normalize((void 0).create(), n3);
        (void 0).copy(this.previousPointerPos, r3), i2 *= t3, this.quatFromVectors(o3, a3, this.pointerRotation, i2);
      } else (void 0).slerp(this.pointerRotation, this.pointerRotation, this.IDENTITY_QUAT, e3);
    } else {
      const e3 = 0.1 * n2;
      if ((void 0).slerp(this.pointerRotation, this.pointerRotation, this.IDENTITY_QUAT, e3), this.snapTargetDirection) {
        const e4 = 0.2, t3 = this.snapTargetDirection, n3 = this.snapDirection, o3 = (void 0).squaredDistance(t3, n3);
        i2 *= e4 * Math.max(0.1, 1 - 10 * o3), this.quatFromVectors(t3, n3, r2, i2);
      }
    }
    const o2 = (void 0).multiply((void 0).create(), r2, this.pointerRotation);
    this.orientation = (void 0).multiply((void 0).create(), o2, this.orientation), (void 0).normalize(this.orientation, this.orientation);
    const a2 = 0.8 * n2;
    (void 0).slerp(this._combinedQuat, this._combinedQuat, o2, a2), (void 0).normalize(this._combinedQuat, this._combinedQuat);
    const s2 = 2 * Math.acos(this._combinedQuat[3]), c2 = Math.sin(s2 / 2);
    let l2 = 0;
    c2 > 1e-6 && (l2 = s2 / (2 * Math.PI), this.rotationAxis[0] = this._combinedQuat[0] / c2, this.rotationAxis[1] = this._combinedQuat[1] / c2, this.rotationAxis[2] = this._combinedQuat[2] / c2);
    const u2 = 0.5 * n2;
    this._rotationVelocity += (l2 - this._rotationVelocity) * u2, this.rotationVelocity = this._rotationVelocity / n2, this.updateCallback(e2);
  }
  quatFromVectors(e2, t2, n2, i2 = 1) {
    const r2 = (void 0).cross((void 0).create(), e2, t2);
    (void 0).normalize(r2, r2);
    const o2 = Math.max(-1, Math.min(1, (void 0).dot(e2, t2))), a2 = Math.acos(o2) * i2;
    return (void 0).setAxisAngle(n2, r2, a2), { q: n2, axis: r2, angle: a2 };
  }
  project(e2) {
    const t2 = this.canvas.clientWidth, n2 = this.canvas.clientHeight, i2 = Math.max(t2, n2) - 1, r2 = (2 * e2[0] - t2 - 1) / i2, o2 = (2 * e2[1] - n2 - 1) / i2;
    let a2 = 0;
    const s2 = r2 * r2 + o2 * o2;
    return a2 = s2 <= 2 ? Math.sqrt(4 - s2) : 4 / Math.sqrt(s2), (void 0).fromValues(-r2, o2, a2);
  }
};
var xi = class {
  constructor(e2, t2, n2, i2, r2) {
    this.canvas = e2, this.items = t2, this.onActiveItemChange = n2, this.onMovementChange = i2, this.gl = null, this.discProgram = null, this.discVAO = null, this.worldMatrix = (void 0).create(), this.tex = null, this.viewportSize = (void 0).create(), this.drawBufferSize = (void 0).create(), this.instancePositions = [], this.DISC_INSTANCE_COUNT = 0, this.atlasSize = 1, this._time = 0, this._deltaTime = 0, this._deltaFrames = 0, this._frames = 0, this.movementActive = false, this.TARGET_FRAME_DURATION = 1e3 / 60, this.SPHERE_RADIUS = 2, this.camera = { matrix: (void 0).create(), near: 0.1, far: 40, fov: Math.PI / 4, aspect: 1, position: (void 0).fromValues(0, 0, 3), up: (void 0).fromValues(0, 1, 0), matrices: { view: (void 0).create(), projection: (void 0).create(), inversProjection: (void 0).create() } }, this.smoothRotationVelocity = 0, this.scaleFactor = 1, this.init(r2);
  }
  resize() {
    const e2 = function(e3) {
      const t2 = Math.min(2, window.devicePixelRatio || 1), n2 = Math.round(e3.clientWidth * t2), i2 = Math.round(e3.clientHeight * t2), r2 = e3.width !== n2 || e3.height !== i2;
      return r2 && (e3.width = n2, e3.height = i2), r2;
    }(this.canvas);
    this.gl && (e2 && this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight), this.updateProjectionMatrix());
  }
  run(e2 = 0) {
    this._deltaTime = Math.min(32, e2 - this._time), this._time = e2, this._deltaFrames = this._deltaTime / this.TARGET_FRAME_DURATION, this._frames += this._deltaFrames, this.animate(this._deltaTime), this.render(), requestAnimationFrame((e3) => this.run(e3));
  }
  init(e2) {
    const t2 = this.canvas.getContext("webgl2", { antialias: true, alpha: false });
    if (!t2) throw new Error("No WebGL 2 context!");
    this.gl = t2, (void 0).set(this.viewportSize, this.canvas.clientWidth, this.canvas.clientHeight), (void 0).clone(this.drawBufferSize), this.discProgram = function(e3, t3, n2, i2) {
      const r2 = e3.createProgram();
      if (!r2) return null;
      if ([e3.VERTEX_SHADER, e3.FRAGMENT_SHADER].forEach((n3, i3) => {
        const o2 = function(e4, t4, n4) {
          const i4 = e4.createShader(t4);
          return i4 ? (e4.shaderSource(i4, n4), e4.compileShader(i4), e4.getShaderParameter(i4, e4.COMPILE_STATUS) ? i4 : (e4.deleteShader(i4), null)) : null;
        }(e3, n3, t3[i3]);
        o2 && e3.attachShader(r2, o2);
      }), i2) for (const t4 in i2) Object.prototype.hasOwnProperty.call(i2, t4) && e3.bindAttribLocation(r2, i2[t4], t4);
      return e3.linkProgram(r2), e3.getProgramParameter(r2, e3.LINK_STATUS) ? r2 : (e3.deleteProgram(r2), null);
    }(t2, ["#version 300 es\n\nuniform mat4 uWorldMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform vec3 uCameraPosition;\nuniform vec4 uRotationAxisVelocity;\n\nin vec3 aModelPosition;\nin vec3 aModelNormal;\nin vec2 aModelUvs;\nin mat4 aInstanceMatrix;\n\nout vec2 vUvs;\nout float vAlpha;\nflat out int vInstanceId;\n\n#define PI 3.141593\n\nvoid main() {\n    vec4 worldPosition = uWorldMatrix * aInstanceMatrix * vec4(aModelPosition, 1.);\n\n    vec3 centerPos = (uWorldMatrix * aInstanceMatrix * vec4(0., 0., 0., 1.)).xyz;\n    float radius = length(centerPos.xyz);\n\n    if (gl_VertexID > 0) {\n        vec3 rotationAxis = uRotationAxisVelocity.xyz;\n        float rotationVelocity = min(.15, uRotationAxisVelocity.w * 15.);\n        vec3 stretchDir = normalize(cross(centerPos, rotationAxis));\n        vec3 relativeVertexPos = normalize(worldPosition.xyz - centerPos);\n        float strength = dot(stretchDir, relativeVertexPos);\n        float invAbsStrength = min(0., abs(strength) - 1.);\n        strength = rotationVelocity * sign(strength) * abs(invAbsStrength * invAbsStrength * invAbsStrength + 1.);\n        worldPosition.xyz += stretchDir * strength;\n    }\n\n    worldPosition.xyz = radius * normalize(worldPosition.xyz);\n\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\n\n    vAlpha = smoothstep(0.5, 1., normalize(worldPosition.xyz).z) * .9 + .1;\n    vUvs = aModelUvs;\n    vInstanceId = gl_InstanceID;\n}\n", "#version 300 es\nprecision highp float;\n\nuniform sampler2D uTex;\nuniform int uItemCount;\nuniform int uAtlasSize;\n\nout vec4 outColor;\n\nin vec2 vUvs;\nin float vAlpha;\nflat in int vInstanceId;\n\nvoid main() {\n    int itemIndex = vInstanceId % uItemCount;\n    int cellsPerRow = uAtlasSize;\n    int cellX = itemIndex % cellsPerRow;\n    int cellY = itemIndex / cellsPerRow;\n    vec2 cellSize = vec2(1.0) / vec2(float(cellsPerRow));\n    vec2 cellOffset = vec2(float(cellX), float(cellY)) * cellSize;\n\n    ivec2 texSize = textureSize(uTex, 0);\n    float imageAspect = float(texSize.x) / float(texSize.y);\n    float containerAspect = 1.0;\n    \n    float scale = max(imageAspect / containerAspect, \n                     containerAspect / imageAspect);\n    \n    vec2 st = vec2(vUvs.x, 1.0 - vUvs.y);\n    st = (st - 0.5) * scale + 0.5;\n    \n    st = clamp(st, 0.0, 1.0);\n    \n    st = st * cellSize + cellOffset;\n    \n    outColor = texture(uTex, st);\n    outColor.a *= vAlpha;\n}\n"], 0, { aModelPosition: 0, aModelNormal: 1, aModelUvs: 2, aInstanceMatrix: 3 }), this.discLocations = { aModelPosition: t2.getAttribLocation(this.discProgram, "aModelPosition"), aModelUvs: t2.getAttribLocation(this.discProgram, "aModelUvs"), aInstanceMatrix: t2.getAttribLocation(this.discProgram, "aInstanceMatrix"), uWorldMatrix: t2.getUniformLocation(this.discProgram, "uWorldMatrix"), uViewMatrix: t2.getUniformLocation(this.discProgram, "uViewMatrix"), uProjectionMatrix: t2.getUniformLocation(this.discProgram, "uProjectionMatrix"), uCameraPosition: t2.getUniformLocation(this.discProgram, "uCameraPosition"), uScaleFactor: t2.getUniformLocation(this.discProgram, "uScaleFactor"), uRotationAxisVelocity: t2.getUniformLocation(this.discProgram, "uRotationAxisVelocity"), uTex: t2.getUniformLocation(this.discProgram, "uTex"), uFrames: t2.getUniformLocation(this.discProgram, "uFrames"), uItemCount: t2.getUniformLocation(this.discProgram, "uItemCount"), uAtlasSize: t2.getUniformLocation(this.discProgram, "uAtlasSize") }, this.discGeo = new fi(56, 1), this.discBuffers = this.discGeo.data, this.discVAO = function(e3, t3, n2) {
      const i2 = e3.createVertexArray();
      if (!i2) return null;
      e3.bindVertexArray(i2);
      for (const [n3, i3, r2] of t3) -1 !== i3 && (e3.bindBuffer(e3.ARRAY_BUFFER, n3), e3.enableVertexAttribArray(i3), e3.vertexAttribPointer(i3, r2, e3.FLOAT, false, 0, 0));
      if (n2) {
        const t4 = e3.createBuffer();
        t4 && (e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, t4), e3.bufferData(e3.ELEMENT_ARRAY_BUFFER, n2, e3.STATIC_DRAW));
      }
      return e3.bindVertexArray(null), i2;
    }(t2, [[vi(t2, this.discBuffers.vertices, t2.STATIC_DRAW), this.discLocations.aModelPosition, 3], [vi(t2, this.discBuffers.uvs, t2.STATIC_DRAW), this.discLocations.aModelUvs, 2]], this.discBuffers.indices), this.icoGeo = new pi(), this.icoGeo.subdivide(1).spherize(this.SPHERE_RADIUS), this.instancePositions = this.icoGeo.vertices.map((e3) => e3.position), this.DISC_INSTANCE_COUNT = this.icoGeo.vertices.length, this.initDiscInstances(this.DISC_INSTANCE_COUNT), this.initTexture(), this.control = new gi(this.canvas, (e3) => this.onControlUpdate(e3)), this.updateCameraMatrix(), this.updateProjectionMatrix(), this.resize(), e2 && e2(this);
  }
  initTexture() {
    if (!this.gl) return;
    const e2 = this.gl;
    this.tex = function(e3, t3, n3, i3, r3) {
      const o2 = e3.createTexture();
      if (!o2) throw new Error("Failed to create WebGL texture.");
      return e3.bindTexture(e3.TEXTURE_2D, o2), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_S, i3), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_T, r3), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_MIN_FILTER, t3), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_MAG_FILTER, n3), o2;
    }(e2, e2.LINEAR, e2.LINEAR, e2.CLAMP_TO_EDGE, e2.CLAMP_TO_EDGE);
    const t2 = Math.max(1, this.items.length);
    this.atlasSize = Math.ceil(Math.sqrt(t2));
    const n2 = 512, i2 = document.createElement("canvas"), r2 = i2.getContext("2d");
    i2.width = this.atlasSize * n2, i2.height = this.atlasSize * n2, Promise.all(this.items.map((e3) => new Promise((t3) => {
      const n3 = new Image();
      n3.crossOrigin = "anonymous", n3.onload = () => t3(n3), n3.src = e3.image;
    }))).then((t3) => {
      t3.forEach((e3, t4) => {
        const i3 = t4 % this.atlasSize * n2, o2 = Math.floor(t4 / this.atlasSize) * n2;
        r2.drawImage(e3, i3, o2, n2, n2);
      }), e2.bindTexture(e2.TEXTURE_2D, this.tex), e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, e2.UNSIGNED_BYTE, i2), e2.generateMipmap(e2.TEXTURE_2D);
    });
  }
  initDiscInstances(e2) {
    if (!this.gl || !this.discVAO) return;
    const t2 = this.gl, n2 = new Float32Array(16 * e2), i2 = [];
    for (let t3 = 0; t3 < e2; ++t3) {
      const e3 = new Float32Array(n2.buffer, 16 * t3 * 4, 16);
      (void 0).identity(e3), i2.push(e3);
    }
    this.discInstances = { matricesArray: n2, matrices: i2, buffer: t2.createBuffer() }, t2.bindVertexArray(this.discVAO), t2.bindBuffer(t2.ARRAY_BUFFER, this.discInstances.buffer), t2.bufferData(t2.ARRAY_BUFFER, this.discInstances.matricesArray.byteLength, t2.DYNAMIC_DRAW);
    for (let e3 = 0; e3 < 4; ++e3) {
      const n3 = this.discLocations.aInstanceMatrix + e3;
      t2.enableVertexAttribArray(n3), t2.vertexAttribPointer(n3, 4, t2.FLOAT, false, 64, 4 * e3 * 4), t2.vertexAttribDivisor(n3, 1);
    }
    t2.bindBuffer(t2.ARRAY_BUFFER, null), t2.bindVertexArray(null);
  }
  animate(e2) {
    if (!this.gl) return;
    this.control.update(e2, this.TARGET_FRAME_DURATION);
    const t2 = this.instancePositions.map((e3) => (void 0).transformQuat((void 0).create(), e3, this.control.orientation));
    t2.forEach((e3, t3) => {
      const n2 = 0.25 * (Math.abs(e3[2]) / this.SPHERE_RADIUS * 0.6 + 0.4), i2 = (void 0).create();
      (void 0).multiply(i2, i2, (void 0).fromTranslation((void 0).create(), (void 0).negate((void 0).create(), e3))), (void 0).multiply(i2, i2, (void 0).targetTo((void 0).create(), [0, 0, 0], e3, [0, 1, 0])), (void 0).multiply(i2, i2, (void 0).fromScaling((void 0).create(), [n2, n2, n2])), (void 0).multiply(i2, i2, (void 0).fromTranslation((void 0).create(), [0, 0, -this.SPHERE_RADIUS])), (void 0).copy(this.discInstances.matrices[t3], i2);
    }), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.discInstances.buffer), this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.discInstances.matricesArray), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null), this.smoothRotationVelocity = this.control.rotationVelocity;
  }
  render() {
    if (!this.gl || !this.discProgram) return;
    const e2 = this.gl;
    e2.useProgram(this.discProgram), e2.enable(e2.CULL_FACE), e2.enable(e2.DEPTH_TEST), e2.clearColor(0, 0, 0, 0), e2.clear(e2.COLOR_BUFFER_BIT | e2.DEPTH_BUFFER_BIT), e2.uniformMatrix4fv(this.discLocations.uWorldMatrix, false, this.worldMatrix), e2.uniformMatrix4fv(this.discLocations.uViewMatrix, false, this.camera.matrices.view), e2.uniformMatrix4fv(this.discLocations.uProjectionMatrix, false, this.camera.matrices.projection), e2.uniform3f(this.discLocations.uCameraPosition, this.camera.position[0], this.camera.position[1], this.camera.position[2]), e2.uniform4f(this.discLocations.uRotationAxisVelocity, this.control.rotationAxis[0], this.control.rotationAxis[1], this.control.rotationAxis[2], 1.1 * this.smoothRotationVelocity), e2.uniform1i(this.discLocations.uItemCount, this.items.length), e2.uniform1i(this.discLocations.uAtlasSize, this.atlasSize), e2.uniform1f(this.discLocations.uFrames, this._frames), e2.uniform1f(this.discLocations.uScaleFactor, this.scaleFactor), e2.uniform1i(this.discLocations.uTex, 0), e2.activeTexture(e2.TEXTURE0), e2.bindTexture(e2.TEXTURE_2D, this.tex), e2.bindVertexArray(this.discVAO), e2.drawElementsInstanced(e2.TRIANGLES, this.discBuffers.indices.length, e2.UNSIGNED_SHORT, 0, this.DISC_INSTANCE_COUNT), e2.bindVertexArray(null);
  }
  updateCameraMatrix() {
    (void 0).targetTo(this.camera.matrix, this.camera.position, [0, 0, 0], this.camera.up), (void 0).invert(this.camera.matrices.view, this.camera.matrix);
  }
  updateProjectionMatrix() {
    if (!this.gl) return;
    const e2 = this.gl.canvas;
    this.camera.aspect = e2.clientWidth / e2.clientHeight;
    const t2 = 0.35 * this.SPHERE_RADIUS, n2 = this.camera.position[2];
    this.camera.aspect > 1 ? this.camera.fov = 2 * Math.atan(t2 / n2) : this.camera.fov = 2 * Math.atan(t2 / this.camera.aspect / n2), (void 0).perspective(this.camera.matrices.projection, this.camera.fov, this.camera.aspect, this.camera.near, this.camera.far), (void 0).invert(this.camera.matrices.inversProjection, this.camera.matrices.projection);
  }
  onControlUpdate(e2) {
    const t2 = e2 / this.TARGET_FRAME_DURATION + 1e-4;
    let n2 = 5 / t2, i2 = 3;
    const r2 = this.control.isPointerDown || Math.abs(this.smoothRotationVelocity) > 0.01;
    if (r2 !== this.movementActive && (this.movementActive = r2, this.onMovementChange(r2)), this.control.isPointerDown) i2 += 80 * this.control.rotationVelocity + 2.5, n2 = 7 / t2;
    else {
      const e3 = this.findNearestVertexIndex(), t3 = e3 % Math.max(1, this.items.length);
      this.onActiveItemChange(t3);
      const n3 = (void 0).normalize((void 0).create(), this.getVertexWorldPosition(e3));
      this.control.snapTargetDirection = n3;
    }
    this.camera.position[2] += (i2 - this.camera.position[2]) / n2, this.updateCameraMatrix();
  }
  findNearestVertexIndex() {
    const e2 = this.control.snapDirection, t2 = (void 0).conjugate((void 0).create(), this.control.orientation), n2 = (void 0).transformQuat((void 0).create(), e2, t2);
    let i2 = -1, r2 = 0;
    for (let e3 = 0; e3 < this.instancePositions.length; ++e3) {
      const t3 = (void 0).dot(n2, this.instancePositions[e3]);
      t3 > i2 && (i2 = t3, r2 = e3);
    }
    return r2;
  }
  getVertexWorldPosition(e2) {
    const t2 = this.instancePositions[e2];
    return (void 0).transformQuat((void 0).create(), t2, this.control.orientation);
  }
};
var yi = [{ image: "https://picsum.photos/900/900?grayscale", link: "https://google.com/", title: "", description: "" }];
var wi = ({ items: a2 = [] }) => {
  const s2 = (0, import_react3.useRef)(null), [c2, l2] = (0, import_react3.useState)(null), [u2, h2] = (0, import_react3.useState)(false);
  (0, import_react3.useEffect)(() => {
    const e2 = s2.current;
    let t2 = null;
    const n2 = (e3) => {
      if (!a2.length) return;
      const t3 = e3 % a2.length;
      l2(a2[t3]);
    };
    e2 && (t2 = new xi(e2, a2.length ? a2 : yi, n2, h2, (e3) => e3.run()));
    const i2 = () => {
      t2 && t2.resize();
    };
    return window.addEventListener("resize", i2), i2(), () => {
      window.removeEventListener("resize", i2);
    };
  }, [a2]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: ["/* Note: this CSS is only an example, you can overlay whatever you want using the activeItem logic */\n\n#infinite-grid-menu-canvas {\n  cursor: grab;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n  outline: none;\n}\n\n#infinite-grid-menu-canvas:active {\n  cursor: grabbing;\n}\n\n.action-button {\n  position: absolute;\n  left: 50%;\n  z-index: 10;\n  width: 60px;\n  height: 60px;\n  display: grid;\n  place-items: center;\n  background: #5227FF;\n  border: none;\n  border-radius: 50%;\n  cursor: pointer;\n  border: 5px solid #000;\n}\n\n.face-title {\n  user-select: none;\n  position: absolute;\n  font-weight: 900;\n  font-size: 4rem;\n  left: 1.6em;\n  top: 50%;\n}\n\n.action-button-icon {\n  user-select: none;\n  position: relative;\n  color: #fff;\n  top: 2px;\n  font-size: 26px;\n}\n\n.face-title {\n  position: absolute;\n  top: 50%;\n  transform: translate(20%, -50%);\n}\n\n.face-title.active {\n  opacity: 1;\n  transform: translate(20%, -50%);\n  pointer-events: auto;\n  transition: 0.5s ease;\n}\n\n.face-title.inactive {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.1s ease;\n}\n\n.face-description {\n  user-select: none;\n  position: absolute;\n  max-width: 10ch;\n  top: 50%;\n  font-size: 1.5rem;\n  right: 1%;\n  transform: translate(0, -50%);\n}\n\n.face-description.active {\n  opacity: 1;\n  transform: translate(-90%, -50%);\n  pointer-events: auto;\n  transition: 0.5s ease;\n}\n\n.face-description.inactive {\n  pointer-events: none;\n  transform: translate(-60%, -50%);\n  opacity: 0;\n  transition: 0.1s ease;\n}\n\n.action-button {\n  position: absolute;\n  left: 50%;\n}\n\n.action-button.active {\n  bottom: 3.8em;\n  transform: translateX(-50%) scale(1);\n  opacity: 1;\n  pointer-events: auto;\n  transition: 0.5s ease;\n}\n\n.action-button.inactive {\n  bottom: -80px;\n  transform: translateX(-50%) scale(0);\n  opacity: 0;\n  pointer-events: none;\n  transition: 0.1s ease;\n}\n\n@media (max-width: 1500px) {\n  .face-title, .face-description {\n    display: none;\n  }\n}", (0, import_jsx_runtime.jsxs)("div", { style: { position: "relative", width: "100%", height: "100%" }, children: [(0, import_jsx_runtime.jsx)("canvas", { id: "infinite-grid-menu-canvas", ref: s2 }), c2 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("h2", { className: "face-title " + (u2 ? "inactive" : "active"), children: c2.title }), (0, import_jsx_runtime.jsx)("p", { className: "face-description " + (u2 ? "inactive" : "active"), children: c2.description }), (0, import_jsx_runtime.jsx)("div", { onClick: () => {
    (c2 == null ? void 0 : c2.link) && c2.link.startsWith("http") && window.open(c2.link, "_blank");
  }, className: "action-button " + (u2 ? "inactive" : "active"), children: (0, import_jsx_runtime.jsx)("p", { className: "action-button-icon", children: "↗" }) })] })] })] });
};
var bi = ["https://images.unsplash.com/photo-1528181304800-259b08848526?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://images.unsplash.com/photo-1506665531195-3566af2b4dfa?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://images.unsplash.com/photo-1520250497591-112f2f40a3f4?q=80&w=3456&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://images.unsplash.com/photo-1495103033382-fe343886b671?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://images.unsplash.com/photo-1506781961370-37a89d6b3095?q=80&w=3264&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://images.unsplash.com/photo-1599576838688-8a6c11263108?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://images.unsplash.com/photo-1494094892896-7f14a4433b7a?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://plus.unsplash.com/premium_photo-1664910706524-e783eed89e71?q=80&w=3869&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://images.unsplash.com/photo-1503788311183-fa3bf9c4bc32?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D", "https://images.unsplash.com/photo-1585970480901-90d6bb2a48b5?q=80&w=3774&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"];
var Mi = ({ autoplay: a2 = false, pauseOnHover: s2 = false, images: c2 = [] }) => {
  c2 = bi;
  const [l2, u2] = (0, import_react3.useState)(window.innerWidth <= 640), h2 = l2 ? 1100 : 1800, d2 = c2.length, m2 = h2 / d2 * 1.5, p2 = h2 / (2 * Math.PI), f2 = useMotionValue(0), v2 = useAnimation(), g2 = (0, import_react3.useRef)(null), x2 = useTransform(f2, (e2) => `rotate3d(0, 1, 0, ${e2}deg)`);
  (0, import_react3.useEffect)(() => {
    if (a2) return g2.current = setInterval(() => {
      v2.start({ rotateY: f2.get() - 360 / d2, transition: { duration: 2, ease: "linear" } }), f2.set(f2.get() - 360 / d2);
    }, 2e3), () => {
      g2.current && clearInterval(g2.current);
    };
  }, [a2, f2, v2, d2]), (0, import_react3.useEffect)(() => {
    const e2 = () => {
      u2(window.innerWidth <= 640);
    };
    return window.addEventListener("resize", e2), () => window.removeEventListener("resize", e2);
  }, []);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".gallery-container {\n  position: relative;\n  height: 500px;\n  width: 100%;\n  overflow: hidden;\n}\n\n.gallery-gradient {\n  position: absolute;\n  top: 0;\n  height: 100%;\n  width: 48px;\n  z-index: 10;\n}\n\n.gallery-gradient-left {\n  left: 0;\n  background: linear-gradient(to left, rgba(0, 0, 0, 0) 0%, #060010 100%);\n}\n\n.gallery-gradient-right {\n  right: 0;\n  background: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, #060010 100%);\n}\n\n.gallery-content {\n  display: flex;\n  height: 100%;\n  align-items: center;\n  justify-content: center;\n  perspective: 1000px;\n  transform-style: preserve-3d;\n}\n\n.gallery-track {\n  display: flex;\n  height: auto;\n  min-height: 200px;\n  justify-content: center;\n  align-items: center;\n  cursor: grab;\n  transform-style: preserve-3d;\n  width: 100%;\n}\n\n.gallery-item {\n  position: absolute;\n  display: flex;\n  height: fit-content;\n  align-items: center;\n  justify-content: center;\n  padding: 8%;\n  backface-visibility: hidden;\n}\n\n.gallery-img {\n  pointer-events: none;\n  height: 120px;\n  width: 300px;\n  border-radius: 15px;\n  border: 3px solid #fff;\n  object-fit: cover;\n  transition: 0.3s ease;\n}\n\n.gallery-item:hover .gallery-img {\n  transform: scale(1.05);\n  transition: 0.3s ease;\n}\n\n@media (max-width: 768px) {\n  .gallery-item {\n    padding: 6%;\n  }\n  .gallery-img {\n    height: 100px;\n    width: 220px;\n  }\n}\n" }), (0, import_jsx_runtime.jsxs)("div", { className: "gallery-container", children: [(0, import_jsx_runtime.jsx)("div", { className: "gallery-gradient gallery-gradient-left" }), (0, import_jsx_runtime.jsx)("div", { className: "gallery-gradient gallery-gradient-right" }), (0, import_jsx_runtime.jsx)("div", { className: "gallery-content", children: (0, import_jsx_runtime.jsx)(motion.div, { drag: "x", className: "gallery-track", onMouseEnter: () => {
    a2 && s2 && (g2.current && clearInterval(g2.current), v2.stop());
  }, onMouseLeave: () => {
    a2 && s2 && (v2.start({ rotateY: f2.get() - 360 / d2, transition: { duration: 2, ease: "linear" } }), f2.set(f2.get() - 360 / d2), g2.current = setInterval(() => {
      v2.start({ rotateY: f2.get() - 360 / d2, transition: { duration: 2, ease: "linear" } }), f2.set(f2.get() - 360 / d2);
    }, 2e3));
  }, style: { transform: x2, rotateY: f2, width: h2, transformStyle: "preserve-3d" }, onDrag: (e2, t2) => {
    v2.stop(), f2.set(f2.get() + 0.05 * t2.offset.x);
  }, onDragEnd: (e2, t2) => {
    v2.start({ rotateY: f2.get() + 0.05 * t2.velocity.x, transition: { type: "spring", stiffness: 60, damping: 20, mass: 0.1, ease: "easeOut" } });
  }, animate: v2, children: c2.map((t2, n2) => (0, import_jsx_runtime.jsx)("div", { className: "gallery-item", style: { width: `${m2}px`, transform: `rotateY(${360 / d2 * n2}deg) translateZ(${p2}px)` }, children: (0, import_jsx_runtime.jsx)("img", { src: t2, alt: "gallery", className: "gallery-img" }) }, n2)) }) })] })] });
};
function Pi({ children: i2, initialStep: r2 = 1, onStepChange: a2 = () => {
}, onFinalStepCompleted: s2 = () => {
}, stepCircleContainerClassName: c2 = "", stepContainerClassName: l2 = "", contentClassName: u2 = "", footerClassName: d2 = "", backButtonProps: m2 = {}, nextButtonProps: p2 = {}, backButtonText: f2 = "Back", nextButtonText: v2 = "Continue", disableStepIndicators: g2 = false, renderStepIndicator: x2, ...y }) {
  const [w, b] = (0, import_react3.useState)(r2), [M, P] = (0, import_react3.useState)(0), S = import_react3.Children.toArray(i2), C = S.length, E = w > C, z = w === C, _ = (e2) => {
    b(e2), e2 > C ? s2() : a2(e2);
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [" ", (0, import_jsx_runtime.jsx)("style", { children: ".outer-container {\n  display: flex;\n  min-height: 100%;\n  flex: 1 1 0%;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  padding: 1rem;\n}\n\n@media (min-width: 640px) {\n  .outer-container {\n    aspect-ratio: 4 / 3;\n  }\n}\n\n@media (min-width: 768px) {\n  .outer-container {\n    aspect-ratio: 2 / 1;\n  }\n}\n\n.step-circle-container {\n  margin-left: auto;\n  margin-right: auto;\n  width: 100%;\n  max-width: 28rem;\n  border-radius: 2rem;\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),\n    0 10px 10px -5px rgba(0, 0, 0, 0.04);\n}\n\n.step-indicator-row {\n  display: flex;\n  width: 100%;\n  align-items: center;\n  padding: 2rem;\n}\n\n.step-content-default {\n  position: relative;\n  overflow: hidden;\n}\n\n.step-default {\n  padding-left: 2rem;\n  padding-right: 2rem;\n}\n\n.footer-container {\n  padding-left: 2rem;\n  padding-right: 2rem;\n  padding-bottom: 2rem;\n}\n\n.footer-nav {\n  margin-top: 2.5rem;\n  display: flex;\n}\n\n.footer-nav.spread {\n  justify-content: space-between;\n}\n\n.footer-nav.end {\n  justify-content: flex-end;\n}\n\n.back-button {\n  transition: all 350ms;\n  border-radius: 0.25rem;\n  padding: 0.25rem 0.5rem;\n  color: #a3a3a3;\n  cursor: pointer;\n}\n\n.back-button:hover {\n  color: #52525b;\n}\n\n.back-button.inactive {\n  pointer-events: none;\n  opacity: 0.5;\n  color: #a3a3a3;\n}\n\n.next-button {\n  transition: all 350ms;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 9999px;\n  background-color: #5227FF;\n  color: #fff;\n  font-weight: 500;\n  letter-spacing: -0.025em;\n  padding: 0.375rem 0.875rem;\n  cursor: pointer;\n}\n\n.next-button:hover {\n  background-color: #5227FF;\n}\n\n.next-button:active {\n  background-color: #5227FF;\n}\n\n.step-indicator {\n  position: relative;\n  cursor: pointer;\n  outline: none;\n}\n\n.step-indicator-inner {\n  display: flex;\n  height: 2rem;\n  width: 2rem;\n  align-items: center;\n  justify-content: center;\n  border-radius: 9999px;\n  font-weight: 600;\n}\n\n.active-dot {\n  height: 0.75rem;\n  width: 0.75rem;\n  border-radius: 9999px;\n  background-color: #fff;\n}\n\n.step-number {\n  font-size: 0.875rem;\n}\n\n.step-connector {\n  position: relative;\n  margin-left: 0.5rem;\n  margin-right: 0.5rem;\n  height: 0.125rem;\n  flex: 1;\n  overflow: hidden;\n  border-radius: 0.25rem;\n  background-color: #52525b;\n}\n\n.step-connector-inner {\n  position: absolute;\n  left: 0;\n  top: 0;\n  height: 100%;\n}\n\n.check-icon {\n  height: 1rem;\n  width: 1rem;\n  color: #fff;\n}" }), " ", (0, import_jsx_runtime.jsx)("div", { className: "outer-container", ...y, children: (0, import_jsx_runtime.jsxs)("div", { className: `step-circle-container ${c2}`, style: { border: "1px solid #222" }, children: [(0, import_jsx_runtime.jsx)("div", { className: `step-indicator-row ${l2}`, children: S.map((n2, i3) => {
    const r3 = i3 + 1, o2 = i3 < C - 1;
    return (0, import_jsx_runtime.jsxs)(import_react3.default.Fragment, { children: [x2 ? x2({ step: r3, currentStep: w, onStepClick: (e2) => {
      P(e2 > w ? 1 : -1), _(e2);
    } }) : (0, import_jsx_runtime.jsx)(zi, { step: r3, disableStepIndicators: g2, currentStep: w, onClickStep: (e2) => {
      P(e2 > w ? 1 : -1), _(e2);
    } }), o2 && (0, import_jsx_runtime.jsx)(_i, { isComplete: w > r3 })] }, r3);
  }) }), (0, import_jsx_runtime.jsx)(Si, { isCompleted: E, currentStep: w, direction: M, className: `step-content-default ${u2}`, children: S[w - 1] }), !E && (0, import_jsx_runtime.jsx)("div", { className: `footer-container ${d2}`, children: (0, import_jsx_runtime.jsxs)("div", { className: "footer-nav " + (1 !== w ? "spread" : "end"), children: [1 !== w && (0, import_jsx_runtime.jsx)("button", { onClick: () => {
    w > 1 && (P(-1), _(w - 1));
  }, className: "back-button " + (1 === w ? "inactive" : ""), ...m2, children: f2 }), (0, import_jsx_runtime.jsx)("button", { onClick: z ? () => {
    P(1), _(C + 1);
  } : () => {
    z || (P(1), _(w + 1));
  }, className: "next-button", ...p2, children: z ? "Complete" : v2 })] }) })] }) })] });
}
function Si({ isCompleted: t2, currentStep: n2, direction: i2, children: r2, className: a2 }) {
  const [s2, c2] = (0, import_react3.useState)(0);
  return (0, import_jsx_runtime.jsx)(motion.div, { className: a2, style: { position: "relative", overflow: "hidden" }, animate: { height: t2 ? 0 : s2 }, transition: { type: "spring", duration: 0.4 }, children: (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, mode: "sync", custom: i2, children: !t2 && (0, import_jsx_runtime.jsx)(Ci, { direction: i2, onHeightReady: (e2) => c2(e2), children: r2 }, n2) }) });
}
function Ci({ children: t2, direction: n2, onHeightReady: r2 }) {
  const o2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useLayoutEffect)(() => {
    o2.current && r2(o2.current.offsetHeight);
  }, [t2, r2]), (0, import_jsx_runtime.jsx)(motion.div, { ref: o2, custom: n2, variants: Ei, initial: "enter", animate: "center", exit: "exit", transition: { duration: 0.4 }, style: { position: "absolute", left: 0, right: 0, top: 0 }, children: t2 });
}
var Ei = { enter: (e2) => ({ x: e2 >= 0 ? "-100%" : "100%", opacity: 0 }), center: { x: "0%", opacity: 1 }, exit: (e2) => ({ x: e2 >= 0 ? "50%" : "-50%", opacity: 0 }) };
function zi({ step: t2, currentStep: n2, onClickStep: i2, disableStepIndicators: r2 }) {
  const o2 = n2 === t2 ? "active" : n2 < t2 ? "inactive" : "complete";
  return (0, import_jsx_runtime.jsx)(motion.div, { onClick: () => {
    t2 === n2 || r2 || i2(t2);
  }, className: "step-indicator", animate: o2, initial: false, children: (0, import_jsx_runtime.jsx)(motion.div, { variants: { inactive: { scale: 1, backgroundColor: "#222", color: "#a3a3a3" }, active: { scale: 1, backgroundColor: "#5227FF", color: "#5227FF" }, complete: { scale: 1, backgroundColor: "#5227FF", color: "#3b82f6" } }, transition: { duration: 0.3 }, className: "step-indicator-inner", children: "complete" === o2 ? (0, import_jsx_runtime.jsx)(Ti, { className: "check-icon" }) : "active" === o2 ? (0, import_jsx_runtime.jsx)("div", { className: "active-dot" }) : (0, import_jsx_runtime.jsx)("span", { className: "step-number", children: t2 }) }) });
}
function _i({ isComplete: t2 }) {
  return (0, import_jsx_runtime.jsx)("div", { className: "step-connector", children: (0, import_jsx_runtime.jsx)(motion.div, { className: "step-connector-inner", variants: { incomplete: { width: 0, backgroundColor: "transparent" }, complete: { width: "100%", backgroundColor: "#5227FF" } }, initial: false, animate: t2 ? "complete" : "incomplete", transition: { duration: 0.4 } }) });
}
function Ti(t2) {
  return (0, import_jsx_runtime.jsx)("svg", { ...t2, fill: "none", stroke: "currentColor", strokeWidth: 2, viewBox: "0 0 24 24", children: (0, import_jsx_runtime.jsx)(motion.path, { initial: { pathLength: 0 }, animate: { pathLength: 1 }, transition: { delay: 0.1, type: "tween", ease: "easeOut", duration: 0.3 }, strokeLinecap: "round", strokeLinejoin: "round", d: "M5 13l4 4L19 7" }) });
}
function Ai({ className: i2 = "", images: o2 = [], containerWidth: a2 = 400, containerHeight: s2 = 400, animationDelay: c2 = 0.5, animationStagger: l2 = 0.06, easeType: u2 = "elastic.out(1, 0.8)", transformStyles: h2 = ["rotate(10deg) translate(-170px)", "rotate(5deg) translate(-85px)", "rotate(-3deg)", "rotate(-10deg) translate(85px)", "rotate(2deg) translate(170px)"], enableHover: d2 = false }) {
  (0, import_react3.useEffect)(() => {
    (void 0).fromTo(".card", { scale: 0 }, { scale: 1, stagger: l2, ease: u2, delay: c2 });
  }, [l2, u2, c2]);
  const m2 = (e2) => {
    d2 && o2.forEach((t2, n2) => {
      (void 0).killTweensOf(`.card-${n2}`);
      const i3 = h2[n2] || "none";
      if (n2 === e2) {
        const e3 = /rotate\([\s\S]*?\)/.test(r2 = i3) ? r2.replace(/rotate\([\s\S]*?\)/, "rotate(0deg)") : "none" === r2 ? "rotate(0deg)" : `${r2} rotate(0deg)`;
        (void 0).to(`.card-${n2}`, { transform: e3, duration: 0.4, ease: "back.out(1.4)", overwrite: "auto" });
      } else {
        const t3 = ((e3, t4) => {
          const n3 = /translate\(([-0-9.]+)px\)/, i4 = e3.match(n3);
          if (i4) {
            const r4 = parseFloat(i4[1]) + t4;
            return e3.replace(n3, `translate(${r4}px)`);
          }
          return "none" === e3 ? `translate(${t4}px)` : `${e3} translate(${t4}px)`;
        })(i3, n2 < e2 ? -160 : 160), r3 = 0.05 * Math.abs(e2 - n2);
        (void 0).to(`.card-${n2}`, { transform: t3, duration: 0.4, ease: "back.out(1.4)", delay: r3, overwrite: "auto" });
      }
      var r2;
    });
  }, p2 = () => {
    d2 && o2.forEach((e2, t2) => {
      (void 0).killTweensOf(`.card-${t2}`);
      const n2 = h2[t2] || "none";
      (void 0).to(`.card-${t2}`, { transform: n2, duration: 0.4, ease: "back.out(1.4)", overwrite: "auto" });
    });
  };
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".bounceCardsContainer {\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  width: 400px;\n  height: 400px;\n}\n\n.card {\n  position: absolute;\n  width: 200px;\n  aspect-ratio: 1;\n  border: 5px solid #fff;\n  border-radius: 25px;\n  overflow: hidden;\n  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);\n}\n\n.card .image {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}" }), (0, import_jsx_runtime.jsx)("div", { className: `bounceCardsContainer ${i2}`, style: { position: "relative", width: a2, height: s2 }, children: o2.map((t2, n2) => (0, import_jsx_runtime.jsx)("div", { className: `card card-${n2}`, style: { transform: h2[n2] ?? "none" }, onMouseEnter: () => m2(n2), onMouseLeave: p2, children: (0, import_jsx_runtime.jsx)("img", { className: "image", src: t2, alt: `card-${n2}` }) }, n2)) })] });
}
var Ri = (e2) => {
  const t2 = e2.replace("#", "");
  return [parseInt(t2.slice(0, 2), 16) / 255, parseInt(t2.slice(2, 4), 16) / 255, parseInt(t2.slice(4, 6), 16) / 255];
};
var Ii = (0, import_react3.forwardRef)(function({ uniforms: n2 }, i2) {
  const { viewport: r2 } = (void 0)();
  return (0, import_react3.useLayoutEffect)(() => {
    const e2 = i2;
    e2.current && e2.current.scale.set(r2.width, r2.height, 1);
  }, [i2, r2]), (void 0)((e2, t2) => {
    const n3 = i2;
    if (n3.current) {
      n3.current.material.uniforms.uTime.value += 0.1 * t2;
    }
  }), (0, import_jsx_runtime.jsxs)("mesh", { ref: i2, children: [(0, import_jsx_runtime.jsx)("planeGeometry", { args: [1, 1, 1, 1] }), (0, import_jsx_runtime.jsx)("shaderMaterial", { uniforms: n2, vertexShader: "\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvoid main() {\n  vPosition = position;\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n", fragmentShader: "\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nuniform float uTime;\nuniform vec3  uColor;\nuniform float uSpeed;\nuniform float uScale;\nuniform float uRotation;\nuniform float uNoiseIntensity;\n\nconst float e = 2.71828182845904523536;\n\nfloat noise(vec2 texCoord) {\n  float G = e;\n  vec2  r = (G * sin(G * texCoord));\n  return fract(r.x * r.y * (1.0 + texCoord.x));\n}\n\nvec2 rotateUvs(vec2 uv, float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  mat2  rot = mat2(c, -s, s, c);\n  return rot * uv;\n}\n\nvoid main() {\n  float rnd        = noise(gl_FragCoord.xy);\n  vec2  uv         = rotateUvs(vUv * uScale, uRotation);\n  vec2  tex        = uv * uScale;\n  float tOffset    = uSpeed * uTime;\n\n  tex.y += 0.03 * sin(8.0 * tex.x - tOffset);\n\n  float pattern = 0.6 +\n                  0.4 * sin(5.0 * (tex.x + tex.y +\n                                   cos(3.0 * tex.x + 5.0 * tex.y) +\n                                   0.02 * tOffset) +\n                           sin(20.0 * (tex.x + tex.y - 0.1 * tOffset)));\n\n  vec4 col = vec4(uColor, 1.0) * vec4(pattern) - rnd / 15.0 * uNoiseIntensity;\n  col.a = 1.0;\n  gl_FragColor = col;\n}\n" })] });
});
Ii.displayName = "SilkPlane";
var Li = ({ speed: t2 = 5, scale: n2 = 1, color: r2 = "#7B7481", noiseIntensity: o2 = 1.5, rotation: s2 = 0 }) => {
  const c2 = (0, import_react3.useRef)(null), l2 = (0, import_react3.useMemo)(() => ({ uSpeed: { value: t2 }, uScale: { value: n2 }, uNoiseIntensity: { value: o2 }, uColor: { value: new Color2(...Ri(r2)) }, uRotation: { value: s2 }, uTime: { value: 0 } }), [t2, n2, o2, r2, s2]);
  return (0, import_jsx_runtime.jsx)(void 0, { dpr: [1, 2], frameloop: "always", children: (0, import_jsx_runtime.jsx)(Ii, { ref: c2, uniforms: l2 }) });
};
function Fi(o2) {
  const { colorStops: a2 = ["#5227FF", "#7cff67", "#5227FF"], amplitude: s2 = 1, blend: c2 = 0.5 } = o2, l2 = (0, import_react3.useRef)(o2);
  l2.current = o2;
  const u2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = u2.current;
    if (!e2) return;
    const t2 = new Renderer({ alpha: true, premultipliedAlpha: true, antialias: true }), n2 = t2.gl;
    let i2;
    function r2() {
      if (!e2) return;
      const n3 = e2.offsetWidth, r3 = e2.offsetHeight;
      t2.setSize(n3, r3), i2 && (i2.uniforms.uResolution.value = [n3, r3]);
    }
    n2.clearColor(0, 0, 0, 0), n2.enable(n2.BLEND), n2.blendFunc(n2.ONE, n2.ONE_MINUS_SRC_ALPHA), n2.canvas.style.backgroundColor = "transparent", window.addEventListener("resize", r2);
    const o3 = new Triangle(n2);
    o3.attributes.uv && delete o3.attributes.uv;
    const h2 = a2.map((e3) => {
      const t3 = new Color(e3);
      return [t3.r, t3.g, t3.b];
    });
    i2 = new Program(n2, { vertex: "#version 300 es\nin vec2 position;\nvoid main() {\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n", fragment: "#version 300 es\nprecision highp float;\n\nuniform float uTime;\nuniform float uAmplitude;\nuniform vec3 uColorStops[3];\nuniform vec2 uResolution;\nuniform float uBlend;\n\nout vec4 fragColor;\n\nvec3 permute(vec3 x) {\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(\n      0.211324865405187, 0.366025403784439,\n      -0.577350269189626, 0.024390243902439\n  );\n  vec2 i  = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n\n  vec3 p = permute(\n      permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0)\n  );\n\n  vec3 m = max(\n      0.5 - vec3(\n          dot(x0, x0),\n          dot(x12.xy, x12.xy),\n          dot(x12.zw, x12.zw)\n      ), \n      0.0\n  );\n  m = m * m;\n  m = m * m;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nstruct ColorStop {\n  vec3 color;\n  float position;\n};\n\n#define COLOR_RAMP(colors, factor, finalColor) {                int index = 0;                                              for (int i = 0; i < 2; i++) {                                    ColorStop currentColor = colors[i];                         bool isInBetween = currentColor.position <= factor;         index = int(mix(float(index), float(i), float(isInBetween)));   }                                                           ColorStop currentColor = colors[index];                     ColorStop nextColor = colors[index + 1];                    float range = nextColor.position - currentColor.position;   float lerpFactor = (factor - currentColor.position) / range;   finalColor = mix(currentColor.color, nextColor.color, lerpFactor); }\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / uResolution;\n  \n  ColorStop colors[3];\n  colors[0] = ColorStop(uColorStops[0], 0.0);\n  colors[1] = ColorStop(uColorStops[1], 0.5);\n  colors[2] = ColorStop(uColorStops[2], 1.0);\n  \n  vec3 rampColor;\n  COLOR_RAMP(colors, uv.x, rampColor);\n  \n  float height = snoise(vec2(uv.x * 2.0 + uTime * 0.1, uTime * 0.25)) * 0.5 * uAmplitude;\n  height = exp(height);\n  height = (uv.y * 2.0 - height + 0.2);\n  float intensity = 0.6 * height;\n  \n  float midPoint = 0.20;\n  float auroraAlpha = smoothstep(midPoint - uBlend * 0.5, midPoint + uBlend * 0.5, intensity);\n  \n  vec3 auroraColor = intensity * rampColor;\n  \n  fragColor = vec4(auroraColor * auroraAlpha, auroraAlpha);\n}\n", uniforms: { uTime: { value: 0 }, uAmplitude: { value: s2 }, uColorStops: { value: h2 }, uResolution: { value: [e2.offsetWidth, e2.offsetHeight] }, uBlend: { value: c2 } } });
    const d2 = new Mesh(n2, { geometry: o3, program: i2 });
    e2.appendChild(n2.canvas);
    let m2 = 0;
    const p2 = (e3) => {
      m2 = requestAnimationFrame(p2);
      const { time: n3 = 0.01 * e3, speed: r3 = 1 } = l2.current;
      if (i2) {
        i2.uniforms.uTime.value = n3 * r3 * 0.1, i2.uniforms.uAmplitude.value = l2.current.amplitude ?? 1, i2.uniforms.uBlend.value = l2.current.blend ?? c2;
        const e4 = l2.current.colorStops ?? a2;
        i2.uniforms.uColorStops.value = e4.map((e5) => {
          const t3 = new Color(e5);
          return [t3.r, t3.g, t3.b];
        }), t2.render({ scene: d2 });
      }
    };
    return m2 = requestAnimationFrame(p2), r2(), () => {
      var _a;
      cancelAnimationFrame(m2), window.removeEventListener("resize", r2), e2 && n2.canvas.parentNode === e2 && e2.removeChild(n2.canvas), (_a = n2.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
    };
  }, [s2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".aurora-container {\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: u2, className: "aurora-container" })] });
}
var ki = ({ children: t2 }) => (0, import_jsx_runtime.jsx)(void 0, { dpr: [1, 2], frameloop: "always", className: "beams-container", children: t2 });
var Di = (e2) => {
  const t2 = e2.replace("#", "");
  return [parseInt(t2.substring(0, 2), 16) / 255, parseInt(t2.substring(2, 4), 16) / 255, parseInt(t2.substring(4, 6), 16) / 255];
};
var Ni = ({ beamWidth: n2 = 2, beamHeight: r2 = 15, beamNumber: o2 = 12, lightColor: s2 = "#ffffff", speed: c2 = 2, noiseIntensity: l2 = 1.75, scale: u2 = 0.2, rotation: h2 = 0 }) => {
  const d2 = (0, import_react3.useRef)(null), m2 = (0, import_react3.useMemo)(() => function(e2, t2) {
    var _a;
    const n3 = ShaderLib.physical, { vertexShader: i2, fragmentShader: r3, uniforms: o3 } = n3, a2 = n3.defines ?? {}, s3 = UniformsUtils.clone(o3), c3 = new e2(t2.material || {});
    c3.color && (s3.diffuse.value = c3.color), "roughness" in c3 && (s3.roughness.value = c3.roughness), "metalness" in c3 && (s3.metalness.value = c3.metalness), "envMap" in c3 && (s3.envMap.value = c3.envMap), "envMapIntensity" in c3 && (s3.envMapIntensity.value = c3.envMapIntensity), Object.entries(t2.uniforms ?? {}).forEach(([e3, t3]) => {
      s3[e3] = null !== t3 && "object" == typeof t3 && "value" in t3 ? t3 : { value: t3 };
    });
    let l3 = `${t2.header}
${t2.vertexHeader ?? ""}
${i2}`, u3 = `${t2.header}
${t2.fragmentHeader ?? ""}
${r3}`;
    for (const [e3, n4] of Object.entries(t2.vertex ?? {})) l3 = l3.replace(e3, `${e3}
${n4}`);
    for (const [e3, n4] of Object.entries(t2.fragment ?? {})) u3 = u3.replace(e3, `${e3}
${n4}`);
    return new ShaderMaterial({ defines: { ...a2 }, uniforms: s3, vertexShader: l3, fragmentShader: u3, lights: true, fog: !!((_a = t2.material) == null ? void 0 : _a.fog) });
  }(MeshStandardMaterial, { header: "\n  varying vec3 vEye;\n  varying float vNoise;\n  varying vec2 vUv;\n  varying vec3 vPosition;\n  uniform float time;\n  uniform float uSpeed;\n  uniform float uNoiseIntensity;\n  uniform float uScale;\n  \nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) +\n           (c - a)* u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P);\n  vec3 Pi1 = Pi0 + vec3(1.0);\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P);\n  vec3 Pf1 = Pf0 - vec3(1.0);\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));\n  g000 *= norm0.x; g010 *= norm0.y; g100 *= norm0.z; g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));\n  g001 *= norm1.x; g011 *= norm1.y; g101 *= norm1.z; g111 *= norm1.w;\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x,Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x,Pf1.y,Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy,Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy,Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x,Pf0.y,Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x,Pf1.yz));\n  float n111 = dot(g111, Pf1);\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy,n_z.zw,fade_xyz.y);\n  float n_xyz = mix(n_yz.x,n_yz.y,fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n", vertexHeader: "\n  float getPos(vec3 pos) {\n    vec3 noisePos =\n      vec3(pos.x * 0., pos.y - uv.y, pos.z + time * uSpeed * 3.) * uScale;\n    return cnoise(noisePos);\n  }\n  vec3 getCurrentPos(vec3 pos) {\n    vec3 newpos = pos;\n    newpos.z += getPos(pos);\n    return newpos;\n  }\n  vec3 getNormal(vec3 pos) {\n    vec3 curpos = getCurrentPos(pos);\n    vec3 nextposX = getCurrentPos(pos + vec3(0.01, 0.0, 0.0));\n    vec3 nextposZ = getCurrentPos(pos + vec3(0.0, -0.01, 0.0));\n    vec3 tangentX = normalize(nextposX - curpos);\n    vec3 tangentZ = normalize(nextposZ - curpos);\n    return normalize(cross(tangentZ, tangentX));\n  }", fragmentHeader: "", vertex: { "#include <begin_vertex>": "transformed.z += getPos(transformed.xyz);", "#include <beginnormal_vertex>": "objectNormal = getNormal(position.xyz);" }, fragment: { "#include <dithering_fragment>": "\n    float randomNoise = noise(gl_FragCoord.xy);\n    gl_FragColor.rgb -= randomNoise / 15. * uNoiseIntensity;" }, material: { fog: true }, uniforms: { diffuse: new Color2(...Di("#000000")), time: { shared: true, mixed: true, linked: true, value: 0 }, roughness: 0.3, metalness: 0.3, uSpeed: { shared: true, mixed: true, linked: true, value: c2 }, envMapIntensity: 10, uNoiseIntensity: l2, uScale: u2 } }), [c2, l2, u2]);
  return (0, import_jsx_runtime.jsxs)(ki, { children: [(0, import_jsx_runtime.jsxs)("group", { rotation: [0, 0, degToRad(h2)], children: [(0, import_jsx_runtime.jsx)(Ui, { ref: d2, material: m2, count: o2, width: n2, height: r2 }), (0, import_jsx_runtime.jsx)(Oi, { color: s2, position: [0, 3, 10] })] }), (0, import_jsx_runtime.jsx)("ambientLight", { intensity: 1 }), (0, import_jsx_runtime.jsx)("color", { attach: "background", args: ["#000000"] }), (0, import_jsx_runtime.jsx)(void 0, { makeDefault: true, position: [0, 0, 20], fov: 30 })] });
};
var Bi = (0, import_react3.forwardRef)(({ material: t2, width: n2, count: r2, height: o2 }, s2) => {
  const c2 = (0, import_react3.useRef)(null);
  (0, import_react3.useImperativeHandle)(s2, () => c2.current);
  const l2 = (0, import_react3.useMemo)(() => function(e2, t3, n3, i2, r3) {
    const o3 = new BufferGeometry(), a2 = e2 * (r3 + 1) * 2, s3 = e2 * r3 * 2, c3 = new Float32Array(3 * a2), l3 = new Uint32Array(3 * s3), u2 = new Float32Array(2 * a2);
    let h2 = 0, d2 = 0, m2 = 0;
    const p2 = -(e2 * t3 + (e2 - 1) * i2) / 2;
    for (let o4 = 0; o4 < e2; o4++) {
      const e3 = p2 + o4 * (t3 + i2), a3 = 300 * Math.random(), s4 = 300 * Math.random();
      for (let i3 = 0; i3 <= r3; i3++) {
        const o5 = n3 * (i3 / r3 - 0.5), p3 = [e3, o5, 0], f2 = [e3 + t3, o5, 0];
        c3.set([...p3, ...f2], 3 * h2);
        const v2 = i3 / r3;
        if (u2.set([a3, v2 + s4, a3 + 1, v2 + s4], m2), i3 < r3) {
          const e4 = h2, t4 = h2 + 1, n4 = h2 + 2, i4 = h2 + 3;
          l3.set([e4, t4, n4, n4, t4, i4], d2), d2 += 6;
        }
        h2 += 2, m2 += 4;
      }
    }
    return o3.setAttribute("position", new BufferAttribute(c3, 3)), o3.setAttribute("uv", new BufferAttribute(u2, 2)), o3.setIndex(new BufferAttribute(l3, 1)), o3.computeVertexNormals(), o3;
  }(r2, n2, o2, 0, 100), [r2, n2, o2]);
  return (void 0)((e2, t3) => {
    c2.current.material.uniforms.time.value += 0.1 * t3;
  }), (0, import_jsx_runtime.jsx)("mesh", { ref: c2, geometry: l2, material: t2 });
});
Bi.displayName = "MergedPlanes";
var Ui = (0, import_react3.forwardRef)((t2, n2) => (0, import_jsx_runtime.jsx)(Bi, { ref: n2, material: t2.material, width: t2.width, count: t2.count, height: t2.height }));
Ui.displayName = "PlaneNoise";
var Oi = ({ position: o2, color: a2 }) => {
  const s2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    if (!s2.current) return;
    const e2 = s2.current.shadow.camera;
    e2.top = 24, e2.bottom = -24, e2.left = -24, e2.right = 24, e2.far = 64, s2.current.shadow.bias = -4e-3;
  }, []), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".beams-container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("directionalLight", { ref: s2, color: a2, intensity: 1, position: o2 })] });
};
var Vi = ({ hue: o2 = 230, xOffset: a2 = 0, speed: s2 = 1, intensity: c2 = 1, size: l2 = 1 }) => {
  const u2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = u2.current;
    if (!e2) return;
    const t2 = () => {
      e2.width = e2.clientWidth, e2.height = e2.clientHeight;
    };
    t2(), window.addEventListener("resize", t2);
    const n2 = e2.getContext("webgl");
    if (!n2) return;
    const i2 = (e3, t3) => {
      const i3 = n2.createShader(t3);
      return i3 ? (n2.shaderSource(i3, e3), n2.compileShader(i3), n2.getShaderParameter(i3, n2.COMPILE_STATUS) ? i3 : (n2.deleteShader(i3), null)) : null;
    }, r2 = i2("\n      attribute vec2 aPosition;\n      void main() {\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n      }\n    ", n2.VERTEX_SHADER), h2 = i2("\n      precision mediump float;\n      uniform vec2 iResolution;\n      uniform float iTime;\n      uniform float uHue;\n      uniform float uXOffset;\n      uniform float uSpeed;\n      uniform float uIntensity;\n      uniform float uSize;\n      \n      #define OCTAVE_COUNT 10\n\n      vec3 hsv2rgb(vec3 c) {\n          vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n          return c.z * mix(vec3(1.0), rgb, c.y);\n      }\n\n      float hash11(float p) {\n          p = fract(p * .1031);\n          p *= p + 33.33;\n          p *= p + p;\n          return fract(p);\n      }\n\n      float hash12(vec2 p) {\n          vec3 p3 = fract(vec3(p.xyx) * .1031);\n          p3 += dot(p3, p3.yzx + 33.33);\n          return fract((p3.x + p3.y) * p3.z);\n      }\n\n      mat2 rotate2d(float theta) {\n          float c = cos(theta);\n          float s = sin(theta);\n          return mat2(c, -s, s, c);\n      }\n\n      float noise(vec2 p) {\n          vec2 ip = floor(p);\n          vec2 fp = fract(p);\n          float a = hash12(ip);\n          float b = hash12(ip + vec2(1.0, 0.0));\n          float c = hash12(ip + vec2(0.0, 1.0));\n          float d = hash12(ip + vec2(1.0, 1.0));\n          \n          vec2 t = smoothstep(0.0, 1.0, fp);\n          return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n      }\n\n      float fbm(vec2 p) {\n          float value = 0.0;\n          float amplitude = 0.5;\n          for (int i = 0; i < OCTAVE_COUNT; ++i) {\n              value += amplitude * noise(p);\n              p *= rotate2d(0.45);\n              p *= 2.0;\n              amplitude *= 0.5;\n          }\n          return value;\n      }\n\n      void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n          vec2 uv = fragCoord / iResolution.xy;\n          uv = 2.0 * uv - 1.0;\n          uv.x *= iResolution.x / iResolution.y;\n          uv.x += uXOffset;\n          \n          uv += 2.0 * fbm(uv * uSize + 0.8 * iTime * uSpeed) - 1.0;\n          \n          float dist = abs(uv.x);\n          vec3 baseColor = hsv2rgb(vec3(uHue / 360.0, 0.7, 0.8));\n          vec3 col = baseColor * pow(mix(0.0, 0.07, hash11(iTime * uSpeed)) / dist, 1.0) * uIntensity;\n          col = pow(col, vec3(1.0));\n          fragColor = vec4(col, 1.0);\n      }\n\n      void main() {\n          mainImage(gl_FragColor, gl_FragCoord.xy);\n      }\n    ", n2.FRAGMENT_SHADER);
    if (!r2 || !h2) return;
    const d2 = n2.createProgram();
    if (!d2) return;
    if (n2.attachShader(d2, r2), n2.attachShader(d2, h2), n2.linkProgram(d2), !n2.getProgramParameter(d2, n2.LINK_STATUS)) return;
    n2.useProgram(d2);
    const m2 = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), p2 = n2.createBuffer();
    n2.bindBuffer(n2.ARRAY_BUFFER, p2), n2.bufferData(n2.ARRAY_BUFFER, m2, n2.STATIC_DRAW);
    const f2 = n2.getAttribLocation(d2, "aPosition");
    n2.enableVertexAttribArray(f2), n2.vertexAttribPointer(f2, 2, n2.FLOAT, false, 0, 0);
    const v2 = n2.getUniformLocation(d2, "iResolution"), g2 = n2.getUniformLocation(d2, "iTime"), x2 = n2.getUniformLocation(d2, "uHue"), y = n2.getUniformLocation(d2, "uXOffset"), w = n2.getUniformLocation(d2, "uSpeed"), b = n2.getUniformLocation(d2, "uIntensity"), M = n2.getUniformLocation(d2, "uSize"), P = performance.now(), S = () => {
      t2(), n2.viewport(0, 0, e2.width, e2.height), n2.uniform2f(v2, e2.width, e2.height);
      const i3 = performance.now();
      n2.uniform1f(g2, (i3 - P) / 1e3), n2.uniform1f(x2, o2), n2.uniform1f(y, a2), n2.uniform1f(w, s2), n2.uniform1f(b, c2), n2.uniform1f(M, l2), n2.drawArrays(n2.TRIANGLES, 0, 6), requestAnimationFrame(S);
    };
    return requestAnimationFrame(S), () => {
      window.removeEventListener("resize", t2);
    };
  }, [o2, a2, s2, c2, l2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".lightning-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}" }), (0, import_jsx_runtime.jsx)("canvas", { ref: u2, className: "lightning-container" })] });
};
var Xi = class extends Effect {
  constructor() {
    const e2 = /* @__PURE__ */ new Map([["colorNum", new Uniform(4)], ["pixelSize", new Uniform(2)]]);
    super("RetroEffect", "\nprecision highp float;\nuniform float colorNum;\nuniform float pixelSize;\nconst float bayerMatrix8x8[64] = float[64](\n  0.0/64.0, 48.0/64.0, 12.0/64.0, 60.0/64.0,  3.0/64.0, 51.0/64.0, 15.0/64.0, 63.0/64.0,\n  32.0/64.0,16.0/64.0, 44.0/64.0, 28.0/64.0, 35.0/64.0,19.0/64.0, 47.0/64.0, 31.0/64.0,\n  8.0/64.0, 56.0/64.0,  4.0/64.0, 52.0/64.0, 11.0/64.0,59.0/64.0,  7.0/64.0, 55.0/64.0,\n  40.0/64.0,24.0/64.0, 36.0/64.0, 20.0/64.0, 43.0/64.0,27.0/64.0, 39.0/64.0, 23.0/64.0,\n  2.0/64.0, 50.0/64.0, 14.0/64.0, 62.0/64.0,  1.0/64.0,49.0/64.0, 13.0/64.0, 61.0/64.0,\n  34.0/64.0,18.0/64.0, 46.0/64.0, 30.0/64.0, 33.0/64.0,17.0/64.0, 45.0/64.0, 29.0/64.0,\n  10.0/64.0,58.0/64.0,  6.0/64.0, 54.0/64.0,  9.0/64.0,57.0/64.0,  5.0/64.0, 53.0/64.0,\n  42.0/64.0,26.0/64.0, 38.0/64.0, 22.0/64.0, 41.0/64.0,25.0/64.0, 37.0/64.0, 21.0/64.0\n);\n\nvec3 dither(vec2 uv, vec3 color) {\n  vec2 scaledCoord = floor(uv * resolution / pixelSize);\n  int x = int(mod(scaledCoord.x, 8.0));\n  int y = int(mod(scaledCoord.y, 8.0));\n  float threshold = bayerMatrix8x8[y * 8 + x] - 0.25;\n  float step = 1.0 / (colorNum - 1.0);\n  color += threshold * step;\n  float bias = 0.2;\n  color = clamp(color - bias, 0.0, 1.0);\n  return floor(color * (colorNum - 1.0) + 0.5) / (colorNum - 1.0);\n}\n\nvoid mainImage(in vec4 inputColor, in vec2 uv, out vec4 outputColor) {\n  vec2 normalizedPixelSize = pixelSize / resolution;\n  vec2 uvPixel = normalizedPixelSize * floor(uv / normalizedPixelSize);\n  vec4 color = texture2D(inputBuffer, uvPixel);\n  color.rgb = dither(uv, color.rgb);\n  outputColor = color;\n}\n", { uniforms: e2 }), this.uniforms = e2;
  }
  set colorNum(e2) {
    this.uniforms.get("colorNum").value = e2;
  }
  get colorNum() {
    return this.uniforms.get("colorNum").value;
  }
  set pixelSize(e2) {
    this.uniforms.get("pixelSize").value = e2;
  }
  get pixelSize() {
    return this.uniforms.get("pixelSize").value;
  }
};
var qi = (0, import_react3.forwardRef)((t2, n2) => {
  const { colorNum: i2, pixelSize: r2 } = t2, o2 = (void 0)(Xi);
  return (0, import_jsx_runtime.jsx)(o2, { ref: n2, colorNum: i2, pixelSize: r2 });
});
function Yi({ waveSpeed: a2, waveFrequency: s2, waveAmplitude: c2, waveColor: l2, colorNum: u2, pixelSize: h2, disableAnimation: d2, enableMouseInteraction: m2, mouseRadius: p2 }) {
  const f2 = (0, import_react3.useRef)(null), [v2, g2] = (0, import_react3.useState)({ x: 0, y: 0 }), { viewport: x2, size: y, gl: w } = (void 0)(), b = (0, import_react3.useRef)({ time: new Uniform(0), resolution: new Uniform(new Vector2(0, 0)), waveSpeed: new Uniform(a2), waveFrequency: new Uniform(s2), waveAmplitude: new Uniform(c2), waveColor: new Uniform(new Color2(...l2)), mousePos: new Uniform(new Vector2(0, 0)), enableMouseInteraction: new Uniform(m2 ? 1 : 0), mouseRadius: new Uniform(p2) });
  (0, import_react3.useEffect)(() => {
    const e2 = w.getPixelRatio(), t2 = Math.floor(y.width * e2), n2 = Math.floor(y.height * e2), i2 = b.current.resolution.value;
    i2.x === t2 && i2.y === n2 || i2.set(t2, n2);
  }, [y, w]), (void 0)(({ clock: e2 }) => {
    d2 || (b.current.time.value = e2.getElapsedTime()), b.current.waveSpeed.value = a2, b.current.waveFrequency.value = s2, b.current.waveAmplitude.value = c2, b.current.waveColor.value.set(...l2), b.current.enableMouseInteraction.value = m2 ? 1 : 0, b.current.mouseRadius.value = p2, m2 && b.current.mousePos.value.set(v2.x, v2.y);
  });
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)("mesh", { ref: f2, scale: [x2.width, x2.height, 1], children: [(0, import_jsx_runtime.jsx)("planeGeometry", { args: [1, 1] }), (0, import_jsx_runtime.jsx)("shaderMaterial", { vertexShader: "\nprecision highp float;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n  vec4 viewPosition = viewMatrix * modelPosition;\n  gl_Position = projectionMatrix * viewPosition;\n}\n", fragmentShader: "\nprecision highp float;\nuniform vec2 resolution;\nuniform float time;\nuniform float waveSpeed;\nuniform float waveFrequency;\nuniform float waveAmplitude;\nuniform vec3 waveColor;\nuniform vec2 mousePos;\nuniform int enableMouseInteraction;\nuniform float mouseRadius;\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat cnoise(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0,0.0,1.0,1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0,0.0,1.0,1.0);\n  Pi = mod289(Pi);\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = fract(i * (1.0/41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(g00,g00), dot(g01,g01), dot(g10,g10), dot(g11,g11)));\n  g00 *= norm.x; g01 *= norm.y; g10 *= norm.z; g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  return 2.3 * mix(n_x.x, n_x.y, fade_xy.y);\n}\n\nconst int OCTAVES = 8;\nfloat fbm(vec2 p) {\n  float value = 0.0;\n  float amp = 1.0;\n  float freq = waveFrequency;\n  for (int i = 0; i < OCTAVES; i++) {\n    value += amp * abs(cnoise(p));\n    p *= freq;\n    amp *= waveAmplitude;\n  }\n  return value;\n}\n\nfloat pattern(vec2 p) {\n  vec2 p2 = p - time * waveSpeed;\n  return fbm(p - fbm(p + fbm(p2)));\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n  uv -= 0.5;\n  uv.x *= resolution.x / resolution.y;\n  float f = pattern(uv);\n  if (enableMouseInteraction == 1) {\n    vec2 mouseNDC = (mousePos / resolution - 0.5) * vec2(1.0, -1.0);\n    mouseNDC.x *= resolution.x / resolution.y;\n    float dist = length(uv - mouseNDC);\n    float effect = 1.0 - smoothstep(0.0, mouseRadius, dist);\n    f -= 0.5 * effect;\n  }\n  vec3 col = mix(vec3(0.0), waveColor, f);\n  gl_FragColor = vec4(col, 1.0);\n}\n", uniforms: b.current })] }), (0, import_jsx_runtime.jsx)(void 0, { children: (0, import_jsx_runtime.jsx)(qi, { colorNum: u2, pixelSize: h2 }) }), (0, import_jsx_runtime.jsxs)("mesh", { onPointerMove: (e2) => {
    if (!m2) return;
    const t2 = w.domElement.getBoundingClientRect(), n2 = w.getPixelRatio(), i2 = (e2.clientX - t2.left) * n2, r2 = (e2.clientY - t2.top) * n2;
    g2({ x: i2, y: r2 });
  }, position: [0, 0, 0.01], scale: [x2.width, x2.height, 1], visible: false, children: [(0, import_jsx_runtime.jsx)("planeGeometry", { args: [1, 1] }), (0, import_jsx_runtime.jsx)("meshBasicMaterial", { transparent: true, opacity: 0 })] })] });
}
function $i({ waveSpeed: i2 = 0.05, waveFrequency: r2 = 3, waveAmplitude: o2 = 0.3, waveColor: a2 = [0.5, 0.5, 0.5], colorNum: s2 = 4, pixelSize: c2 = 2, disableAnimation: l2 = false, enableMouseInteraction: u2 = true, mouseRadius: h2 = 1 }) {
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".dither-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}" }), (0, import_jsx_runtime.jsx)(void 0, { className: "dither-container", camera: { position: [0, 0, 6] }, dpr: window.devicePixelRatio, gl: { antialias: true, preserveDrawingBuffer: true }, children: (0, import_jsx_runtime.jsx)(Yi, { waveSpeed: i2, waveFrequency: r2, waveAmplitude: o2, waveColor: a2, colorNum: s2, pixelSize: c2, disableAnimation: l2, enableMouseInteraction: u2, mouseRadius: h2 }) })] });
}
function Wi(e2) {
  let t2 = e2.replace("#", ""), n2 = 0, i2 = 0, r2 = 0, o2 = 1;
  return 6 === t2.length ? (n2 = parseInt(t2.slice(0, 2), 16) / 255, i2 = parseInt(t2.slice(2, 4), 16) / 255, r2 = parseInt(t2.slice(4, 6), 16) / 255) : 8 === t2.length && (n2 = parseInt(t2.slice(0, 2), 16) / 255, i2 = parseInt(t2.slice(2, 4), 16) / 255, r2 = parseInt(t2.slice(4, 6), 16) / 255, o2 = parseInt(t2.slice(6, 8), 16) / 255), [n2, i2, r2, o2];
}
qi.displayName = "RetroEffect";
function Hi({ spinRotation: o2 = -2, spinSpeed: a2 = 7, offset: s2 = [0, 0], color1: c2 = "#DE443B", color2: l2 = "#006BB4", color3: u2 = "#162325", contrast: h2 = 3.5, lighting: d2 = 0.4, spinAmount: m2 = 0.25, pixelFilter: p2 = 745, spinEase: f2 = 1, isRotate: v2 = false, mouseInteraction: g2 = true }) {
  const x2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    if (!x2.current) return;
    const e2 = x2.current, t2 = new Renderer(), n2 = t2.gl;
    let i2;
    function r2() {
      t2.setSize(e2.offsetWidth, e2.offsetHeight), i2 && (i2.uniforms.iResolution.value = [n2.canvas.width, n2.canvas.height, n2.canvas.width / n2.canvas.height]);
    }
    n2.clearColor(0, 0, 0, 1), window.addEventListener("resize", r2), r2();
    const y = new Triangle(n2);
    i2 = new Program(n2, { vertex: "\nattribute vec2 uv;\nattribute vec2 position;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0, 1);\n}\n", fragment: "\nprecision highp float;\n\n#define PI 3.14159265359\n\nuniform float iTime;\nuniform vec3 iResolution;\nuniform float uSpinRotation;\nuniform float uSpinSpeed;\nuniform vec2 uOffset;\nuniform vec4 uColor1;\nuniform vec4 uColor2;\nuniform vec4 uColor3;\nuniform float uContrast;\nuniform float uLighting;\nuniform float uSpinAmount;\nuniform float uPixelFilter;\nuniform float uSpinEase;\nuniform bool uIsRotate;\nuniform vec2 uMouse;\n\nvarying vec2 vUv;\n\nvec4 effect(vec2 screenSize, vec2 screen_coords) {\n    float pixel_size = length(screenSize.xy) / uPixelFilter;\n    vec2 uv = (floor(screen_coords.xy * (1.0 / pixel_size)) * pixel_size - 0.5 * screenSize.xy) / length(screenSize.xy) - uOffset;\n    float uv_len = length(uv);\n    \n    float speed = (uSpinRotation * uSpinEase * 0.2);\n    if(uIsRotate){\n       speed = iTime * speed;\n    }\n    speed += 302.2;\n    \n    float mouseInfluence = (uMouse.x * 2.0 - 1.0);\n    speed += mouseInfluence * 0.1;\n    \n    float new_pixel_angle = atan(uv.y, uv.x) + speed - uSpinEase * 20.0 * (uSpinAmount * uv_len + (1.0 - uSpinAmount));\n    vec2 mid = (screenSize.xy / length(screenSize.xy)) / 2.0;\n    uv = (vec2(uv_len * cos(new_pixel_angle) + mid.x, uv_len * sin(new_pixel_angle) + mid.y) - mid);\n    \n    uv *= 30.0;\n    float baseSpeed = iTime * uSpinSpeed;\n    speed = baseSpeed + mouseInfluence * 2.0;\n    \n    vec2 uv2 = vec2(uv.x + uv.y);\n    \n    for(int i = 0; i < 5; i++) {\n        uv2 += sin(max(uv.x, uv.y)) + uv;\n        uv += 0.5 * vec2(\n            cos(5.1123314 + 0.353 * uv2.y + speed * 0.131121),\n            sin(uv2.x - 0.113 * speed)\n        );\n        uv -= cos(uv.x + uv.y) - sin(uv.x * 0.711 - uv.y);\n    }\n    \n    float contrast_mod = (0.25 * uContrast + 0.5 * uSpinAmount + 1.2);\n    float paint_res = min(2.0, max(0.0, length(uv) * 0.035 * contrast_mod));\n    float c1p = max(0.0, 1.0 - contrast_mod * abs(1.0 - paint_res));\n    float c2p = max(0.0, 1.0 - contrast_mod * abs(paint_res));\n    float c3p = 1.0 - min(1.0, c1p + c2p);\n    float light = (uLighting - 0.2) * max(c1p * 5.0 - 4.0, 0.0) + uLighting * max(c2p * 5.0 - 4.0, 0.0);\n    \n    return (0.3 / uContrast) * uColor1 + (1.0 - 0.3 / uContrast) * (uColor1 * c1p + uColor2 * c2p + vec4(c3p * uColor3.rgb, c3p * uColor1.a)) + light;\n}\n\nvoid main() {\n    vec2 uv = vUv * iResolution.xy;\n    gl_FragColor = effect(iResolution.xy, uv);\n}\n", uniforms: { iTime: { value: 0 }, iResolution: { value: [n2.canvas.width, n2.canvas.height, n2.canvas.width / n2.canvas.height] }, uSpinRotation: { value: o2 }, uSpinSpeed: { value: a2 }, uOffset: { value: s2 }, uColor1: { value: Wi(c2) }, uColor2: { value: Wi(l2) }, uColor3: { value: Wi(u2) }, uContrast: { value: h2 }, uLighting: { value: d2 }, uSpinAmount: { value: m2 }, uPixelFilter: { value: p2 }, uSpinEase: { value: f2 }, uIsRotate: { value: v2 }, uMouse: { value: [0.5, 0.5] } } });
    const w = new Mesh(n2, { geometry: y, program: i2 });
    let b;
    function M(t3) {
      if (!g2) return;
      const n3 = e2.getBoundingClientRect(), r3 = (t3.clientX - n3.left) / n3.width, o3 = 1 - (t3.clientY - n3.top) / n3.height;
      i2.uniforms.uMouse.value = [r3, o3];
    }
    return b = requestAnimationFrame(function e3(n3) {
      b = requestAnimationFrame(e3), i2.uniforms.iTime.value = 1e-3 * n3, t2.render({ scene: w });
    }), e2.appendChild(n2.canvas), e2.addEventListener("mousemove", M), () => {
      var _a;
      cancelAnimationFrame(b), window.removeEventListener("resize", r2), e2.removeEventListener("mousemove", M), e2.removeChild(n2.canvas), (_a = n2.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
    };
  }, [o2, a2, s2, c2, l2, u2, h2, d2, m2, p2, f2, v2, g2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".balatro-container {\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: x2, className: "balatro-container" })] });
}
var Gi = ({ className: t2 = "", variation: n2 = 0, pixelRatioProp: o2 = 2, shapeSize: a2 = 1.2, roundness: s2 = 0.4, borderSize: c2 = 0.05, circleSize: l2 = 0.3, circleEdge: u2 = 0.5 }) => {
  const h2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = h2.current;
    let t3, i2 = 0, r2 = 0;
    const d2 = new Vector2(), m2 = new Vector2(), p2 = new Vector2();
    let f2 = 1, v2 = 1;
    const g2 = new Scene(), x2 = new OrthographicCamera();
    x2.position.z = 1;
    const y = new WebGLRenderer({ alpha: true });
    if (y.setClearColor(0, 0), !e2) return;
    e2.appendChild(y.domElement);
    const w = new PlaneGeometry(1, 1), b = new ShaderMaterial({ vertexShader: "\nvarying vec2 v_texcoord;\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    v_texcoord = uv;\n}\n", fragmentShader: "\nvarying vec2 v_texcoord;\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform float u_shapeSize;\nuniform float u_roundness;\nuniform float u_borderSize;\nuniform float u_circleSize;\nuniform float u_circleEdge;\n\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n\n#ifndef VAR\n#define VAR 0\n#endif\n\n#ifndef FNC_COORD\n#define FNC_COORD\nvec2 coord(in vec2 p) {\n    p = p / u_resolution.xy;\n    if (u_resolution.x > u_resolution.y) {\n        p.x *= u_resolution.x / u_resolution.y;\n        p.x += (u_resolution.y - u_resolution.x) / u_resolution.y / 2.0;\n    } else {\n        p.y *= u_resolution.y / u_resolution.x;\n        p.y += (u_resolution.x - u_resolution.y) / u_resolution.x / 2.0;\n    }\n    p -= 0.5;\n    p *= vec2(-1.0, 1.0);\n    return p;\n}\n#endif\n\n#define st0 coord(gl_FragCoord.xy)\n#define mx coord(u_mouse * u_pixelRatio)\n\nfloat sdRoundRect(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\n}\nfloat sdCircle(in vec2 st, in vec2 center) {\n    return length(st - center) * 2.0;\n}\nfloat sdPoly(in vec2 p, in float w, in int sides) {\n    float a = atan(p.x, p.y) + PI;\n    float r = TWO_PI / float(sides);\n    float d = cos(floor(0.5 + a / r) * r - a) * length(max(abs(p) * 1.0, 0.0));\n    return d * 2.0 - w;\n}\n\nfloat aastep(float threshold, float value) {\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold - afwidth, threshold + afwidth, value);\n}\nfloat fill(in float x) { return 1.0 - aastep(0.0, x); }\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\nfloat stroke(in float d, in float t) { return (1.0 - aastep(t, abs(d))); }\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return clamp(d, 0.0, 1.0);\n}\n\nfloat strokeAA(float x, float size, float w, float edge) {\n    float afwidth = length(vec2(dFdx(x), dFdy(x))) * 0.70710678;\n    float d = smoothstep(size - edge - afwidth, size + edge + afwidth, x + w * 0.5)\n            - smoothstep(size - edge - afwidth, size + edge + afwidth, x - w * 0.5);\n    return clamp(d, 0.0, 1.0);\n}\n\nvoid main() {\n    vec2 st = st0 + 0.5;\n    vec2 posMouse = mx * vec2(1., -1.) + 0.5;\n    \n    float size = u_shapeSize;\n    float roundness = u_roundness;\n    float borderSize = u_borderSize;\n    float circleSize = u_circleSize;\n    float circleEdge = u_circleEdge;\n    \n    float sdfCircle = fill(\n        sdCircle(st, posMouse),\n        circleSize,\n        circleEdge\n    );\n    \n    float sdf;\n    if (VAR == 0) {\n        sdf = sdRoundRect(st, vec2(size), roundness);\n        sdf = strokeAA(sdf, 0.0, borderSize, sdfCircle) * 4.0;\n    } else if (VAR == 1) {\n        sdf = sdCircle(st, vec2(0.5));\n        sdf = fill(sdf, 0.6, sdfCircle) * 1.2;\n    } else if (VAR == 2) {\n        sdf = sdCircle(st, vec2(0.5));\n        sdf = strokeAA(sdf, 0.58, 0.02, sdfCircle) * 4.0;\n    } else if (VAR == 3) {\n        sdf = sdPoly(st - vec2(0.5, 0.45), 0.3, 3);\n        sdf = fill(sdf, 0.05, sdfCircle) * 1.4;\n    }\n    \n    vec3 color = vec3(sdf);\n    float alpha = step(0.01, sdf);\n    gl_FragColor = vec4(color.rgb, alpha);\n}\n", uniforms: { u_mouse: { value: m2 }, u_resolution: { value: p2 }, u_pixelRatio: { value: o2 }, u_shapeSize: { value: a2 }, u_roundness: { value: s2 }, u_borderSize: { value: c2 }, u_circleSize: { value: l2 }, u_circleEdge: { value: u2 } }, defines: { VAR: n2 }, transparent: true }), M = new Mesh2(w, b);
    g2.add(M);
    const P = (t4) => {
      if (!e2) return;
      const n3 = e2.getBoundingClientRect();
      d2.set(t4.clientX - n3.left, t4.clientY - n3.top);
    };
    document.addEventListener("mousemove", P), document.addEventListener("pointermove", P);
    const S = () => {
      const e3 = h2.current;
      if (!e3) return;
      f2 = e3.clientWidth, v2 = e3.clientHeight;
      const t4 = Math.min(window.devicePixelRatio, 2);
      y.setSize(f2, v2), y.setPixelRatio(t4), x2.left = -f2 / 2, x2.right = f2 / 2, x2.top = v2 / 2, x2.bottom = -v2 / 2, x2.updateProjectionMatrix(), M.scale.set(f2, v2, 1), p2.set(f2, v2).multiplyScalar(t4), b.uniforms.u_pixelRatio.value = t4;
    };
    S(), window.addEventListener("resize", S);
    const C = new ResizeObserver(() => S());
    h2.current && C.observe(h2.current);
    const E = () => {
      i2 = 1e-3 * performance.now();
      const e3 = i2 - r2;
      r2 = i2, m2.x = MathUtils.damp(m2.x, d2.x, 8, e3), m2.y = MathUtils.damp(m2.y, d2.y, 8, e3), y.render(g2, x2), t3 = requestAnimationFrame(E);
    };
    return E(), () => {
      cancelAnimationFrame(t3), window.removeEventListener("resize", S), C && C.disconnect(), document.removeEventListener("mousemove", P), document.removeEventListener("pointermove", P), e2.removeChild(y.domElement), y.dispose();
    };
  }, [n2, o2, a2, s2, c2, l2, u2]), (0, import_jsx_runtime.jsx)("div", { className: t2, ref: h2, style: { width: "100%", height: "100%" } });
};
(void 0).registerPlugin(void 0);
var ji = (e2, t2) => {
  let n2 = 0;
  return function(...i2) {
    const r2 = performance.now();
    r2 - n2 >= t2 && (n2 = r2, e2.apply(this, i2));
  };
};
function Zi(e2) {
  const t2 = e2.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
  return t2 ? { r: parseInt(t2[1], 16), g: parseInt(t2[2], 16), b: parseInt(t2[3], 16) } : { r: 0, g: 0, b: 0 };
}
var Ki = ({ dotSize: o2 = 16, gap: s2 = 32, baseColor: c2 = "#5227FF", activeColor: u2 = "#5227FF", proximity: h2 = 150, speedTrigger: d2 = 100, shockRadius: m2 = 250, shockStrength: p2 = 5, maxSpeed: f2 = 5e3, resistance: g2 = 750, returnDuration: x2 = 1.5, className: y = "", style: w }) => {
  const b = (0, import_react3.useRef)(null), M = (0, import_react3.useRef)(null), P = (0, import_react3.useRef)([]), S = (0, import_react3.useRef)({ x: 0, y: 0, vx: 0, vy: 0, speed: 0, lastTime: 0, lastX: 0, lastY: 0 }), C = (0, import_react3.useMemo)(() => Zi(c2), [c2]), E = (0, import_react3.useMemo)(() => Zi(u2), [u2]), z = (0, import_react3.useMemo)(() => {
    const e2 = new Path2D();
    return e2.arc(0, 0, o2 / 2, 0, 2 * Math.PI), e2;
  }, [o2]), _ = (0, import_react3.useCallback)(() => {
    const e2 = b.current, t2 = M.current;
    if (!e2 || !t2) return;
    const { width: n2, height: i2 } = e2.getBoundingClientRect(), r2 = window.devicePixelRatio || 1;
    t2.width = n2 * r2, t2.height = i2 * r2, t2.style.width = `${n2}px`, t2.style.height = `${i2}px`;
    const a2 = t2.getContext("2d");
    a2 && a2.scale(r2, r2);
    const c3 = Math.floor((n2 + s2) / (o2 + s2)), l2 = Math.floor((i2 + s2) / (o2 + s2)), u3 = o2 + s2, h3 = (n2 - (u3 * c3 - s2)) / 2 + o2 / 2, d3 = (i2 - (u3 * l2 - s2)) / 2 + o2 / 2, m3 = [];
    for (let e3 = 0; e3 < l2; e3++) for (let t3 = 0; t3 < c3; t3++) {
      const n3 = h3 + t3 * u3, i3 = d3 + e3 * u3;
      m3.push({ cx: n3, cy: i3, xOffset: 0, yOffset: 0, _inertiaApplied: false });
    }
    P.current = m3;
  }, [o2, s2]);
  return (0, import_react3.useEffect)(() => {
    let e2;
    const t2 = h2 * h2, n2 = () => {
      const i2 = M.current;
      if (!i2) return;
      const r2 = i2.getContext("2d");
      if (!r2) return;
      r2.clearRect(0, 0, i2.width, i2.height);
      const { x: o3, y: a2 } = S.current;
      for (const e3 of P.current) {
        const n3 = e3.cx + e3.xOffset, i3 = e3.cy + e3.yOffset, s3 = e3.cx - o3, l2 = e3.cy - a2, u3 = s3 * s3 + l2 * l2;
        let d3 = c2;
        if (u3 <= t2) {
          const e4 = 1 - Math.sqrt(u3) / h2;
          d3 = `rgb(${Math.round(C.r + (E.r - C.r) * e4)},${Math.round(C.g + (E.g - C.g) * e4)},${Math.round(C.b + (E.b - C.b) * e4)})`;
        }
        r2.save(), r2.translate(n3, i3), r2.fillStyle = d3, r2.fill(z), r2.restore();
      }
      e2 = requestAnimationFrame(n2);
    };
    return n2(), () => cancelAnimationFrame(e2);
  }, [h2, c2, E, C, z]), (0, import_react3.useEffect)(() => {
    _();
    let e2 = null;
    return "ResizeObserver" in window ? (e2 = new ResizeObserver(_), b.current && e2.observe(b.current)) : window.addEventListener("resize", _), () => {
      e2 ? e2.disconnect() : window.removeEventListener("resize", _);
    };
  }, [_]), (0, import_react3.useEffect)(() => {
    const e2 = (e3) => {
      const t3 = M.current.getBoundingClientRect(), n2 = e3.clientX - t3.left, i2 = e3.clientY - t3.top;
      for (const e4 of P.current) {
        const t4 = Math.hypot(e4.cx - n2, e4.cy - i2);
        if (t4 < m2 && !e4._inertiaApplied) {
          e4._inertiaApplied = true, (void 0).killTweensOf(e4);
          const r2 = Math.max(0, 1 - t4 / m2), o3 = (e4.cx - n2) * p2 * r2, a2 = (e4.cy - i2) * p2 * r2;
          (void 0).to(e4, { inertia: { xOffset: o3, yOffset: a2, resistance: g2 }, onComplete: () => {
            (void 0).to(e4, { xOffset: 0, yOffset: 0, duration: x2, ease: "elastic.out(1,0.75)" }), e4._inertiaApplied = false;
          } });
        }
      }
    }, t2 = ji((e3) => {
      const t3 = performance.now(), n2 = S.current, i2 = n2.lastTime ? t3 - n2.lastTime : 16;
      let r2 = (e3.clientX - n2.lastX) / i2 * 1e3, o3 = (e3.clientY - n2.lastY) / i2 * 1e3, a2 = Math.hypot(r2, o3);
      if (a2 > f2) {
        const e4 = f2 / a2;
        r2 *= e4, o3 *= e4, a2 = f2;
      }
      n2.lastTime = t3, n2.lastX = e3.clientX, n2.lastY = e3.clientY, n2.vx = r2, n2.vy = o3, n2.speed = a2;
      const s3 = M.current.getBoundingClientRect();
      n2.x = e3.clientX - s3.left, n2.y = e3.clientY - s3.top;
      for (const e4 of P.current) {
        const t4 = Math.hypot(e4.cx - n2.x, e4.cy - n2.y);
        if (a2 > d2 && t4 < h2 && !e4._inertiaApplied) {
          e4._inertiaApplied = true, (void 0).killTweensOf(e4);
          const t5 = e4.cx - n2.x + 5e-3 * r2, i3 = e4.cy - n2.y + 5e-3 * o3;
          (void 0).to(e4, { inertia: { xOffset: t5, yOffset: i3, resistance: g2 }, onComplete: () => {
            (void 0).to(e4, { xOffset: 0, yOffset: 0, duration: x2, ease: "elastic.out(1,0.75)" }), e4._inertiaApplied = false;
          } });
        }
      }
    }, 50);
    return window.addEventListener("mousemove", t2, { passive: true }), window.addEventListener("click", e2), () => {
      window.removeEventListener("mousemove", t2), window.removeEventListener("click", e2);
    };
  }, [f2, d2, h2, g2, x2, m2, p2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".dot-grid {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  width: 100%;\n  position: relative;\n}\n\n.dot-grid__wrap {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n\n.dot-grid__canvas {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n}" }), (0, import_jsx_runtime.jsx)("section", { className: `dot-grid ${y}`, style: w, children: (0, import_jsx_runtime.jsx)("div", { ref: b, className: "dot-grid__wrap", children: (0, import_jsx_runtime.jsx)("canvas", { ref: M, className: "dot-grid__canvas" }) }) })] });
};
var Qi = ({ color: o2 = [1, 1, 1], amplitude: a2 = 1, distance: s2 = 0, enableMouseInteraction: c2 = false, ...l2 }) => {
  const u2 = (0, import_react3.useRef)(null), h2 = (0, import_react3.useRef)(void 0);
  return (0, import_react3.useEffect)(() => {
    if (!u2.current) return;
    const e2 = u2.current, t2 = new Renderer({ alpha: true }), n2 = t2.gl;
    n2.clearColor(0, 0, 0, 0), n2.enable(n2.BLEND), n2.blendFunc(n2.SRC_ALPHA, n2.ONE_MINUS_SRC_ALPHA), e2.appendChild(n2.canvas);
    const i2 = new Triangle(n2), r2 = new Program(n2, { vertex: "\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0.0, 1.0);\n}\n", fragment: "\nprecision highp float;\n\nuniform float iTime;\nuniform vec3 iResolution;\nuniform vec3 uColor;\nuniform float uAmplitude;\nuniform float uDistance;\nuniform vec2 uMouse;\n\n#define PI 3.1415926538\n\nconst int u_line_count = 40;\nconst float u_line_width = 7.0;\nconst float u_line_blur = 10.0;\n\nfloat Perlin2D(vec2 P) {\n    vec2 Pi = floor(P);\n    vec4 Pf_Pfmin1 = P.xyxy - vec4(Pi, Pi + 1.0);\n    vec4 Pt = vec4(Pi.xy, Pi.xy + 1.0);\n    Pt = Pt - floor(Pt * (1.0 / 71.0)) * 71.0;\n    Pt += vec2(26.0, 161.0).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec4 hash_x = fract(Pt * (1.0 / 951.135664));\n    vec4 hash_y = fract(Pt * (1.0 / 642.949883));\n    vec4 grad_x = hash_x - 0.49999;\n    vec4 grad_y = hash_y - 0.49999;\n    vec4 grad_results = inversesqrt(grad_x * grad_x + grad_y * grad_y)\n        * (grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww);\n    grad_results *= 1.4142135623730950;\n    vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy\n               * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);\n    vec4 blend2 = vec4(blend, vec2(1.0 - blend));\n    return dot(grad_results, blend2.zxzx * blend2.wwyy);\n}\n\nfloat pixel(float count, vec2 resolution) {\n    return (1.0 / max(resolution.x, resolution.y)) * count;\n}\n\nfloat lineFn(vec2 st, float width, float perc, float offset, vec2 mouse, float time, float amplitude, float distance) {\n    float split_offset = (perc * 0.4);\n    float split_point = 0.1 + split_offset;\n\n    float amplitude_normal = smoothstep(split_point, 0.7, st.x);\n    float amplitude_strength = 0.5;\n    float finalAmplitude = amplitude_normal * amplitude_strength\n                           * amplitude * (1.0 + (mouse.y - 0.5) * 0.2);\n\n    float time_scaled = time / 10.0 + (mouse.x - 0.5) * 1.0;\n    float blur = smoothstep(split_point, split_point + 0.05, st.x) * perc;\n\n    float xnoise = mix(\n        Perlin2D(vec2(time_scaled, st.x + perc) * 2.5),\n        Perlin2D(vec2(time_scaled, st.x + time_scaled) * 3.5) / 1.5,\n        st.x * 0.3\n    );\n\n    float y = 0.5 + (perc - 0.5) * distance + xnoise / 2.0 * finalAmplitude;\n\n    float line_start = smoothstep(\n        y + (width / 2.0) + (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n        y,\n        st.y\n    );\n\n    float line_end = smoothstep(\n        y,\n        y - (width / 2.0) - (u_line_blur * pixel(1.0, iResolution.xy) * blur),\n        st.y\n    );\n\n    return clamp(\n        (line_start - line_end) * (1.0 - smoothstep(0.0, 1.0, pow(perc, 0.3))),\n        0.0,\n        1.0\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    float line_strength = 1.0;\n    for (int i = 0; i < u_line_count; i++) {\n        float p = float(i) / float(u_line_count);\n        line_strength *= (1.0 - lineFn(\n            uv,\n            u_line_width * pixel(1.0, iResolution.xy) * (1.0 - p),\n            p,\n            (PI * 1.0) * p,\n            uMouse,\n            iTime,\n            uAmplitude,\n            uDistance\n        ));\n    }\n\n    float colorVal = 1.0 - line_strength;\n    fragColor = vec4(uColor * colorVal, colorVal);\n}\n\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", uniforms: { iTime: { value: 0 }, iResolution: { value: new Color(n2.canvas.width, n2.canvas.height, n2.canvas.width / n2.canvas.height) }, uColor: { value: new Color(...o2) }, uAmplitude: { value: a2 }, uDistance: { value: s2 }, uMouse: { value: new Float32Array([0.5, 0.5]) } } }), l3 = new Mesh(n2, { geometry: i2, program: r2 });
    function d2() {
      const { clientWidth: n3, clientHeight: i3 } = e2;
      t2.setSize(n3, i3), r2.uniforms.iResolution.value.r = n3, r2.uniforms.iResolution.value.g = i3, r2.uniforms.iResolution.value.b = n3 / i3;
    }
    window.addEventListener("resize", d2), d2();
    let m2 = [0.5, 0.5], p2 = [0.5, 0.5];
    function f2(t3) {
      const n3 = e2.getBoundingClientRect(), i3 = (t3.clientX - n3.left) / n3.width, r3 = 1 - (t3.clientY - n3.top) / n3.height;
      p2 = [i3, r3];
    }
    function v2() {
      p2 = [0.5, 0.5];
    }
    return c2 && (e2.addEventListener("mousemove", f2), e2.addEventListener("mouseleave", v2)), h2.current = requestAnimationFrame(function e3(n3) {
      if (c2) {
        const e4 = 0.05;
        m2[0] += e4 * (p2[0] - m2[0]), m2[1] += e4 * (p2[1] - m2[1]), r2.uniforms.uMouse.value[0] = m2[0], r2.uniforms.uMouse.value[1] = m2[1];
      } else r2.uniforms.uMouse.value[0] = 0.5, r2.uniforms.uMouse.value[1] = 0.5;
      r2.uniforms.iTime.value = 1e-3 * n3, t2.render({ scene: l3 }), h2.current = requestAnimationFrame(e3);
    }), () => {
      var _a;
      h2.current && cancelAnimationFrame(h2.current), window.removeEventListener("resize", d2), c2 && (e2.removeEventListener("mousemove", f2), e2.removeEventListener("mouseleave", v2)), e2.contains(n2.canvas) && e2.removeChild(n2.canvas), (_a = n2.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
    };
  }, [o2, a2, s2, c2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".threads-container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: u2, className: "threads-container", ...l2 })] });
};
var Ji = { onSpeedUp: () => {
}, onSlowDown: () => {
}, distortion: "turbulentDistortion", length: 400, roadWidth: 10, islandWidth: 2, lanesPerRoad: 4, fov: 90, fovSpeedUp: 150, speedUp: 2, carLightsFade: 0.4, totalSideLightSticks: 20, lightPairsPerRoadWay: 40, shoulderLinesWidthPercentage: 0.05, brokenLinesWidthPercentage: 0.1, brokenLinesLengthPercentage: 0.5, lightStickWidth: [0.12, 0.5], lightStickHeight: [1.3, 1.7], movingAwaySpeed: [60, 80], movingCloserSpeed: [-120, -160], carLightsLength: [12, 80], carLightsRadius: [0.05, 0.14], carWidthPercentage: [0.3, 0.5], carShiftX: [-0.8, 0.8], carFloorSeparation: [0, 5], colors: { roadColor: 526344, islandColor: 657930, background: 0, shoulderLines: 16777215, brokenLines: 16777215, leftCars: [14177983, 6770850, 12732332], rightCars: [242627, 941733, 3294549], sticks: 242627 } };
function er(e2) {
  return 0.5 * Math.sin(e2) + 0.5;
}
var tr = { uFreq: { value: new Vector3(3, 6, 10) }, uAmp: { value: new Vector3(30, 30, 20) } };
var nr = { uFreq: { value: new Vector2(5, 2) }, uAmp: { value: new Vector2(25, 15) } };
var ir = { uFreq: { value: new Vector2(2, 3) }, uAmp: { value: new Vector2(35, 10) } };
var rr = { uFreq: { value: new Vector4(4, 8, 8, 1) }, uAmp: { value: new Vector4(25, 5, 10, 10) } };
var or = { uFreq: { value: new Vector2(4, 8) }, uAmp: { value: new Vector2(10, 20) }, uPowY: { value: new Vector2(20, 2) } };
var ar = { mountainDistortion: { uniforms: tr, getDistortion: "\n      uniform vec3 uAmp;\n      uniform vec3 uFreq;\n      #define PI 3.14159265358979\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      vec3 getDistortion(float progress){\n        float movementProgressFix = 0.02;\n        return vec3( \n          cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n          nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\n          nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\n        );\n      }\n    ", getJS: (e2, t2) => {
  const n2 = 0.02, i2 = tr.uFreq.value, r2 = tr.uAmp.value, o2 = new Vector3(Math.cos(e2 * Math.PI * i2.x + t2) * r2.x - Math.cos(n2 * Math.PI * i2.x + t2) * r2.x, er(e2 * Math.PI * i2.y + t2) * r2.y - er(n2 * Math.PI * i2.y + t2) * r2.y, er(e2 * Math.PI * i2.z + t2) * r2.z - er(n2 * Math.PI * i2.z + t2) * r2.z), a2 = new Vector3(2, 2, 2), s2 = new Vector3(0, 0, -5);
  return o2.multiply(a2).add(s2);
} }, xyDistortion: { uniforms: nr, getDistortion: "\n      uniform vec2 uFreq;\n      uniform vec2 uAmp;\n      #define PI 3.14159265358979\n      vec3 getDistortion(float progress){\n        float movementProgressFix = 0.02;\n        return vec3( \n          cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n          sin(progress * PI * uFreq.y + PI/2. + uTime) * uAmp.y - sin(movementProgressFix * PI * uFreq.y + PI/2. + uTime) * uAmp.y,\n          0.\n        );\n      }\n    ", getJS: (e2, t2) => {
  const n2 = nr.uFreq.value, i2 = nr.uAmp.value, r2 = new Vector3(Math.cos(e2 * Math.PI * n2.x + t2) * i2.x - Math.cos(0.02 * Math.PI * n2.x + t2) * i2.x, Math.sin(e2 * Math.PI * n2.y + t2 + Math.PI / 2) * i2.y - Math.sin(0.02 * Math.PI * n2.y + t2 + Math.PI / 2) * i2.y, 0), o2 = new Vector3(2, 0.4, 1), a2 = new Vector3(0, 0, -3);
  return r2.multiply(o2).add(a2);
} }, LongRaceDistortion: { uniforms: ir, getDistortion: "\n      uniform vec2 uFreq;\n      uniform vec2 uAmp;\n      #define PI 3.14159265358979\n      vec3 getDistortion(float progress){\n        float camProgress = 0.0125;\n        return vec3( \n          sin(progress * PI * uFreq.x + uTime) * uAmp.x - sin(camProgress * PI * uFreq.x + uTime) * uAmp.x,\n          sin(progress * PI * uFreq.y + uTime) * uAmp.y - sin(camProgress * PI * uFreq.y + uTime) * uAmp.y,\n          0.\n        );\n      }\n    ", getJS: (e2, t2) => {
  const n2 = 0.0125, i2 = ir.uFreq.value, r2 = ir.uAmp.value, o2 = new Vector3(Math.sin(e2 * Math.PI * i2.x + t2) * r2.x - Math.sin(n2 * Math.PI * i2.x + t2) * r2.x, Math.sin(e2 * Math.PI * i2.y + t2) * r2.y - Math.sin(n2 * Math.PI * i2.y + t2) * r2.y, 0), a2 = new Vector3(1, 1, 0), s2 = new Vector3(0, 0, -5);
  return o2.multiply(a2).add(s2);
} }, turbulentDistortion: { uniforms: rr, getDistortion: "\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          cos(PI * progress * uFreq.r + uTime) * uAmp.r +\n          pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +\n          -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.0125),\n          getDistortionY(progress) - getDistortionY(0.0125),\n          0.\n        );\n      }\n    ", getJS: (e2, t2) => {
  const n2 = rr.uFreq.value, i2 = rr.uAmp.value, r2 = (e3) => Math.cos(Math.PI * e3 * n2.x + t2) * i2.x + Math.pow(Math.cos(Math.PI * e3 * n2.y + t2 * (n2.y / n2.x)), 2) * i2.y, o2 = (e3) => -er(Math.PI * e3 * n2.z + t2) * i2.z - Math.pow(er(Math.PI * e3 * n2.w + t2 / (n2.z / n2.w)), 5) * i2.w, a2 = new Vector3(r2(e2) - r2(e2 + 7e-3), o2(e2) - o2(e2 + 7e-3), 0), s2 = new Vector3(-2, -5, 0), c2 = new Vector3(0, 0, -10);
  return a2.multiply(s2).add(c2);
} }, turbulentDistortionStill: { uniforms: rr, getDistortion: "\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          cos(PI * progress * uFreq.r) * uAmp.r +\n          pow(cos(PI * progress * uFreq.g * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          -nsin(PI * progress * uFreq.b) * uAmp.b +\n          -pow(nsin(PI * progress * uFreq.a / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.02),\n          0.\n        );\n      }\n    " }, deepDistortionStill: { uniforms: or, getDistortion: "\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      uniform vec2 uPowY;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          sin(progress * PI * uFreq.x) * uAmp.x * 2.\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y) * uAmp.y\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.05),\n          0.\n        );\n      }\n    " }, deepDistortion: { uniforms: or, getDistortion: "\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      uniform vec2 uPowY;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          sin(progress * PI * uFreq.x + uTime) * uAmp.x\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.02),\n          0.\n        );\n      }\n    ", getJS: (e2, t2) => {
  const n2 = or.uFreq.value, i2 = or.uAmp.value, r2 = or.uPowY.value, o2 = (e3) => Math.sin(e3 * Math.PI * n2.x + t2) * i2.x, a2 = (e3) => Math.pow(e3 * r2.x, r2.y) + Math.sin(e3 * Math.PI * n2.y + t2) * i2.y, s2 = new Vector3(o2(e2) - o2(e2 + 0.01), a2(e2) - a2(e2 + 0.01), 0), c2 = new Vector3(-2, -4, 0), l2 = new Vector3(0, 0, -10);
  return s2.multiply(c2).add(l2);
} } };
var sr = { uDistortionX: { value: new Vector2(80, 3) }, uDistortionY: { value: new Vector2(-40, 2.5) } };
function cr(e2) {
  return Array.isArray(e2) ? Math.random() * (e2[1] - e2[0]) + e2[0] : Math.random() * e2;
}
function lr(e2) {
  return Array.isArray(e2) ? e2[Math.floor(Math.random() * e2.length)] : e2;
}
function ur(e2, t2, n2 = 0.1, i2 = 1e-3) {
  let r2 = (t2 - e2) * n2;
  return Math.abs(r2) < i2 && (r2 = t2 - e2), r2;
}
var hr = class {
  constructor(e2, t2, n2, i2, r2) {
    this.webgl = e2, this.options = t2, this.colors = n2, this.speed = i2, this.fade = r2;
  }
  init() {
    const e2 = this.options, t2 = new LineCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, -1)), n2 = new TubeGeometry(t2, 40, 1, 8, false), i2 = new InstancedBufferGeometry().copy(n2);
    i2.instanceCount = 2 * e2.lightPairsPerRoadWay;
    const r2 = e2.roadWidth / e2.lanesPerRoad, o2 = [], a2 = [], s2 = [];
    let c2;
    c2 = Array.isArray(this.colors) ? this.colors.map((e3) => new Color2(e3)) : [new Color2(this.colors)];
    for (let t3 = 0; t3 < e2.lightPairsPerRoadWay; t3++) {
      const n3 = cr(e2.carLightsRadius), i3 = cr(e2.carLightsLength), l3 = cr(this.speed);
      let u3 = t3 % e2.lanesPerRoad * r2 - e2.roadWidth / 2 + r2 / 2;
      const h2 = cr(e2.carWidthPercentage) * r2;
      u3 += cr(e2.carShiftX) * r2;
      const d2 = cr(e2.carFloorSeparation) + 1.3 * n3, m2 = -cr(e2.length);
      o2.push(u3 - h2 / 2), o2.push(d2), o2.push(m2), o2.push(u3 + h2 / 2), o2.push(d2), o2.push(m2), a2.push(n3), a2.push(i3), a2.push(l3), a2.push(n3), a2.push(i3), a2.push(l3);
      const p2 = lr(c2);
      s2.push(p2.r), s2.push(p2.g), s2.push(p2.b), s2.push(p2.r), s2.push(p2.g), s2.push(p2.b);
    }
    i2.setAttribute("aOffset", new InstancedBufferAttribute(new Float32Array(o2), 3, false)), i2.setAttribute("aMetrics", new InstancedBufferAttribute(new Float32Array(a2), 3, false)), i2.setAttribute("aColor", new InstancedBufferAttribute(new Float32Array(s2), 3, false));
    const l2 = new ShaderMaterial({ fragmentShader: dr, vertexShader: mr, transparent: true, uniforms: Object.assign({ uTime: { value: 0 }, uTravelLength: { value: e2.length }, uFade: { value: this.fade } }, this.webgl.fogUniforms, ("object" == typeof this.options.distortion ? this.options.distortion.uniforms : {}) || {}) });
    l2.onBeforeCompile = (e3) => {
      e3.vertexShader = e3.vertexShader.replace("#include <getDistortion_vertex>", "object" == typeof this.options.distortion ? this.options.distortion.getDistortion : "");
    };
    const u2 = new Mesh2(i2, l2);
    u2.frustumCulled = false, this.webgl.scene.add(u2), this.mesh = u2;
  }
  update(e2) {
    this.mesh.material.uniforms.uTime && (this.mesh.material.uniforms.uTime.value = e2);
  }
};
var dr = `
  #define USE_FOG;
  ${ShaderChunk.fog_pars_fragment}
  varying vec3 vColor;
  varying vec2 vUv; 
  uniform vec2 uFade;
  void main() {
    vec3 color = vec3(vColor);
    float alpha = smoothstep(uFade.x, uFade.y, vUv.x);
    gl_FragColor = vec4(color, alpha);
    if (gl_FragColor.a < 0.0001) discard;
    ${ShaderChunk.fog_fragment}
  }
`;
var mr = `
  #define USE_FOG;
  ${ShaderChunk.fog_pars_vertex}
  attribute vec3 aOffset;
  attribute vec3 aMetrics;
  attribute vec3 aColor;
  uniform float uTravelLength;
  uniform float uTime;
  varying vec2 vUv; 
  varying vec3 vColor; 
  #include <getDistortion_vertex>
  void main() {
    vec3 transformed = position.xyz;
    float radius = aMetrics.r;
    float myLength = aMetrics.g;
    float speed = aMetrics.b;

    transformed.xy *= radius;
    transformed.z *= myLength;

    transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);
    transformed.xy += aOffset.xy;

    float progress = abs(transformed.z / uTravelLength);
    transformed.xyz += getDistortion(progress);

    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
    gl_Position = projectionMatrix * mvPosition;
    vUv = uv;
    vColor = aColor;
    ${ShaderChunk.fog_vertex}
  }
`;
var pr = class {
  constructor(e2, t2) {
    this.webgl = e2, this.options = t2;
  }
  init() {
    const e2 = this.options, t2 = new PlaneGeometry(1, 1), n2 = new InstancedBufferGeometry().copy(t2), i2 = e2.totalSideLightSticks;
    n2.instanceCount = i2;
    const r2 = e2.length / (i2 - 1), o2 = [], a2 = [], s2 = [];
    let c2;
    c2 = Array.isArray(e2.colors.sticks) ? e2.colors.sticks.map((e3) => new Color2(e3)) : [new Color2(e2.colors.sticks)];
    for (let t3 = 0; t3 < i2; t3++) {
      const n3 = cr(e2.lightStickWidth), i3 = cr(e2.lightStickHeight);
      o2.push((t3 - 1) * r2 * 2 + r2 * Math.random());
      const l3 = lr(c2);
      a2.push(l3.r), a2.push(l3.g), a2.push(l3.b), s2.push(n3), s2.push(i3);
    }
    n2.setAttribute("aOffset", new InstancedBufferAttribute(new Float32Array(o2), 1, false)), n2.setAttribute("aColor", new InstancedBufferAttribute(new Float32Array(a2), 3, false)), n2.setAttribute("aMetrics", new InstancedBufferAttribute(new Float32Array(s2), 2, false));
    const l2 = new ShaderMaterial({ fragmentShader: vr, vertexShader: fr, side: DoubleSide, uniforms: Object.assign({ uTravelLength: { value: e2.length }, uTime: { value: 0 } }, this.webgl.fogUniforms, ("object" == typeof e2.distortion ? e2.distortion.uniforms : {}) || {}) });
    l2.onBeforeCompile = (e3) => {
      e3.vertexShader = e3.vertexShader.replace("#include <getDistortion_vertex>", "object" == typeof this.options.distortion ? this.options.distortion.getDistortion : "");
    };
    const u2 = new Mesh2(n2, l2);
    u2.frustumCulled = false, this.webgl.scene.add(u2), this.mesh = u2;
  }
  update(e2) {
    this.mesh.material.uniforms.uTime && (this.mesh.material.uniforms.uTime.value = e2);
  }
};
var fr = `
  #define USE_FOG;
  ${ShaderChunk.fog_pars_vertex}
  attribute float aOffset;
  attribute vec3 aColor;
  attribute vec2 aMetrics;
  uniform float uTravelLength;
  uniform float uTime;
  varying vec3 vColor;
  mat4 rotationY( in float angle ) {
    return mat4(
      cos(angle),		0,		sin(angle),	0,
      0,		        1.0,	0,			0,
      -sin(angle),	    0,		cos(angle),	0,
      0, 		        0,		0,			1
    );
  }
  #include <getDistortion_vertex>
  void main(){
    vec3 transformed = position.xyz;
    float width = aMetrics.x;
    float height = aMetrics.y;

    transformed.xy *= vec2(width, height);
    float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);

    transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;
    transformed.z += - uTravelLength + time;

    float progress = abs(transformed.z / uTravelLength);
    transformed.xyz += getDistortion(progress);

    transformed.y += height / 2.;
    transformed.x += -width / 2.;
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
    gl_Position = projectionMatrix * mvPosition;
    vColor = aColor;
    ${ShaderChunk.fog_vertex}
  }
`;
var vr = `
  #define USE_FOG;
  ${ShaderChunk.fog_pars_fragment}
  varying vec3 vColor;
  void main(){
    vec3 color = vec3(vColor);
    gl_FragColor = vec4(color,1.);
    ${ShaderChunk.fog_fragment}
  }
`;
var gr = class {
  constructor(e2, t2) {
    this.webgl = e2, this.options = t2, this.uTime = { value: 0 };
  }
  createPlane(e2, t2, n2) {
    const i2 = this.options, r2 = new PlaneGeometry(n2 ? i2.roadWidth : i2.islandWidth, i2.length, 20, 100);
    let o2 = { uTravelLength: { value: i2.length }, uColor: { value: new Color2(n2 ? i2.colors.roadColor : i2.colors.islandColor) }, uTime: this.uTime };
    n2 && (o2 = Object.assign(o2, { uLanes: { value: i2.lanesPerRoad }, uBrokenLinesColor: { value: new Color2(i2.colors.brokenLines) }, uShoulderLinesColor: { value: new Color2(i2.colors.shoulderLines) }, uShoulderLinesWidthPercentage: { value: i2.shoulderLinesWidthPercentage }, uBrokenLinesLengthPercentage: { value: i2.brokenLinesLengthPercentage }, uBrokenLinesWidthPercentage: { value: i2.brokenLinesWidthPercentage } }));
    const a2 = new ShaderMaterial({ fragmentShader: n2 ? wr : yr, vertexShader: br, side: DoubleSide, uniforms: Object.assign(o2, this.webgl.fogUniforms, ("object" == typeof i2.distortion ? i2.distortion.uniforms : {}) || {}) });
    a2.onBeforeCompile = (e3) => {
      e3.vertexShader = e3.vertexShader.replace("#include <getDistortion_vertex>", "object" == typeof this.options.distortion ? this.options.distortion.getDistortion : "");
    };
    const s2 = new Mesh2(r2, a2);
    return s2.rotation.x = -Math.PI / 2, s2.position.z = -i2.length / 2, s2.position.x += (this.options.islandWidth / 2 + i2.roadWidth / 2) * e2, this.webgl.scene.add(s2), s2;
  }
  init() {
    this.leftRoadWay = this.createPlane(-1, this.options.roadWidth, true), this.rightRoadWay = this.createPlane(1, this.options.roadWidth, true), this.island = this.createPlane(0, this.options.islandWidth, false);
  }
  update(e2) {
    this.uTime.value = e2;
  }
};
var xr = `
  #define USE_FOG;
  varying vec2 vUv; 
  uniform vec3 uColor;
  uniform float uTime;
  #include <roadMarkings_vars>
  ${ShaderChunk.fog_pars_fragment}
  void main() {
    vec2 uv = vUv;
    vec3 color = vec3(uColor);
    #include <roadMarkings_fragment>
    gl_FragColor = vec4(color, 1.);
    ${ShaderChunk.fog_fragment}
  }
`;
var yr = xr.replace("#include <roadMarkings_fragment>", "").replace("#include <roadMarkings_vars>", "");
var wr = xr.replace("#include <roadMarkings_fragment>", "\n  uv.y = mod(uv.y + uTime * 0.05, 1.);\n  float laneWidth = 1.0 / uLanes;\n  float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;\n  float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n  float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));\n  float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x);\n\n  brokenLines = mix(brokenLines, sideLines, uv.x);\n").replace("#include <roadMarkings_vars>", "\n  uniform float uLanes;\n  uniform vec3 uBrokenLinesColor;\n  uniform vec3 uShoulderLinesColor;\n  uniform float uShoulderLinesWidthPercentage;\n  uniform float uBrokenLinesWidthPercentage;\n  uniform float uBrokenLinesLengthPercentage;\n  highp float random(vec2 co) {\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy, vec2(a, b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n  }\n");
var br = `
  #define USE_FOG;
  uniform float uTime;
  ${ShaderChunk.fog_pars_vertex}
  uniform float uTravelLength;
  varying vec2 vUv; 
  #include <getDistortion_vertex>
  void main() {
    vec3 transformed = position.xyz;
    vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);
    transformed.x += distortion.x;
    transformed.z += distortion.y;
    transformed.y += -1. * distortion.z;  
    
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
    gl_Position = projectionMatrix * mvPosition;
    vUv = uv;
    ${ShaderChunk.fog_vertex}
  }
`;
var Mr = class {
  constructor(e2, t2) {
    this.options = t2, this.options.distortion || (this.options.distortion = { uniforms: sr, getDistortion: "\n  #define PI 3.14159265358979\n  uniform vec2 uDistortionX;\n  uniform vec2 uDistortionY;\n  float nsin(float val){\n    return sin(val) * 0.5 + 0.5;\n  }\n  vec3 getDistortion(float progress){\n    progress = clamp(progress, 0., 1.);\n    float xAmp = uDistortionX.r;\n    float xFreq = uDistortionX.g;\n    float yAmp = uDistortionY.r;\n    float yFreq = uDistortionY.g;\n    return vec3( \n      xAmp * nsin(progress * PI * xFreq - PI / 2.),\n      yAmp * nsin(progress * PI * yFreq - PI / 2.),\n      0.\n    );\n  }\n" }), this.container = e2, this.renderer = new WebGLRenderer({ antialias: false, alpha: true }), this.renderer.setSize(e2.offsetWidth, e2.offsetHeight, false), this.renderer.setPixelRatio(window.devicePixelRatio), this.composer = new EffectComposer(this.renderer), e2.appendChild(this.renderer.domElement), this.camera = new PerspectiveCamera(t2.fov, e2.offsetWidth / e2.offsetHeight, 0.1, 1e4), this.camera.position.z = -5, this.camera.position.y = 8, this.camera.position.x = 0, this.scene = new Scene(), this.scene.background = null;
    const n2 = new Fog(t2.colors.background, 0.2 * t2.length, 500 * t2.length);
    this.scene.fog = n2, this.fogUniforms = { fogColor: { value: n2.color }, fogNear: { value: n2.near }, fogFar: { value: n2.far } }, this.clock = new Clock(), this.assets = {}, this.disposed = false, this.road = new gr(this, t2), this.leftCarLights = new hr(this, t2, t2.colors.leftCars, t2.movingAwaySpeed, new Vector2(0, 1 - t2.carLightsFade)), this.rightCarLights = new hr(this, t2, t2.colors.rightCars, t2.movingCloserSpeed, new Vector2(1, 0 + t2.carLightsFade)), this.leftSticks = new pr(this, t2), this.fovTarget = t2.fov, this.speedUpTarget = 0, this.speedUp = 0, this.timeOffset = 0, this.tick = this.tick.bind(this), this.init = this.init.bind(this), this.setSize = this.setSize.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onMouseUp = this.onMouseUp.bind(this), window.addEventListener("resize", this.onWindowResize.bind(this));
  }
  onWindowResize() {
    const e2 = this.container.offsetWidth, t2 = this.container.offsetHeight;
    this.renderer.setSize(e2, t2), this.camera.aspect = e2 / t2, this.camera.updateProjectionMatrix(), this.composer.setSize(e2, t2);
  }
  initPasses() {
    this.renderPass = new RenderPass(this.scene, this.camera), this.bloomPass = new EffectPass(this.camera, new BloomEffect({ luminanceThreshold: 0.2, luminanceSmoothing: 0, resolutionScale: 1 }));
    const e2 = new EffectPass(this.camera, new SMAAEffect({ preset: SMAAPreset.MEDIUM }));
    this.renderPass.renderToScreen = false, this.bloomPass.renderToScreen = false, e2.renderToScreen = true, this.composer.addPass(this.renderPass), this.composer.addPass(this.bloomPass), this.composer.addPass(e2);
  }
  loadAssets() {
    const e2 = this.assets;
    return new Promise((t2) => {
      const n2 = new LoadingManager(t2), i2 = new Image(), r2 = new Image();
      e2.smaa = {}, i2.addEventListener("load", function() {
        e2.smaa.search = this, n2.itemEnd("smaa-search");
      }), r2.addEventListener("load", function() {
        e2.smaa.area = this, n2.itemEnd("smaa-area");
      }), n2.itemStart("smaa-search"), n2.itemStart("smaa-area"), i2.src = SMAAEffect.searchImageDataURL, r2.src = SMAAEffect.areaImageDataURL;
    });
  }
  init() {
    this.initPasses();
    const e2 = this.options;
    this.road.init(), this.leftCarLights.init(), this.leftCarLights.mesh.position.setX(-e2.roadWidth / 2 - e2.islandWidth / 2), this.rightCarLights.init(), this.rightCarLights.mesh.position.setX(e2.roadWidth / 2 + e2.islandWidth / 2), this.leftSticks.init(), this.leftSticks.mesh.position.setX(-(e2.roadWidth + e2.islandWidth / 2)), this.container.addEventListener("mousedown", this.onMouseDown), this.container.addEventListener("mouseup", this.onMouseUp), this.container.addEventListener("mouseout", this.onMouseUp), this.tick();
  }
  onMouseDown(e2) {
    this.options.onSpeedUp && this.options.onSpeedUp(e2), this.fovTarget = this.options.fovSpeedUp, this.speedUpTarget = this.options.speedUp;
  }
  onMouseUp(e2) {
    this.options.onSlowDown && this.options.onSlowDown(e2), this.fovTarget = this.options.fov, this.speedUpTarget = 0;
  }
  update(e2) {
    const t2 = Math.exp(60 * Math.log2(0.9) * e2);
    this.speedUp += ur(this.speedUp, this.speedUpTarget, t2, 1e-5), this.timeOffset += this.speedUp * e2;
    const n2 = this.clock.elapsedTime + this.timeOffset;
    this.rightCarLights.update(n2), this.leftCarLights.update(n2), this.leftSticks.update(n2), this.road.update(n2);
    let i2 = false;
    const r2 = ur(this.camera.fov, this.fovTarget, t2);
    if (0 !== r2 && (this.camera.fov += r2 * e2 * 6, i2 = true), "object" == typeof this.options.distortion && this.options.distortion.getJS) {
      const e3 = this.options.distortion.getJS(0.025, n2);
      this.camera.lookAt(new Vector3(this.camera.position.x + e3.x, this.camera.position.y + e3.y, this.camera.position.z + e3.z)), i2 = true;
    }
    i2 && this.camera.updateProjectionMatrix();
  }
  render(e2) {
    this.composer.render(e2);
  }
  dispose() {
    this.disposed = true;
  }
  setSize(e2, t2, n2) {
    this.composer.setSize(e2, t2, n2);
  }
  tick() {
    if (this.disposed || !this) return;
    if (function(e3, t2) {
      const n2 = e3.domElement, i2 = n2.clientWidth, r2 = n2.clientHeight, o2 = n2.width !== i2 || n2.height !== r2;
      return o2 && t2(i2, r2, false), o2;
    }(this.renderer, this.setSize)) {
      const e3 = this.renderer.domElement;
      this.camera.aspect = e3.clientWidth / e3.clientHeight, this.camera.updateProjectionMatrix();
    }
    const e2 = this.clock.getDelta();
    this.render(e2), this.update(e2), requestAnimationFrame(this.tick);
  }
};
var Pr = ({ effectOptions: o2 = {} }) => {
  const a2 = { ...Ji, ...o2 }, s2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = s2.current;
    if (!e2) return;
    "string" == typeof a2.distortion && (a2.distortion = ar[a2.distortion]);
    const t2 = new Mr(e2, a2);
    t2.loadAssets().then(t2.init);
  }, []), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: "#lights {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: absolute;\n}\n\ncanvas {\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { id: "lights", ref: s2 })] });
};
function Sr({ color: o2 = [1, 1, 1], speed: a2 = 1, amplitude: s2 = 0.1, mouseReact: c2 = true, ...l2 }) {
  const u2 = (0, import_react3.useRef)(null), h2 = (0, import_react3.useRef)({ x: 0.5, y: 0.5 });
  return (0, import_react3.useEffect)(() => {
    if (!u2.current) return;
    const e2 = u2.current, t2 = new Renderer(), n2 = t2.gl;
    let i2;
    function r2() {
      t2.setSize(1 * e2.offsetWidth, 1 * e2.offsetHeight), i2 && (i2.uniforms.uResolution.value = new Color(n2.canvas.width, n2.canvas.height, n2.canvas.width / n2.canvas.height));
    }
    n2.clearColor(1, 1, 1, 1), window.addEventListener("resize", r2, false), r2();
    const l3 = new Triangle(n2);
    i2 = new Program(n2, { vertex: "\nattribute vec2 uv;\nattribute vec2 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 0, 1);\n}\n", fragment: "\nprecision highp float;\n\nuniform float uTime;\nuniform vec3 uColor;\nuniform vec3 uResolution;\nuniform vec2 uMouse;\nuniform float uAmplitude;\nuniform float uSpeed;\n\nvarying vec2 vUv;\n\nvoid main() {\n  float mr = min(uResolution.x, uResolution.y);\n  vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;\n\n  uv += (uMouse - vec2(0.5)) * uAmplitude;\n\n  float d = -uTime * 0.5 * uSpeed;\n  float a = 0.0;\n  for (float i = 0.0; i < 8.0; ++i) {\n    a += cos(i - d - a * uv.x);\n    d += sin(uv.y * i + a);\n  }\n  d += uTime * 0.5 * uSpeed;\n  vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);\n  col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * uColor;\n  gl_FragColor = vec4(col, 1.0);\n}\n", uniforms: { uTime: { value: 0 }, uColor: { value: new Color(...o2) }, uResolution: { value: new Color(n2.canvas.width, n2.canvas.height, n2.canvas.width / n2.canvas.height) }, uMouse: { value: new Float32Array([h2.current.x, h2.current.y]) }, uAmplitude: { value: s2 }, uSpeed: { value: a2 } } });
    const d2 = new Mesh(n2, { geometry: l3, program: i2 });
    let m2;
    function p2(t3) {
      const n3 = e2.getBoundingClientRect(), r3 = (t3.clientX - n3.left) / n3.width, o3 = 1 - (t3.clientY - n3.top) / n3.height;
      h2.current = { x: r3, y: o3 }, i2.uniforms.uMouse.value[0] = r3, i2.uniforms.uMouse.value[1] = o3;
    }
    return m2 = requestAnimationFrame(function e3(n3) {
      m2 = requestAnimationFrame(e3), i2.uniforms.uTime.value = 1e-3 * n3, t2.render({ scene: d2 });
    }), e2.appendChild(n2.canvas), c2 && e2.addEventListener("mousemove", p2), () => {
      var _a;
      cancelAnimationFrame(m2), window.removeEventListener("resize", r2), c2 && e2.removeEventListener("mousemove", p2), e2.removeChild(n2.canvas), (_a = n2.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
    };
  }, [o2, a2, s2, c2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".iridescence-container {\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: u2, className: "iridescence-container", ...l2 })] });
}
var Cr = ({ grid: o2 = 15, mouse: a2 = 0.1, strength: s2 = 0.15, relaxation: c2 = 0.9, imageSrc: l2, className: u2 = "" }) => {
  const h2 = (0, import_react3.useRef)(null), d2 = (0, import_react3.useRef)(1), m2 = (0, import_react3.useRef)(null), p2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    if (!h2.current) return;
    const e2 = h2.current, t2 = new Scene(), n2 = new WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
    n2.setPixelRatio(Math.min(window.devicePixelRatio, 2)), e2.appendChild(n2.domElement);
    const i2 = new OrthographicCamera(0, 0, 0, 0, -1e3, 1e3);
    i2.position.z = 2, m2.current = i2;
    const r2 = { time: { value: 0 }, resolution: { value: new Vector4() }, uTexture: { value: null }, uDataTexture: { value: null } };
    new TextureLoader().load(l2, (e3) => {
      e3.minFilter = LinearFilter, d2.current = e3.image.width / e3.image.height, r2.uTexture.value = e3, w();
    });
    const u3 = o2, f2 = new Float32Array(4 * u3 * u3);
    for (let e3 = 0; e3 < u3 * u3; e3++) f2[4 * e3] = 255 * Math.random() - 125, f2[4 * e3 + 1] = 255 * Math.random() - 125;
    p2.current = new Float32Array(f2);
    const v2 = new DataTexture(f2, u3, u3, RGBAFormat, FloatType);
    v2.needsUpdate = true, r2.uDataTexture.value = v2;
    const g2 = new ShaderMaterial({ side: DoubleSide, uniforms: r2, vertexShader: "\nuniform float time;\nvarying vec2 vUv;\nvarying vec3 vPosition;\n\nvoid main() {\n  vUv = uv;\n  vPosition = position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n", fragmentShader: "\nuniform sampler2D uDataTexture;\nuniform sampler2D uTexture;\nuniform vec4 resolution;\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 uv = vUv;\n  vec4 offset = texture2D(uDataTexture, vUv);\n  gl_FragColor = texture2D(uTexture, uv - 0.02 * offset.rg);\n}\n" }), x2 = new PlaneGeometry(1, 1, u3 - 1, u3 - 1), y = new Mesh2(x2, g2);
    t2.add(y);
    const w = () => {
      const t3 = e2.offsetWidth, o3 = e2.offsetHeight, a3 = t3 / o3, s3 = d2.current;
      n2.setSize(t3, o3);
      const c3 = Math.max(a3 / s3, 1);
      y.scale.set(s3 * c3, c3, 1);
      const l3 = 1 * a3;
      i2.left = -l3 / 2, i2.right = l3 / 2, i2.top = 0.5, i2.bottom = -0.5, i2.updateProjectionMatrix(), r2.resolution.value.set(t3, o3, 1, 1);
    }, b = { x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0 }, M = (t3) => {
      const n3 = e2.getBoundingClientRect(), i3 = (t3.clientX - n3.left) / n3.width, r3 = 1 - (t3.clientY - n3.top) / n3.height;
      b.vX = i3 - b.prevX, b.vY = r3 - b.prevY, Object.assign(b, { x: i3, y: r3, prevX: i3, prevY: r3 });
    }, P = () => {
      v2.needsUpdate = true, Object.assign(b, { x: 0, y: 0, prevX: 0, prevY: 0, vX: 0, vY: 0 });
    };
    e2.addEventListener("mousemove", M), e2.addEventListener("mouseleave", P), window.addEventListener("resize", w), w();
    const S = () => {
      requestAnimationFrame(S), r2.time.value += 0.05;
      const e3 = v2.image.data;
      for (let t3 = 0; t3 < u3 * u3; t3++) e3[4 * t3] *= c2, e3[4 * t3 + 1] *= c2;
      const o3 = u3 * b.x, l3 = u3 * b.y, h3 = u3 * a2;
      for (let t3 = 0; t3 < u3; t3++) for (let n3 = 0; n3 < u3; n3++) {
        const i3 = Math.pow(o3 - t3, 2) + Math.pow(l3 - n3, 2);
        if (i3 < h3 * h3) {
          const r3 = 4 * (t3 + u3 * n3), o4 = Math.min(h3 / Math.sqrt(i3), 10);
          e3[r3] += 100 * s2 * b.vX * o4, e3[r3 + 1] -= 100 * s2 * b.vY * o4;
        }
      }
      v2.needsUpdate = true, n2.render(t2, i2);
    };
    return S(), () => {
      e2.removeEventListener("mousemove", M), e2.removeEventListener("mouseleave", P), window.removeEventListener("resize", w), n2.dispose(), x2.dispose(), g2.dispose(), v2.dispose(), r2.uTexture.value && r2.uTexture.value.dispose();
    };
  }, [o2, a2, s2, c2, l2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".distortion-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: h2, className: `distortion-container ${u2}` })] });
};
function Er(e2, t2, n2, i2) {
  if ("a" === n2 && !i2) throw new TypeError("Private accessor was defined without a getter");
  if ("function" == typeof t2 ? e2 !== t2 || !i2 : !t2.has(e2)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return "m" === n2 ? i2 : "a" === n2 ? i2.call(e2) : i2 ? i2.value : t2.get(e2);
}
function zr(e2, t2, n2, i2, r2) {
  if ("m" === i2) throw new TypeError("Private method is not writable");
  if ("a" === i2 && !r2) throw new TypeError("Private accessor was defined without a setter");
  if ("function" == typeof t2 ? e2 !== t2 || !r2 : !t2.has(e2)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return "a" === i2 ? r2.call(e2, n2) : r2 ? r2.value = n2 : t2.set(e2, n2), n2;
}
var _r;
var Tr;
var Ar;
var Rr;
var Ir;
var Lr;
var Fr;
var kr;
var Dr;
var Nr;
var Br;
var Ur;
var Or;
var Vr;
var Xr;
var qr;
var Yr;
var $r;
var Wr;
var Hr;
var Gr;
var jr;
var Zr;
var Kr;
var Qr;
var Jr;
var eo;
var to;
var no;
"function" == typeof SuppressedError && SuppressedError, (void 0).registerPlugin(void 0);
var io = class {
  constructor(e2) {
    _r.add(this), Tr.set(this, void 0), Ar.set(this, void 0), Rr.set(this, void 0), Ir.set(this, void 0), Lr.set(this, void 0), Fr.set(this, 0), kr.set(this, new Clock()), Dr.set(this, { elapsed: 0, delta: 0 }), Nr.set(this, false), Br.set(this, false), this.size = { width: 0, height: 0, wWidth: 0, wHeight: 0, ratio: 0, pixelRatio: 0 }, this.render = Er(this, _r, "m", Kr).bind(this), this.onBeforeRender = () => {
    }, this.onAfterRender = () => {
    }, this.onAfterResize = () => {
    }, this.isDisposed = false, zr(this, Tr, { ...e2 }, "f"), Er(this, _r, "m", Ur).call(this), Er(this, _r, "m", Or).call(this), Er(this, _r, "m", Vr).call(this), this.resize(), Er(this, _r, "m", Xr).call(this);
  }
  resize() {
    let e2, t2;
    Er(this, Tr, "f").size instanceof Object ? (e2 = Er(this, Tr, "f").size.width, t2 = Er(this, Tr, "f").size.height) : "parent" === Er(this, Tr, "f").size && this.canvas.parentNode ? (e2 = this.canvas.parentNode.offsetWidth, t2 = this.canvas.parentNode.offsetHeight) : (e2 = window.innerWidth, t2 = window.innerHeight), this.size.width = e2, this.size.height = t2, this.size.ratio = e2 / t2, Er(this, _r, "m", Yr).call(this), Er(this, _r, "m", Wr).call(this), this.onAfterResize(this.size);
  }
  updateWorldSize() {
    if (this.camera.isPerspectiveCamera) {
      const e2 = this.camera.fov * Math.PI / 180;
      this.size.wHeight = 2 * Math.tan(e2 / 2) * this.camera.position.length(), this.size.wWidth = this.size.wHeight * this.camera.aspect;
    } else if (this.camera.isOrthographicCamera) {
      const e2 = this.camera;
      this.size.wHeight = e2.top - e2.bottom, this.size.wWidth = e2.right - e2.left;
    }
  }
  get postprocessing() {
    return Er(this, Ar, "f");
  }
  set postprocessing(e2) {
    zr(this, Ar, e2, "f"), this.render = e2.render.bind(e2);
  }
  clear() {
    this.scene.traverse((e2) => {
      e2.isMesh && "object" == typeof e2.material && null !== e2.material && (Object.keys(e2.material).forEach((t2) => {
        const n2 = e2.material[t2];
        n2 && "object" == typeof n2 && "function" == typeof n2.dispose && n2.dispose();
      }), e2.material.dispose(), e2.geometry.dispose());
    }), this.scene.clear();
  }
  dispose() {
    var _a;
    Er(this, _r, "m", Qr).call(this), Er(this, _r, "m", Zr).call(this), this.clear(), (_a = Er(this, Ar, "f")) == null ? void 0 : _a.dispose(), this.renderer.dispose(), this.isDisposed = true;
  }
};
Tr = /* @__PURE__ */ new WeakMap(), Ar = /* @__PURE__ */ new WeakMap(), Rr = /* @__PURE__ */ new WeakMap(), Ir = /* @__PURE__ */ new WeakMap(), Lr = /* @__PURE__ */ new WeakMap(), Fr = /* @__PURE__ */ new WeakMap(), kr = /* @__PURE__ */ new WeakMap(), Dr = /* @__PURE__ */ new WeakMap(), Nr = /* @__PURE__ */ new WeakMap(), Br = /* @__PURE__ */ new WeakMap(), _r = /* @__PURE__ */ new WeakSet(), Ur = function() {
  this.camera = new PerspectiveCamera(), this.cameraFov = this.camera.fov;
}, Or = function() {
  this.scene = new Scene();
}, Vr = function() {
  if (Er(this, Tr, "f").canvas) this.canvas = Er(this, Tr, "f").canvas;
  else if (Er(this, Tr, "f").id) {
    const e3 = document.getElementById(Er(this, Tr, "f").id);
    e3 instanceof HTMLCanvasElement && (this.canvas = e3);
  }
  this.canvas.style.display = "block";
  const e2 = { canvas: this.canvas, powerPreference: "high-performance", ...Er(this, Tr, "f").rendererOptions ?? {} };
  this.renderer = new WebGLRenderer(e2), this.renderer.outputColorSpace = SRGBColorSpace;
}, Xr = function() {
  Er(this, Tr, "f").size instanceof Object || (window.addEventListener("resize", Er(this, _r, "m", qr).bind(this)), "parent" === Er(this, Tr, "f").size && this.canvas.parentNode && (zr(this, Rr, new ResizeObserver(Er(this, _r, "m", qr).bind(this)), "f"), Er(this, Rr, "f").observe(this.canvas.parentNode))), zr(this, Ir, new IntersectionObserver(Er(this, _r, "m", Hr).bind(this), { root: null, rootMargin: "0px", threshold: 0 }), "f"), Er(this, Ir, "f").observe(this.canvas), document.addEventListener("visibilitychange", Er(this, _r, "m", Gr).bind(this));
}, qr = function() {
  Er(this, Lr, "f") && clearTimeout(Er(this, Lr, "f")), zr(this, Lr, window.setTimeout(this.resize.bind(this), 100), "f");
}, Yr = function() {
  this.camera.aspect = this.size.width / this.size.height, this.camera.isPerspectiveCamera && this.cameraFov && (this.cameraMinAspect && this.camera.aspect < this.cameraMinAspect ? Er(this, _r, "m", $r).call(this, this.cameraMinAspect) : this.cameraMaxAspect && this.camera.aspect > this.cameraMaxAspect ? Er(this, _r, "m", $r).call(this, this.cameraMaxAspect) : this.camera.fov = this.cameraFov), this.camera.updateProjectionMatrix(), this.updateWorldSize();
}, $r = function(e2) {
  const t2 = Math.tan(MathUtils.degToRad(this.cameraFov / 2)) / (this.camera.aspect / e2);
  this.camera.fov = 2 * MathUtils.radToDeg(Math.atan(t2));
}, Wr = function() {
  var _a;
  this.renderer.setSize(this.size.width, this.size.height), (_a = Er(this, Ar, "f")) == null ? void 0 : _a.setSize(this.size.width, this.size.height);
  let e2 = window.devicePixelRatio;
  this.maxPixelRatio && e2 > this.maxPixelRatio ? e2 = this.maxPixelRatio : this.minPixelRatio && e2 < this.minPixelRatio && (e2 = this.minPixelRatio), this.renderer.setPixelRatio(e2), this.size.pixelRatio = e2;
}, Hr = function(e2) {
  zr(this, Nr, e2[0].isIntersecting, "f"), Er(this, Nr, "f") ? Er(this, _r, "m", jr).call(this) : Er(this, _r, "m", Zr).call(this);
}, Gr = function() {
  Er(this, Nr, "f") && (document.hidden ? Er(this, _r, "m", Zr).call(this) : Er(this, _r, "m", jr).call(this));
}, jr = function() {
  if (Er(this, Br, "f")) return;
  const e2 = () => {
    zr(this, Fr, requestAnimationFrame(e2), "f"), Er(this, Dr, "f").delta = Er(this, kr, "f").getDelta(), Er(this, Dr, "f").elapsed += Er(this, Dr, "f").delta, this.onBeforeRender(Er(this, Dr, "f")), this.render(), this.onAfterRender(Er(this, Dr, "f"));
  };
  zr(this, Br, true, "f"), Er(this, kr, "f").start(), e2();
}, Zr = function() {
  Er(this, Br, "f") && (cancelAnimationFrame(Er(this, Fr, "f")), zr(this, Br, false, "f"), Er(this, kr, "f").stop());
}, Kr = function() {
  this.renderer.render(this.scene, this.camera);
}, Qr = function() {
  var _a, _b;
  window.removeEventListener("resize", Er(this, _r, "m", qr).bind(this)), (_a = Er(this, Rr, "f")) == null ? void 0 : _a.disconnect(), (_b = Er(this, Ir, "f")) == null ? void 0 : _b.disconnect(), document.removeEventListener("visibilitychange", Er(this, _r, "m", Gr).bind(this));
};
var ro = class {
  constructor(e2) {
    Jr.add(this), this.center = new Vector3(), this.config = e2, this.positionData = new Float32Array(3 * e2.count).fill(0), this.velocityData = new Float32Array(3 * e2.count).fill(0), this.sizeData = new Float32Array(e2.count).fill(1), this.center = new Vector3(), Er(this, Jr, "m", eo).call(this), this.setSizes();
  }
  setSizes() {
    const { config: e2, sizeData: t2 } = this;
    t2[0] = e2.size0;
    for (let n2 = 1; n2 < e2.count; n2++) t2[n2] = MathUtils.randFloat(e2.minSize, e2.maxSize);
  }
  update(e2) {
    const { config: t2, center: n2, positionData: i2, sizeData: r2, velocityData: o2 } = this;
    let a2 = 0;
    if (t2.controlSphere0) {
      a2 = 1;
      new Vector3().fromArray(i2, 0).lerp(n2, 0.1).toArray(i2, 0), new Vector3(0, 0, 0).toArray(o2, 0);
    }
    for (let n3 = a2; n3 < t2.count; n3++) {
      const a3 = 3 * n3, s2 = new Vector3().fromArray(i2, a3), c2 = new Vector3().fromArray(o2, a3);
      c2.y -= e2.delta * t2.gravity * r2[n3], c2.multiplyScalar(t2.friction), c2.clampLength(0, t2.maxVelocity), s2.add(c2), s2.toArray(i2, a3), c2.toArray(o2, a3);
    }
    for (let e3 = a2; e3 < t2.count; e3++) {
      const n3 = 3 * e3, a3 = new Vector3().fromArray(i2, n3), s2 = new Vector3().fromArray(o2, n3), c2 = r2[e3];
      for (let l3 = e3 + 1; l3 < t2.count; l3++) {
        const e4 = 3 * l3, t3 = new Vector3().fromArray(i2, e4), u2 = new Vector3().fromArray(o2, e4), h2 = new Vector3().copy(t3).sub(a3), d2 = h2.length(), m2 = c2 + r2[l3];
        if (d2 < m2) {
          const r3 = m2 - d2, c3 = h2.normalize().multiplyScalar(0.5 * r3), l4 = c3.clone().multiplyScalar(Math.max(s2.length(), 1));
          a3.sub(c3), s2.sub(l4), a3.toArray(i2, n3), s2.toArray(o2, n3), t3.add(c3), u2.add(c3.clone().multiplyScalar(Math.max(u2.length(), 1))), t3.toArray(i2, e4), u2.toArray(o2, e4);
        }
      }
      if (t2.controlSphere0) {
        const e4 = new Vector3().copy(new Vector3().fromArray(i2, 0)).sub(a3), t3 = e4.length(), n4 = c2 + r2[0];
        if (t3 < n4) {
          const i3 = e4.normalize().multiplyScalar(n4 - t3), r3 = i3.clone().multiplyScalar(Math.max(s2.length(), 2));
          a3.sub(i3), s2.sub(r3);
        }
      }
      Math.abs(a3.x) + c2 > t2.maxX && (a3.x = Math.sign(a3.x) * (t2.maxX - c2), s2.x = -s2.x * t2.wallBounce), 0 === t2.gravity ? Math.abs(a3.y) + c2 > t2.maxY && (a3.y = Math.sign(a3.y) * (t2.maxY - c2), s2.y = -s2.y * t2.wallBounce) : a3.y - c2 < -t2.maxY && (a3.y = -t2.maxY + c2, s2.y = -s2.y * t2.wallBounce);
      const l2 = Math.max(t2.maxZ, t2.maxSize);
      Math.abs(a3.z) + c2 > l2 && (a3.z = Math.sign(a3.z) * (t2.maxZ - c2), s2.z = -s2.z * t2.wallBounce), a3.toArray(i2, n3), s2.toArray(o2, n3);
    }
  }
};
Jr = /* @__PURE__ */ new WeakSet(), eo = function() {
  const { config: e2, positionData: t2 } = this;
  this.center.toArray(t2, 0);
  for (let n2 = 1; n2 < e2.count; n2++) {
    const i2 = 3 * n2;
    t2[i2] = MathUtils.randFloatSpread(2 * e2.maxX), t2[i2 + 1] = MathUtils.randFloatSpread(2 * e2.maxY), t2[i2 + 2] = MathUtils.randFloatSpread(2 * e2.maxZ);
  }
};
var oo = class extends MeshPhysicalMaterial {
  constructor(e2) {
    super(e2), this.uniforms = { thicknessDistortion: { value: 0.1 }, thicknessAmbient: { value: 0 }, thicknessAttenuation: { value: 0.1 }, thicknessPower: { value: 2 }, thicknessScale: { value: 10 } }, this.defines = { USE_UV: "" }, this.onBeforeCompile = (e3) => {
      Object.assign(e3.uniforms, this.uniforms), e3.fragmentShader = "\n        uniform float thicknessPower;\n        uniform float thicknessScale;\n        uniform float thicknessDistortion;\n        uniform float thicknessAmbient;\n        uniform float thicknessAttenuation;\n        " + e3.fragmentShader, e3.fragmentShader = e3.fragmentShader.replace("void main() {", "\n        void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, inout ReflectedLight reflectedLight) {\n          vec3 scatteringHalf = normalize(directLight.direction + (geometryNormal * thicknessDistortion));\n          float scatteringDot = pow(saturate(dot(geometryViewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\n          #ifdef USE_COLOR\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * vColor;\n          #else\n            vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * diffuse;\n          #endif\n          reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\n        }\n\n        void main() {\n        ");
      const t2 = ShaderChunk.lights_fragment_begin.replaceAll("RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );", "\n          RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n          RE_Direct_Scattering(directLight, vUv, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, reflectedLight);\n        ");
      e3.fragmentShader = e3.fragmentShader.replace("#include <lights_fragment_begin>", t2), this.onBeforeCompile2 && this.onBeforeCompile2(e3);
    };
  }
};
var ao = { count: 200, colors: [0, 0, 0], ambientColor: 16777215, ambientIntensity: 1, lightIntensity: 200, materialParams: { metalness: 0.5, roughness: 0.5, clearcoat: 1, clearcoatRoughness: 0.15 }, minSize: 0.5, maxSize: 1, size0: 1, gravity: 0.5, friction: 0.9975, wallBounce: 0.95, maxVelocity: 0.15, maxX: 5, maxY: 5, maxZ: 2, controlSphere0: false, followCursor: true };
var so = new Object3D();
var co = false;
var lo = new Vector2();
var uo = /* @__PURE__ */ new Map();
function ho(e2) {
  lo.set(e2.clientX, e2.clientY);
  for (const [e3, t2] of uo) {
    const n2 = e3.getBoundingClientRect();
    vo(n2) ? (fo(t2, n2), t2.hover || (t2.hover = true, t2.onEnter(t2)), t2.onMove(t2)) : t2.hover && (t2.hover = false, t2.onLeave(t2));
  }
}
function mo(e2) {
  lo.set(e2.clientX, e2.clientY);
  for (const [e3, t2] of uo) {
    const n2 = e3.getBoundingClientRect();
    fo(t2, n2), vo(n2) && t2.onClick(t2);
  }
}
function po() {
  for (const e2 of uo.values()) e2.hover && (e2.hover = false, e2.onLeave(e2));
}
function fo(e2, t2) {
  e2.position.set(lo.x - t2.left, lo.y - t2.top), e2.nPosition.set(e2.position.x / t2.width * 2 - 1, -e2.position.y / t2.height * 2 + 1);
}
function vo(e2) {
  return lo.x >= e2.left && lo.x <= e2.left + e2.width && lo.y >= e2.top && lo.y <= e2.top + e2.height;
}
var { randFloat: go, randFloatSpread: xo } = MathUtils;
new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3();
var yo = class extends InstancedMesh {
  constructor(e2, t2 = {}) {
    const n2 = { ...ao, ...t2 }, i2 = new RoomEnvironment(), r2 = new PMREMGenerator(e2).fromScene(i2).texture, o2 = new SphereGeometry(), a2 = new oo({ envMap: r2, ...n2.materialParams });
    a2.envMapRotation.x = -Math.PI / 2, super(o2, a2, n2.count), to.add(this), this.config = n2, this.physics = new ro(n2), Er(this, to, "m", no).call(this), this.setColors(n2.colors);
  }
  setColors(e2) {
    if (Array.isArray(e2) && e2.length > 1) {
      const t2 = function(e3) {
        let t3 = e3, n2 = [];
        return t3.forEach((e4) => {
          n2.push(new Color2(e4));
        }), { setColors: (e4) => {
          t3 = e4, n2 = [], t3.forEach((e5) => {
            n2.push(new Color2(e5));
          });
        }, getColorAt: (e4, i2 = new Color2()) => {
          const r2 = Math.max(0, Math.min(1, e4)) * (t3.length - 1), o2 = Math.floor(r2), a2 = n2[o2];
          if (o2 >= t3.length - 1) return a2.clone();
          const s2 = r2 - o2, c2 = n2[o2 + 1];
          return i2.r = a2.r + s2 * (c2.r - a2.r), i2.g = a2.g + s2 * (c2.g - a2.g), i2.b = a2.b + s2 * (c2.b - a2.b), i2;
        } };
      }(e2);
      for (let e3 = 0; e3 < this.count; e3++) this.setColorAt(e3, t2.getColorAt(e3 / this.count)), 0 === e3 && this.light.color.copy(t2.getColorAt(e3 / this.count));
      if (!this.instanceColor) return;
      this.instanceColor.needsUpdate = true;
    }
  }
  update(e2) {
    this.physics.update(e2);
    for (let e3 = 0; e3 < this.count; e3++) so.position.fromArray(this.physics.positionData, 3 * e3), 0 === e3 && false === this.config.followCursor ? so.scale.setScalar(0) : so.scale.setScalar(this.physics.sizeData[e3]), so.updateMatrix(), this.setMatrixAt(e3, so.matrix), 0 === e3 && this.light.position.copy(so.position);
    this.instanceMatrix.needsUpdate = true;
  }
};
function wo(e2, t2 = {}) {
  const n2 = new io({ canvas: e2, size: "parent", rendererOptions: { antialias: true, alpha: true } });
  let i2;
  n2.renderer.toneMapping = ACESFilmicToneMapping, n2.camera.position.set(0, 0, 20), n2.camera.lookAt(0, 0, 0), n2.cameraMaxAspect = 1.5, n2.resize(), l2(t2);
  const r2 = new Raycaster(), o2 = new Plane2(new Vector3(0, 0, 1), 0), a2 = new Vector3();
  let s2 = false;
  const c2 = function(e3) {
    const t3 = { position: new Vector2(), nPosition: new Vector2(), hover: false, onEnter: () => {
    }, onMove: () => {
    }, onClick: () => {
    }, onLeave: () => {
    }, ...e3 };
    return uo.has(e3.domElement) || (uo.set(e3.domElement, t3), co || (document.body.addEventListener("pointermove", ho), document.body.addEventListener("pointerleave", po), document.body.addEventListener("click", mo), co = true)), t3.dispose = () => {
      uo.delete(e3.domElement), 0 === uo.size && (document.body.removeEventListener("pointermove", ho), document.body.removeEventListener("pointerleave", po), document.body.removeEventListener("click", mo), co = false);
    }, t3;
  }({ domElement: e2, onMove() {
    r2.setFromCamera(c2.nPosition, n2.camera), n2.camera.getWorldDirection(o2.normal), r2.ray.intersectPlane(o2, a2), i2.physics.center.copy(a2), i2.config.controlSphere0 = true;
  }, onLeave() {
    i2.config.controlSphere0 = false;
  } });
  function l2(e3) {
    i2 && (n2.clear(), n2.scene.remove(i2)), i2 = new yo(n2.renderer, e3), n2.scene.add(i2);
  }
  return n2.onBeforeRender = (e3) => {
    s2 || i2.update(e3);
  }, n2.onAfterResize = (e3) => {
    i2.config.maxX = e3.wWidth / 2, i2.config.maxY = e3.wHeight / 2;
  }, { three: n2, get spheres() {
    return i2;
  }, setCount(e3) {
    l2({ ...i2.config, count: e3 });
  }, togglePause() {
    s2 = !s2;
  }, dispose() {
    var _a;
    (_a = c2.dispose) == null ? void 0 : _a.call(c2), n2.dispose();
  } };
}
to = /* @__PURE__ */ new WeakSet(), no = function() {
  this.ambientLight = new AmbientLight(this.config.ambientColor, this.config.ambientIntensity), this.add(this.ambientLight), this.light = new PointLight(this.config.colors[0], this.config.lightIntensity), this.add(this.light);
};
var bo = ({ className: t2 = "", followCursor: n2 = true, ...o2 }) => {
  const a2 = (0, import_react3.useRef)(null), s2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = a2.current;
    if (e2) return s2.current = wo(e2, { followCursor: n2, ...o2 }), () => {
      s2.current && s2.current.dispose();
    };
  }, []), (0, import_jsx_runtime.jsx)("canvas", { className: t2, ref: a2, style: { width: "100%", height: "100%" } });
};
function Mo({ hue: o2 = 0, hoverIntensity: a2 = 0.2, rotateOnHover: s2 = true, forceHoverState: c2 = false }) {
  const l2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = l2.current;
    if (!e2) return;
    const t2 = new Renderer({ alpha: true, premultipliedAlpha: false }), n2 = t2.gl;
    n2.clearColor(0, 0, 0, 0), e2.appendChild(n2.canvas);
    const i2 = new Triangle(n2), r2 = new Program(n2, { vertex: "\n    precision highp float;\n    attribute vec2 position;\n    attribute vec2 uv;\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  ", fragment: "\n    precision highp float;\n\n    uniform float iTime;\n    uniform vec3 iResolution;\n    uniform float hue;\n    uniform float hover;\n    uniform float rot;\n    uniform float hoverIntensity;\n    varying vec2 vUv;\n\n    vec3 rgb2yiq(vec3 c) {\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\n      return vec3(y, i, q);\n    }\n    \n    vec3 yiq2rgb(vec3 c) {\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\n      return vec3(r, g, b);\n    }\n    \n    vec3 adjustHue(vec3 color, float hueDeg) {\n      float hueRad = hueDeg * 3.14159265 / 180.0;\n      vec3 yiq = rgb2yiq(color);\n      float cosA = cos(hueRad);\n      float sinA = sin(hueRad);\n      float i = yiq.y * cosA - yiq.z * sinA;\n      float q = yiq.y * sinA + yiq.z * cosA;\n      yiq.y = i;\n      yiq.z = q;\n      return yiq2rgb(yiq);\n    }\n    \n    vec3 hash33(vec3 p3) {\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n      p3 += dot(p3, p3.yxz + 19.19);\n      return -1.0 + 2.0 * fract(vec3(\n        p3.x + p3.y,\n        p3.x + p3.z,\n        p3.y + p3.z\n      ) * p3.zyx);\n    }\n    \n    float snoise3(vec3 p) {\n      const float K1 = 0.333333333;\n      const float K2 = 0.166666667;\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\n      vec3 i1 = e * (1.0 - e.zxy);\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n      vec3 d1 = d0 - (i1 - K2);\n      vec3 d2 = d0 - (i2 - K1);\n      vec3 d3 = d0 - 0.5;\n      vec4 h = max(0.6 - vec4(\n        dot(d0, d0),\n        dot(d1, d1),\n        dot(d2, d2),\n        dot(d3, d3)\n      ), 0.0);\n      vec4 n = h * h * h * h * vec4(\n        dot(d0, hash33(i)),\n        dot(d1, hash33(i + i1)),\n        dot(d2, hash33(i + i2)),\n        dot(d3, hash33(i + 1.0))\n      );\n      return dot(vec4(31.316), n);\n    }\n    \n    vec4 extractAlpha(vec3 colorIn) {\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\n      return vec4(colorIn.rgb / (a + 1e-5), a);\n    }\n    \n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\n    const float innerRadius = 0.6;\n    const float noiseScale = 0.65;\n    \n    float light1(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * attenuation);\n    }\n    \n    float light2(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * dist * attenuation);\n    }\n    \n    vec4 draw(vec2 uv) {\n      vec3 color1 = adjustHue(baseColor1, hue);\n      vec3 color2 = adjustHue(baseColor2, hue);\n      vec3 color3 = adjustHue(baseColor3, hue);\n      \n      float ang = atan(uv.y, uv.x);\n      float len = length(uv);\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\n      \n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n      float d0 = distance(uv, (r0 * invLen) * uv);\n      float v0 = light1(1.0, 10.0, d0);\n      v0 *= smoothstep(r0 * 1.05, r0, len);\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\n      \n      float a = iTime * -1.0;\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\n      float d = distance(uv, pos);\n      float v1 = light2(1.5, 5.0, d);\n      v1 *= light1(1.0, 50.0, d0);\n      \n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\n      \n      vec3 col = mix(color1, color2, cl);\n      col = mix(color3, col, v0);\n      col = (col + v1) * v2 * v3;\n      col = clamp(col, 0.0, 1.0);\n      \n      return extractAlpha(col);\n    }\n    \n    vec4 mainImage(vec2 fragCoord) {\n      vec2 center = iResolution.xy * 0.5;\n      float size = min(iResolution.x, iResolution.y);\n      vec2 uv = (fragCoord - center) / size * 2.0;\n      \n      float angle = rot;\n      float s = sin(angle);\n      float c = cos(angle);\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n      \n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\n      \n      return draw(uv);\n    }\n    \n    void main() {\n      vec2 fragCoord = vUv * iResolution.xy;\n      vec4 col = mainImage(fragCoord);\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\n    }\n  ", uniforms: { iTime: { value: 0 }, iResolution: { value: new Vec3(n2.canvas.width, n2.canvas.height, n2.canvas.width / n2.canvas.height) }, hue: { value: o2 }, hover: { value: 0 }, rot: { value: 0 }, hoverIntensity: { value: a2 } } }), u2 = new Mesh(n2, { geometry: i2, program: r2 });
    function h2() {
      if (!e2) return;
      const i3 = window.devicePixelRatio || 1, o3 = e2.clientWidth, a3 = e2.clientHeight;
      t2.setSize(o3 * i3, a3 * i3), n2.canvas.style.width = o3 + "px", n2.canvas.style.height = a3 + "px", r2.uniforms.iResolution.value.set(n2.canvas.width, n2.canvas.height, n2.canvas.width / n2.canvas.height);
    }
    window.addEventListener("resize", h2), h2();
    let d2 = 0, m2 = 0, p2 = 0;
    const f2 = (t3) => {
      const n3 = e2.getBoundingClientRect(), i3 = t3.clientX - n3.left, r3 = t3.clientY - n3.top, o3 = n3.width, a3 = n3.height, s3 = Math.min(o3, a3), c3 = (i3 - o3 / 2) / s3 * 2, l3 = (r3 - a3 / 2) / s3 * 2;
      d2 = Math.sqrt(c3 * c3 + l3 * l3) < 0.8 ? 1 : 0;
    }, v2 = () => {
      d2 = 0;
    };
    let g2;
    e2.addEventListener("mousemove", f2), e2.addEventListener("mouseleave", v2);
    const x2 = (e3) => {
      g2 = requestAnimationFrame(x2);
      const n3 = 1e-3 * (e3 - m2);
      m2 = e3, r2.uniforms.iTime.value = 1e-3 * e3, r2.uniforms.hue.value = o2, r2.uniforms.hoverIntensity.value = a2;
      const i3 = c2 ? 1 : d2;
      r2.uniforms.hover.value += 0.1 * (i3 - r2.uniforms.hover.value), s2 && i3 > 0.5 && (p2 += 0.3 * n3), r2.uniforms.rot.value = p2, t2.render({ scene: u2 });
    };
    return g2 = requestAnimationFrame(x2), () => {
      var _a;
      cancelAnimationFrame(g2), window.removeEventListener("resize", h2), e2.removeEventListener("mousemove", f2), e2.removeEventListener("mouseleave", v2), e2.removeChild(n2.canvas), (_a = n2.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
    };
  }, [o2, a2, s2, c2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".orb-container {\n  position: relative;\n  z-index: 2;\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: l2, className: "orb-container" })] });
}
var Po = ({ items: o2 = [], gradientColor: a2 = "black" }) => {
  const s2 = (0, import_react3.useRef)(null), c2 = (0, import_react3.useRef)([]), l2 = (0, import_react3.useRef)(window.innerWidth / 2), u2 = Array.from({ length: 28 }, (e2, t2) => `Item ${t2 + 1}`), h2 = o2.length > 0 ? o2.slice(0, 28) : u2;
  return (0, import_react3.useEffect)(() => {
    (void 0).ticker.lagSmoothing(0);
    const e2 = (e3) => {
      l2.current = e3.clientX;
    }, t2 = (void 0).ticker.add(() => {
      const e3 = [0.6, 0.4, 0.3, 0.2];
      c2.current.forEach((t3, n2) => {
        if (t3) {
          const i2 = n2 % 2 == 0 ? 1 : -1, r2 = (l2.current / window.innerWidth * 300 - 150) * i2;
          (void 0).to(t3, { x: r2, duration: 0.8 + e3[n2 % e3.length], ease: "power3.out", overwrite: "auto" });
        }
      });
    });
    return window.addEventListener("mousemove", e2), () => {
      window.removeEventListener("mousemove", e2), t2();
    };
  }, []), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: '.noscroll {\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.intro {\n  width: 100%;\n  height: 100vh;\n  overflow: hidden;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.intro::after {\n  content: "";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-size: 250px;\n  pointer-events: none;\n  z-index: 4;\n}\n\n.gridMotion-container {\n  gap: 1rem;\n  flex: none;\n  position: relative;\n  width: 150vw;\n  height: 150vh;\n  display: grid;\n  grid-template-rows: repeat(4, 1fr);\n  grid-template-columns: 100%;\n  transform: rotate(-15deg);\n  transform-origin: center center;\n  z-index: 2;\n}\n\n.row {\n  display: grid;\n  gap: 1rem;\n  grid-template-columns: repeat(7, 1fr);\n  will-change: transform, filter;\n}\n\n.row__item {\n  position: relative;\n}\n\n.row__item-inner {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  border-radius: 10px;\n  background-color: #111;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 1.5rem;\n}\n\n.row__item-img {\n  width: 100%;\n  height: 100%;\n  background-size: cover;\n  background-position: 50% 50%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.row__item-content {\n  padding: 1rem;\n  text-align: center;\n  z-index: 1;\n}\n\n.fullview {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  pointer-events: none;\n}\n\n.fullview .row__item-inner {\n  border-radius: 0px;\n}\n' }), (0, import_jsx_runtime.jsx)("div", { className: "noscroll loading", ref: s2, children: (0, import_jsx_runtime.jsxs)("section", { className: "intro", style: { background: `radial-gradient(circle, ${a2} 0%, transparent 100%)` }, children: [(0, import_jsx_runtime.jsx)("div", { className: "gridMotion-container", children: Array.from({ length: 4 }, (t2, n2) => (0, import_jsx_runtime.jsx)("div", { className: "row", ref: (e2) => {
    c2.current[n2] = e2;
  }, children: Array.from({ length: 7 }, (t3, i2) => {
    const r2 = h2[7 * n2 + i2];
    return (0, import_jsx_runtime.jsx)("div", { className: "row__item", children: (0, import_jsx_runtime.jsx)("div", { className: "row__item-inner", style: { backgroundColor: "#111" }, children: "string" == typeof r2 && r2.startsWith("http") ? (0, import_jsx_runtime.jsx)("div", { className: "row__item-img", style: { backgroundImage: `url(${r2})` } }) : (0, import_jsx_runtime.jsx)("div", { className: "row__item-content", children: r2 }) }) }, i2);
  }) }, n2)) }), (0, import_jsx_runtime.jsx)("div", { className: "fullview" })] }) })] });
};
var So = ({ baseColor: o2 = [0.1, 0.1, 0.1], speed: a2 = 0.2, amplitude: s2 = 0.5, frequencyX: c2 = 3, frequencyY: l2 = 2, interactive: u2 = true, ...h2 }) => {
  const d2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    if (!d2.current) return;
    const e2 = d2.current, t2 = new Renderer({ antialias: true }), n2 = t2.gl;
    n2.clearColor(1, 1, 1, 1);
    const i2 = new Triangle(n2), r2 = new Program(n2, { vertex: "\n      attribute vec2 position;\n      attribute vec2 uv;\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0.0, 1.0);\n      }\n    ", fragment: "\n      precision highp float;\n      uniform float uTime;\n      uniform vec3 uResolution;\n      uniform vec3 uBaseColor;\n      uniform float uAmplitude;\n      uniform float uFrequencyX;\n      uniform float uFrequencyY;\n      uniform vec2 uMouse;\n      varying vec2 vUv;\n\n      vec4 renderImage(vec2 uvCoord) {\n          vec2 fragCoord = uvCoord * uResolution.xy;\n          vec2 uv = (2.0 * fragCoord - uResolution.xy) / min(uResolution.x, uResolution.y);\n\n          for (float i = 1.0; i < 10.0; i++){\n              uv.x += uAmplitude / i * cos(i * uFrequencyX * uv.y + uTime + uMouse.x * 3.14159);\n              uv.y += uAmplitude / i * cos(i * uFrequencyY * uv.x + uTime + uMouse.y * 3.14159);\n          }\n\n          vec2 diff = (uvCoord - uMouse);\n          float dist = length(diff);\n          float falloff = exp(-dist * 20.0);\n          float ripple = sin(10.0 * dist - uTime * 2.0) * 0.03;\n          uv += (diff / (dist + 0.0001)) * ripple * falloff;\n\n          vec3 color = uBaseColor / abs(sin(uTime - uv.y - uv.x));\n          return vec4(color, 1.0);\n      }\n\n      void main() {\n          vec4 col = vec4(0.0);\n          int samples = 0;\n          for (int i = -1; i <= 1; i++){\n              for (int j = -1; j <= 1; j++){\n                  vec2 offset = vec2(float(i), float(j)) * (1.0 / min(uResolution.x, uResolution.y));\n                  col += renderImage(vUv + offset);\n                  samples++;\n              }\n          }\n          gl_FragColor = col / float(samples);\n      }\n    ", uniforms: { uTime: { value: 0 }, uResolution: { value: new Float32Array([n2.canvas.width, n2.canvas.height, n2.canvas.width / n2.canvas.height]) }, uBaseColor: { value: new Float32Array(o2) }, uAmplitude: { value: s2 }, uFrequencyX: { value: c2 }, uFrequencyY: { value: l2 }, uMouse: { value: new Float32Array([0, 0]) } } }), h3 = new Mesh(n2, { geometry: i2, program: r2 });
    function m2() {
      t2.setSize(1 * e2.offsetWidth, 1 * e2.offsetHeight);
      const i3 = r2.uniforms.uResolution.value;
      i3[0] = n2.canvas.width, i3[1] = n2.canvas.height, i3[2] = n2.canvas.width / n2.canvas.height;
    }
    function p2(t3) {
      const n3 = e2.getBoundingClientRect(), i3 = (t3.clientX - n3.left) / n3.width, o3 = 1 - (t3.clientY - n3.top) / n3.height, a3 = r2.uniforms.uMouse.value;
      a3[0] = i3, a3[1] = o3;
    }
    function f2(t3) {
      if (t3.touches.length > 0) {
        const n3 = t3.touches[0], i3 = e2.getBoundingClientRect(), o3 = (n3.clientX - i3.left) / i3.width, a3 = 1 - (n3.clientY - i3.top) / i3.height, s3 = r2.uniforms.uMouse.value;
        s3[0] = o3, s3[1] = a3;
      }
    }
    let v2;
    return window.addEventListener("resize", m2), m2(), u2 && (e2.addEventListener("mousemove", p2), e2.addEventListener("touchmove", f2)), v2 = requestAnimationFrame(function e3(n3) {
      v2 = requestAnimationFrame(e3), r2.uniforms.uTime.value = 1e-3 * n3 * a2, t2.render({ scene: h3 });
    }), e2.appendChild(n2.canvas), () => {
      var _a;
      cancelAnimationFrame(v2), window.removeEventListener("resize", m2), u2 && (e2.removeEventListener("mousemove", p2), e2.removeEventListener("touchmove", f2)), n2.canvas.parentElement && n2.canvas.parentElement.removeChild(n2.canvas), (_a = n2.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
    };
  }, [o2, a2, s2, c2, l2, u2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".liquidChrome-container {\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: d2, className: "liquidChrome-container", ...h2 })] });
};
var Co = ({ direction: o2 = "right", speed: a2 = 1, borderColor: s2 = "#999", squareSize: c2 = 40, hoverFillColor: l2 = "#222" }) => {
  const u2 = (0, import_react3.useRef)(null), h2 = (0, import_react3.useRef)(null), d2 = (0, import_react3.useRef)(0), m2 = (0, import_react3.useRef)(0), p2 = (0, import_react3.useRef)({ x: 0, y: 0 }), f2 = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    const e2 = u2.current;
    if (!e2) return;
    const t2 = e2.getContext("2d"), n2 = () => {
      e2.width = e2.offsetWidth, e2.height = e2.offsetHeight, d2.current = Math.ceil(e2.width / c2) + 1, m2.current = Math.ceil(e2.height / c2) + 1;
    };
    window.addEventListener("resize", n2), n2();
    const i2 = () => {
      const n3 = Math.max(a2, 0.1);
      switch (o2) {
        case "right":
          p2.current.x = (p2.current.x - n3 + c2) % c2;
          break;
        case "left":
          p2.current.x = (p2.current.x + n3 + c2) % c2;
          break;
        case "up":
          p2.current.y = (p2.current.y + n3 + c2) % c2;
          break;
        case "down":
          p2.current.y = (p2.current.y - n3 + c2) % c2;
          break;
        case "diagonal":
          p2.current.x = (p2.current.x - n3 + c2) % c2, p2.current.y = (p2.current.y - n3 + c2) % c2;
      }
      (() => {
        if (!t2) return;
        t2.clearRect(0, 0, e2.width, e2.height);
        const n4 = Math.floor(p2.current.x / c2) * c2, i3 = Math.floor(p2.current.y / c2) * c2;
        for (let r4 = n4; r4 < e2.width + c2; r4 += c2) for (let o3 = i3; o3 < e2.height + c2; o3 += c2) {
          const e3 = r4 - p2.current.x % c2, a3 = o3 - p2.current.y % c2;
          f2.current && Math.floor((r4 - n4) / c2) === f2.current.x && Math.floor((o3 - i3) / c2) === f2.current.y && (t2.fillStyle = l2, t2.fillRect(e3, a3, c2, c2)), t2.strokeStyle = s2, t2.strokeRect(e3, a3, c2, c2);
        }
        const r3 = t2.createRadialGradient(e2.width / 2, e2.height / 2, 0, e2.width / 2, e2.height / 2, Math.sqrt(e2.width ** 2 + e2.height ** 2) / 2);
        r3.addColorStop(0, "rgba(0, 0, 0, 0)"), r3.addColorStop(1, "#060010"), t2.fillStyle = r3, t2.fillRect(0, 0, e2.width, e2.height);
      })(), h2.current = requestAnimationFrame(i2);
    }, r2 = (t3) => {
      const n3 = e2.getBoundingClientRect(), i3 = t3.clientX - n3.left, r3 = t3.clientY - n3.top, o3 = Math.floor(p2.current.x / c2) * c2, a3 = Math.floor(p2.current.y / c2) * c2, s3 = Math.floor((i3 + p2.current.x - o3) / c2), l3 = Math.floor((r3 + p2.current.y - a3) / c2);
      f2.current && f2.current.x === s3 && f2.current.y === l3 || (f2.current = { x: s3, y: l3 });
    }, v2 = () => {
      f2.current = null;
    };
    return e2.addEventListener("mousemove", r2), e2.addEventListener("mouseleave", v2), h2.current = requestAnimationFrame(i2), () => {
      window.removeEventListener("resize", n2), h2.current && cancelAnimationFrame(h2.current), e2.removeEventListener("mousemove", r2), e2.removeEventListener("mouseleave", v2);
    };
  }, [o2, a2, s2, l2, c2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".squares-canvas {\n  width: 100%;\n  height: 100%;\n  border: none;\n  display: block;\n}\n" }), (0, import_jsx_runtime.jsx)("canvas", { ref: u2, className: "squares-canvas" })] });
};
var Eo = ({ glitchColors: n2 = ["#2b4539", "#61dca3", "#61b3dc"], glitchSpeed: o2 = 50, centerVignette: a2 = false, outerVignette: s2 = true, smooth: c2 = true }) => {
  const l2 = (0, import_react3.useRef)(null), u2 = (0, import_react3.useRef)(null), h2 = (0, import_react3.useRef)([]), d2 = (0, import_react3.useRef)({ columns: 0, rows: 0 }), m2 = (0, import_react3.useRef)(null), p2 = (0, import_react3.useRef)(Date.now()), f2 = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "!", "@", "#", "$", "&", "*", "(", ")", "-", "_", "+", "=", "/", "[", "]", "{", "}", ";", ":", "<", ">", ",", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], v2 = () => f2[Math.floor(Math.random() * f2.length)], g2 = () => n2[Math.floor(Math.random() * n2.length)], x2 = (e2) => {
    e2 = e2.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (e3, t3, n3, i2) => t3 + t3 + n3 + n3 + i2 + i2);
    const t2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e2);
    return t2 ? { r: parseInt(t2[1], 16), g: parseInt(t2[2], 16), b: parseInt(t2[3], 16) } : null;
  }, y = () => {
    const e2 = l2.current;
    if (!e2) return;
    const t2 = e2.parentElement;
    if (!t2) return;
    const n3 = window.devicePixelRatio || 1, i2 = t2.getBoundingClientRect();
    e2.width = i2.width * n3, e2.height = i2.height * n3, e2.style.width = `${i2.width}px`, e2.style.height = `${i2.height}px`, m2.current && m2.current.setTransform(n3, 0, 0, n3, 0, 0);
    const { columns: r2, rows: o3 } = (a3 = i2.width, s3 = i2.height, { columns: Math.ceil(a3 / 10), rows: Math.ceil(s3 / 20) });
    var a3, s3;
    ((e3, t3) => {
      d2.current = { columns: e3, rows: t3 };
      const n4 = e3 * t3;
      h2.current = Array.from({ length: n4 }, () => ({ char: v2(), color: g2(), targetColor: g2(), colorProgress: 1 }));
    })(r2, o3), w();
  }, w = () => {
    if (!m2.current || 0 === h2.current.length) return;
    const e2 = m2.current, { width: t2, height: n3 } = l2.current.getBoundingClientRect();
    e2.clearRect(0, 0, t2, n3), e2.font = "16px monospace", e2.textBaseline = "top", h2.current.forEach((t3, n4) => {
      const i2 = n4 % d2.current.columns * 10, r2 = 20 * Math.floor(n4 / d2.current.columns);
      e2.fillStyle = t3.color, e2.fillText(t3.char, i2, r2);
    });
  }, b = () => {
    let e2 = false;
    h2.current.forEach((t2) => {
      if (t2.colorProgress < 1) {
        t2.colorProgress += 0.05, t2.colorProgress > 1 && (t2.colorProgress = 1);
        const o3 = x2(t2.color), a3 = x2(t2.targetColor);
        o3 && a3 && (t2.color = (n3 = o3, i2 = a3, r2 = t2.colorProgress, `rgb(${Math.round(n3.r + (i2.r - n3.r) * r2)}, ${Math.round(n3.g + (i2.g - n3.g) * r2)}, ${Math.round(n3.b + (i2.b - n3.b) * r2)})`), e2 = true);
      }
      var n3, i2, r2;
    }), e2 && w();
  }, M = () => {
    const e2 = Date.now();
    e2 - p2.current >= o2 && ((() => {
      if (!h2.current || 0 === h2.current.length) return;
      const e3 = Math.max(1, Math.floor(0.05 * h2.current.length));
      for (let t2 = 0; t2 < e3; t2++) {
        const e4 = Math.floor(Math.random() * h2.current.length);
        h2.current[e4] && (h2.current[e4].char = v2(), h2.current[e4].targetColor = g2(), c2 ? h2.current[e4].colorProgress = 0 : (h2.current[e4].color = h2.current[e4].targetColor, h2.current[e4].colorProgress = 1));
      }
    })(), w(), p2.current = e2), c2 && b(), u2.current = requestAnimationFrame(M);
  };
  (0, import_react3.useEffect)(() => {
    const e2 = l2.current;
    if (!e2) return;
    let t2;
    m2.current = e2.getContext("2d"), y(), M();
    const n3 = () => {
      clearTimeout(t2), t2 = setTimeout(() => {
        cancelAnimationFrame(u2.current), y(), M();
      }, 100);
    };
    return window.addEventListener("resize", n3), () => {
      cancelAnimationFrame(u2.current), window.removeEventListener("resize", n3);
    };
  }, [o2, c2]);
  return (0, import_jsx_runtime.jsxs)("div", { style: { position: "relative", width: "100%", height: "100%", backgroundColor: "#000000", overflow: "hidden" }, children: [(0, import_jsx_runtime.jsx)("canvas", { ref: l2, style: { display: "block", width: "100%", height: "100%" } }), s2 && (0, import_jsx_runtime.jsx)("div", { style: { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", pointerEvents: "none", background: "radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,1) 100%)" } }), a2 && (0, import_jsx_runtime.jsx)("div", { style: { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", pointerEvents: "none", background: "radial-gradient(circle, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 60%)" } })] });
};
var zo = ["#ffffff", "#ffffff", "#ffffff"];
var _o = (e2) => {
  3 === (e2 = e2.replace(/^#/, "")).length && (e2 = e2.split("").map((e3) => e3 + e3).join(""));
  const t2 = parseInt(e2, 16);
  return [(t2 >> 16 & 255) / 255, (t2 >> 8 & 255) / 255, (255 & t2) / 255];
};
var To = ({ particleCount: o2 = 200, particleSpread: a2 = 10, speed: s2 = 0.1, particleColors: c2, moveParticlesOnHover: l2 = false, particleHoverFactor: u2 = 1, alphaParticles: h2 = false, particleBaseSize: d2 = 100, sizeRandomness: m2 = 1, cameraDistance: p2 = 20, disableRotation: f2 = false, className: v2 }) => {
  const g2 = (0, import_react3.useRef)(null), x2 = (0, import_react3.useRef)({ x: 0, y: 0 });
  return (0, import_react3.useEffect)(() => {
    const e2 = g2.current;
    if (!e2) return;
    const t2 = new Renderer({ depth: false, alpha: true }), n2 = t2.gl;
    e2.appendChild(n2.canvas), n2.clearColor(0, 0, 0, 0);
    const i2 = new Camera(n2, { fov: 15 });
    i2.position.set(0, 0, p2);
    const r2 = () => {
      const r3 = e2.clientWidth, o3 = e2.clientHeight;
      t2.setSize(r3, o3), i2.perspective({ aspect: n2.canvas.width / n2.canvas.height });
    };
    window.addEventListener("resize", r2, false), r2();
    const v3 = (t3) => {
      const n3 = e2.getBoundingClientRect(), i3 = (t3.clientX - n3.left) / n3.width * 2 - 1, r3 = -((t3.clientY - n3.top) / n3.height * 2 - 1);
      x2.current = { x: i3, y: r3 };
    };
    l2 && e2.addEventListener("mousemove", v3);
    const y = o2, w = new Float32Array(3 * y), b = new Float32Array(4 * y), M = new Float32Array(3 * y), P = c2 && c2.length > 0 ? c2 : zo;
    for (let e3 = 0; e3 < y; e3++) {
      let t3, n3, i3, r3;
      do {
        t3 = 2 * Math.random() - 1, n3 = 2 * Math.random() - 1, i3 = 2 * Math.random() - 1, r3 = t3 * t3 + n3 * n3 + i3 * i3;
      } while (r3 > 1 || 0 === r3);
      const o3 = Math.cbrt(Math.random());
      w.set([t3 * o3, n3 * o3, i3 * o3], 3 * e3), b.set([Math.random(), Math.random(), Math.random(), Math.random()], 4 * e3);
      const a3 = _o(P[Math.floor(Math.random() * P.length)]);
      M.set(a3, 3 * e3);
    }
    const S = new Geometry(n2, { position: { size: 3, data: w }, random: { size: 4, data: b }, color: { size: 3, data: M } }), C = new Program(n2, { vertex: "\n  attribute vec3 position;\n  attribute vec4 random;\n  attribute vec3 color;\n  \n  uniform mat4 modelMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform float uTime;\n  uniform float uSpread;\n  uniform float uBaseSize;\n  uniform float uSizeRandomness;\n  \n  varying vec4 vRandom;\n  varying vec3 vColor;\n  \n  void main() {\n    vRandom = random;\n    vColor = color;\n    \n    vec3 pos = position * uSpread;\n    pos.z *= 10.0;\n    \n    vec4 mPos = modelMatrix * vec4(pos, 1.0);\n    float t = uTime;\n    mPos.x += sin(t * random.z + 6.28 * random.w) * mix(0.1, 1.5, random.x);\n    mPos.y += sin(t * random.y + 6.28 * random.x) * mix(0.1, 1.5, random.w);\n    mPos.z += sin(t * random.w + 6.28 * random.y) * mix(0.1, 1.5, random.z);\n    \n    vec4 mvPos = viewMatrix * mPos;\n    gl_PointSize = (uBaseSize * (1.0 + uSizeRandomness * (random.x - 0.5))) / length(mvPos.xyz);\n    gl_Position = projectionMatrix * mvPos;\n  }\n", fragment: "\n  precision highp float;\n  \n  uniform float uTime;\n  uniform float uAlphaParticles;\n  varying vec4 vRandom;\n  varying vec3 vColor;\n  \n  void main() {\n    vec2 uv = gl_PointCoord.xy;\n    float d = length(uv - vec2(0.5));\n    \n    if(uAlphaParticles < 0.5) {\n      if(d > 0.5) {\n        discard;\n      }\n      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), 1.0);\n    } else {\n      float circle = smoothstep(0.5, 0.4, d) * 0.8;\n      gl_FragColor = vec4(vColor + 0.2 * sin(uv.yxx + uTime + vRandom.y * 6.28), circle);\n    }\n  }\n", uniforms: { uTime: { value: 0 }, uSpread: { value: a2 }, uBaseSize: { value: d2 }, uSizeRandomness: { value: m2 }, uAlphaParticles: { value: h2 ? 1 : 0 } }, transparent: true, depthTest: false }), E = new Mesh(n2, { mode: n2.POINTS, geometry: S, program: C });
    let z, _ = performance.now(), T = 0;
    const A = (e3) => {
      z = requestAnimationFrame(A);
      const n3 = e3 - _;
      _ = e3, T += n3 * s2, C.uniforms.uTime.value = 1e-3 * T, l2 ? (E.position.x = -x2.current.x * u2, E.position.y = -x2.current.y * u2) : (E.position.x = 0, E.position.y = 0), f2 || (E.rotation.x = 0.1 * Math.sin(2e-4 * T), E.rotation.y = 0.15 * Math.cos(5e-4 * T), E.rotation.z += 0.01 * s2), t2.render({ scene: E, camera: i2 });
    };
    return z = requestAnimationFrame(A), () => {
      window.removeEventListener("resize", r2), l2 && e2.removeEventListener("mousemove", v3), cancelAnimationFrame(z), e2.contains(n2.canvas) && e2.removeChild(n2.canvas);
    };
  }, [o2, a2, s2, l2, u2, h2, d2, m2, p2, f2]), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: ".particles-container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}" }), (0, import_jsx_runtime.jsx)("div", { ref: g2, className: `particles-container ${v2}` })] });
};
var Ao = class {
  constructor(e2, t2, n2) {
    this.x = e2, this.y = t2, this.z = n2;
  }
  dot2(e2, t2) {
    return this.x * e2 + this.y * t2;
  }
};
var Ro = class {
  constructor(e2 = 0) {
    this.grad3 = [new Ao(1, 1, 0), new Ao(-1, 1, 0), new Ao(1, -1, 0), new Ao(-1, -1, 0), new Ao(1, 0, 1), new Ao(-1, 0, 1), new Ao(1, 0, -1), new Ao(-1, 0, -1), new Ao(0, 1, 1), new Ao(0, -1, 1), new Ao(0, 1, -1), new Ao(0, -1, -1)], this.p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], this.perm = new Array(512), this.gradP = new Array(512), this.seed(e2);
  }
  seed(e2) {
    e2 > 0 && e2 < 1 && (e2 *= 65536), (e2 = Math.floor(e2)) < 256 && (e2 |= e2 << 8);
    for (let t2 = 0; t2 < 256; t2++) {
      let n2 = 1 & t2 ? this.p[t2] ^ 255 & e2 : this.p[t2] ^ e2 >> 8 & 255;
      this.perm[t2] = this.perm[t2 + 256] = n2, this.gradP[t2] = this.gradP[t2 + 256] = this.grad3[n2 % 12];
    }
  }
  fade(e2) {
    return e2 * e2 * e2 * (e2 * (6 * e2 - 15) + 10);
  }
  lerp(e2, t2, n2) {
    return (1 - n2) * e2 + n2 * t2;
  }
  perlin2(e2, t2) {
    let n2 = Math.floor(e2), i2 = Math.floor(t2);
    e2 -= n2, t2 -= i2, n2 &= 255, i2 &= 255;
    const r2 = this.gradP[n2 + this.perm[i2]].dot2(e2, t2), o2 = this.gradP[n2 + this.perm[i2 + 1]].dot2(e2, t2 - 1), a2 = this.gradP[n2 + 1 + this.perm[i2]].dot2(e2 - 1, t2), s2 = this.gradP[n2 + 1 + this.perm[i2 + 1]].dot2(e2 - 1, t2 - 1), c2 = this.fade(e2);
    return this.lerp(this.lerp(r2, a2, c2), this.lerp(o2, s2, c2), this.fade(t2));
  }
};
var Io = ({ lineColor: o2 = "black", backgroundColor: a2 = "transparent", waveSpeedX: s2 = 0.0125, waveSpeedY: c2 = 5e-3, waveAmpX: l2 = 32, waveAmpY: u2 = 16, xGap: h2 = 10, yGap: d2 = 32, friction: m2 = 0.925, tension: p2 = 5e-3, maxCursorMove: f2 = 100, style: v2 = {}, className: g2 = "" }) => {
  const x2 = (0, import_react3.useRef)(null), y = (0, import_react3.useRef)(null), w = (0, import_react3.useRef)(null), b = (0, import_react3.useRef)({ width: 0, height: 0, left: 0, top: 0 }), M = (0, import_react3.useRef)(new Ro(Math.random())), P = (0, import_react3.useRef)([]), S = (0, import_react3.useRef)({ x: -10, y: 0, lx: 0, ly: 0, sx: 0, sy: 0, v: 0, vs: 0, a: 0, set: false }), C = (0, import_react3.useRef)({ lineColor: o2, waveSpeedX: s2, waveSpeedY: c2, waveAmpX: l2, waveAmpY: u2, friction: m2, tension: p2, maxCursorMove: f2, xGap: h2, yGap: d2 }), E = (0, import_react3.useRef)(null);
  return (0, import_react3.useEffect)(() => {
    C.current = { lineColor: o2, waveSpeedX: s2, waveSpeedY: c2, waveAmpX: l2, waveAmpY: u2, friction: m2, tension: p2, maxCursorMove: f2, xGap: h2, yGap: d2 };
  }, [o2, s2, c2, l2, u2, m2, p2, f2, h2, d2]), (0, import_react3.useEffect)(() => {
    const e2 = y.current, t2 = x2.current;
    if (e2 && t2) return w.current = e2.getContext("2d"), n2(), i2(), E.current = requestAnimationFrame(function e3(n3) {
      if (!t2) return;
      const i3 = S.current;
      i3.sx += 0.1 * (i3.x - i3.sx), i3.sy += 0.1 * (i3.y - i3.sy);
      const o4 = i3.x - i3.lx, a4 = i3.y - i3.ly, s4 = Math.hypot(o4, a4);
      i3.v = s4, i3.vs += 0.1 * (s4 - i3.vs), i3.vs = Math.min(100, i3.vs), i3.lx = i3.x, i3.ly = i3.y, i3.a = Math.atan2(a4, o4), t2.style.setProperty("--x", `${i3.sx}px`), t2.style.setProperty("--y", `${i3.sy}px`), function(e4) {
        const t3 = P.current, n4 = S.current, i4 = M.current, { waveSpeedX: r3, waveSpeedY: o5, waveAmpX: a5, waveAmpY: s5, friction: c4, tension: l3, maxCursorMove: u3 } = C.current;
        t3.forEach((t4) => {
          t4.forEach((t5) => {
            const h3 = 12 * i4.perlin2(2e-3 * (t5.x + e4 * r3), 15e-4 * (t5.y + e4 * o5));
            t5.wave.x = Math.cos(h3) * a5, t5.wave.y = Math.sin(h3) * s5;
            const d3 = t5.x - n4.sx, m3 = t5.y - n4.sy, p3 = Math.hypot(d3, m3), f3 = Math.max(175, n4.vs);
            if (p3 < f3) {
              const e5 = 1 - p3 / f3, i5 = Math.cos(1e-3 * p3) * e5;
              t5.cursor.vx += Math.cos(n4.a) * i5 * f3 * n4.vs * 65e-5, t5.cursor.vy += Math.sin(n4.a) * i5 * f3 * n4.vs * 65e-5;
            }
            t5.cursor.vx += (0 - t5.cursor.x) * l3, t5.cursor.vy += (0 - t5.cursor.y) * l3, t5.cursor.vx *= c4, t5.cursor.vy *= c4, t5.cursor.x += 2 * t5.cursor.vx, t5.cursor.y += 2 * t5.cursor.vy, t5.cursor.x = Math.min(u3, Math.max(-u3, t5.cursor.x)), t5.cursor.y = Math.min(u3, Math.max(-u3, t5.cursor.y));
          });
        });
      }(n3), function() {
        const { width: e4, height: t3 } = b.current, n4 = w.current;
        n4 && (n4.clearRect(0, 0, e4, t3), n4.beginPath(), n4.strokeStyle = C.current.lineColor, P.current.forEach((e5) => {
          let t4 = r2(e5[0], false);
          n4.moveTo(t4.x, t4.y), e5.forEach((i4, o5) => {
            const a5 = o5 === e5.length - 1;
            t4 = r2(i4, !a5);
            const s5 = r2(e5[o5 + 1] || e5[e5.length - 1], !a5);
            n4.lineTo(t4.x, t4.y), a5 && n4.moveTo(s5.x, s5.y);
          });
        }), n4.stroke());
      }(), E.current = requestAnimationFrame(e3);
    }), window.addEventListener("resize", o3), window.addEventListener("mousemove", a3), window.addEventListener("touchmove", s3, { passive: false }), () => {
      window.removeEventListener("resize", o3), window.removeEventListener("mousemove", a3), window.removeEventListener("touchmove", s3), null !== E.current && cancelAnimationFrame(E.current);
    };
    function n2() {
      if (!t2 || !e2) return;
      const n3 = t2.getBoundingClientRect();
      b.current = { width: n3.width, height: n3.height, left: n3.left, top: n3.top }, e2.width = n3.width, e2.height = n3.height;
    }
    function i2() {
      const { width: e3, height: t3 } = b.current;
      P.current = [];
      const n3 = e3 + 200, i3 = t3 + 30, { xGap: r3, yGap: o4 } = C.current, a4 = Math.ceil(n3 / r3), s4 = Math.ceil(i3 / o4), c4 = (e3 - r3 * a4) / 2, l3 = (t3 - o4 * s4) / 2;
      for (let e4 = 0; e4 <= a4; e4++) {
        const t4 = [];
        for (let n4 = 0; n4 <= s4; n4++) t4.push({ x: c4 + r3 * e4, y: l3 + o4 * n4, wave: { x: 0, y: 0 }, cursor: { x: 0, y: 0, vx: 0, vy: 0 } });
        P.current.push(t4);
      }
    }
    function r2(e3, t3 = true) {
      const n3 = e3.x + e3.wave.x + (t3 ? e3.cursor.x : 0), i3 = e3.y + e3.wave.y + (t3 ? e3.cursor.y : 0);
      return { x: Math.round(10 * n3) / 10, y: Math.round(10 * i3) / 10 };
    }
    function o3() {
      n2(), i2();
    }
    function a3(e3) {
      c3(e3.clientX, e3.clientY);
    }
    function s3(e3) {
      const t3 = e3.touches[0];
      c3(t3.clientX, t3.clientY);
    }
    function c3(e3, t3) {
      const n3 = S.current, i3 = b.current;
      n3.x = e3 - i3.left, n3.y = t3 - i3.top, n3.set || (n3.sx = n3.x, n3.sy = n3.y, n3.lx = n3.x, n3.ly = n3.y, n3.set = true);
    }
  }, []), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("style", { children: '.waves {\n  position: absolute;\n  top: 0;\n  left: 0;\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\n.waves::before {\n  content: "";\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 0.5rem;\n  height: 0.5rem;\n  background: #160000;\n  border-radius: 50%;\n  transform: translate3d(calc(var(-0.5rem) - 50%), calc(var(50%) - 50%), 0);\n  will-change: transform;\n}\n\n.waves-canvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n}' }), " ", (0, import_jsx_runtime.jsx)("div", { ref: x2, className: `waves ${g2}`, style: { position: "absolute", top: 0, left: 0, margin: 0, padding: 0, width: "100%", height: "100%", overflow: "hidden", backgroundColor: a2, ...v2 }, children: (0, import_jsx_runtime.jsx)("canvas", { ref: y, className: "waves-canvas" }) })] });
};
export {
  Tt as AnimatedContent,
  an as AnimatedList,
  wt as AsciiText,
  Fi as Aurora,
  Ai as Backgrounds,
  Hi as Balatro,
  bo as Ballpit,
  Ni as Beams,
  rn as BlobCursor,
  et as BlurText,
  Et as Bounce,
  Jn as CardSwap,
  Wn as Carousel,
  hn as ChromeGrid,
  qn as CircularGallery,
  it as CircularText,
  _t as ClickSpark,
  Ct as CountUp,
  ui as Counter,
  qt as Crosshair,
  ii as DecayCard,
  ht as DecryptedText,
  $i as Dither,
  Ln as Dock,
  Ki as DotGrid,
  ai as ElasticSlider,
  At as FadeContent,
  ct as FallingText,
  ri as FlowingMenu,
  Kn as FlyingPosters,
  mn as Folder,
  at as FuzzyText,
  It as GlareHover,
  ni as GlassIcons,
  Mt as GlitchText,
  Fn as GooeyNav,
  st as GradientText,
  Cr as GridDistortion,
  Po as GridMotion,
  Pr as Hyperspeed,
  jt as ImageTrail,
  wi as InfiniteMenu,
  ei as InfiniteScroll,
  Sr as Iridescence,
  Eo as LetterGlitch,
  Vi as Lightning,
  So as LiquidChrome,
  Ft as Magnet,
  Lt as MagnetLines,
  nn as MetaBalls,
  Ot as MetallicPaint,
  bn as ModelViewer,
  Vt as Noise,
  Mo as Orb,
  Bn as PixelCard,
  Bt as PixelTrail,
  Rt as PixelTransition,
  Tn as ProfileCard,
  Zt as Ribbons,
  Mi as RollingGallery,
  bt as ScrambleText,
  mt as ScrollFloat,
  pt as ScrollReveal,
  Pt as ScrollVelocity,
  Gi as ShapeBlur,
  rt as ShinyText,
  Li as Silk,
  Kt as SplashCursor,
  Je as SplitText,
  Hn as SpotlightCard,
  Co as Squares,
  cn as Stack,
  zt as StarBorder,
  Pi as Stepper,
  lt as TextCursor,
  ot as TextPressure,
  Qi as Threads,
  un as TiltedCard,
  dt as TrueFocus,
  St as VariableProximity,
  Io as Waves,
  To as particles
};
//# sourceMappingURL=@appletosolutions_reactbits.js.map
